webpackJsonp([3,5],{

/***/ 100:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(255))

/***/ }),

/***/ 101:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(256))

/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(257))

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(258))

/***/ }),

/***/ 18:
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	if (typeof execScript !== "undefined")
		execScript(src);
	else
		eval.call(null, src);
}


/***/ }),

/***/ 252:
/***/ (function(module, exports) {

module.exports = "//     Backbone.js 1.3.3\r\n\r\n//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n//     Backbone may be freely distributed under the MIT license.\r\n//     For all details and documentation:\r\n//     http://backbonejs.org\r\n\r\n(function(factory) {\r\n\r\n  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\r\n  // We use `self` instead of `window` for `WebWorker` support.\r\n  var root = (typeof self == 'object' && self.self === self && self) ||\r\n            (typeof global == 'object' && global.global === global && global);\r\n\r\n  // Set up Backbone appropriately for the environment. Start with AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\r\n      // Export global even in AMD case in case this script is loaded with\r\n      // others that may still expect a global Backbone.\r\n      root.Backbone = factory(root, exports, _, $);\r\n    });\r\n\r\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\r\n  } else if (typeof exports !== 'undefined') {\r\n    var _ = require('underscore'), $;\r\n    try { $ = require('jquery'); } catch (e) {}\r\n    factory(root, exports, _, $);\r\n\r\n  // Finally, as a browser global.\r\n  } else {\r\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\r\n  }\r\n\r\n})(function(root, Backbone, _, $) {\r\n\r\n  // Initial Setup\r\n  // -------------\r\n\r\n  // Save the previous value of the `Backbone` variable, so that it can be\r\n  // restored later on, if `noConflict` is used.\r\n  var previousBackbone = root.Backbone;\r\n\r\n  // Create a local reference to a common array method we'll want to use later.\r\n  var slice = Array.prototype.slice;\r\n\r\n  // Current version of the library. Keep in sync with `package.json`.\r\n  Backbone.VERSION = '1.3.3';\r\n\r\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\r\n  // the `$` variable.\r\n  Backbone.$ = $;\r\n\r\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\r\n  // to its previous owner. Returns a reference to this Backbone object.\r\n  Backbone.noConflict = function() {\r\n    root.Backbone = previousBackbone;\r\n    return this;\r\n  };\r\n\r\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\r\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\r\n  // set a `X-Http-Method-Override` header.\r\n  Backbone.emulateHTTP = false;\r\n\r\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\r\n  // `application/json` requests ... this will encode the body as\r\n  // `application/x-www-form-urlencoded` instead and will send the model in a\r\n  // form param named `model`.\r\n  Backbone.emulateJSON = false;\r\n\r\n  // Proxy Backbone class methods to Underscore functions, wrapping the model's\r\n  // `attributes` object or collection's `models` array behind the scenes.\r\n  //\r\n  // collection.filter(function(model) { return model.get('age') > 10 });\r\n  // collection.each(this.addView);\r\n  //\r\n  // `Function#apply` can be slow so we use the method's arg count, if we know it.\r\n  var addMethod = function(length, method, attribute) {\r\n    switch (length) {\r\n      case 1: return function() {\r\n        return _[method](this[attribute]);\r\n      };\r\n      case 2: return function(value) {\r\n        return _[method](this[attribute], value);\r\n      };\r\n      case 3: return function(iteratee, context) {\r\n        return _[method](this[attribute], cb(iteratee, this), context);\r\n      };\r\n      case 4: return function(iteratee, defaultVal, context) {\r\n        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);\r\n      };\r\n      default: return function() {\r\n        var args = slice.call(arguments);\r\n        args.unshift(this[attribute]);\r\n        return _[method].apply(_, args);\r\n      };\r\n    }\r\n  };\r\n  var addUnderscoreMethods = function(Class, methods, attribute) {\r\n    _.each(methods, function(length, method) {\r\n      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);\r\n    });\r\n  };\r\n\r\n  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\r\n  var cb = function(iteratee, instance) {\r\n    if (_.isFunction(iteratee)) return iteratee;\r\n    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\r\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\r\n    return iteratee;\r\n  };\r\n  var modelMatcher = function(attrs) {\r\n    var matcher = _.matches(attrs);\r\n    return function(model) {\r\n      return matcher(model.attributes);\r\n    };\r\n  };\r\n\r\n  // Backbone.Events\r\n  // ---------------\r\n\r\n  // A module that can be mixed in to *any object* in order to provide it with\r\n  // a custom event channel. You may bind a callback to an event with `on` or\r\n  // remove with `off`; `trigger`-ing an event fires all callbacks in\r\n  // succession.\r\n  //\r\n  //     var object = {};\r\n  //     _.extend(object, Backbone.Events);\r\n  //     object.on('expand', function(){ alert('expanded'); });\r\n  //     object.trigger('expand');\r\n  //\r\n  var Events = Backbone.Events = {};\r\n\r\n  // Regular expression used to split event strings.\r\n  var eventSplitter = /\\s+/;\r\n\r\n  // Iterates over the standard `event, callback` (as well as the fancy multiple\r\n  // space-separated events `\"change blur\", callback` and jQuery-style event\r\n  // maps `{event: callback}`).\r\n  var eventsApi = function(iteratee, events, name, callback, opts) {\r\n    var i = 0, names;\r\n    if (name && typeof name === 'object') {\r\n      // Handle event maps.\r\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\r\n      for (names = _.keys(name); i < names.length ; i++) {\r\n        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\r\n      }\r\n    } else if (name && eventSplitter.test(name)) {\r\n      // Handle space-separated event names by delegating them individually.\r\n      for (names = name.split(eventSplitter); i < names.length; i++) {\r\n        events = iteratee(events, names[i], callback, opts);\r\n      }\r\n    } else {\r\n      // Finally, standard events.\r\n      events = iteratee(events, name, callback, opts);\r\n    }\r\n    return events;\r\n  };\r\n\r\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\r\n  // the callback to all events fired.\r\n  Events.on = function(name, callback, context) {\r\n    return internalOn(this, name, callback, context);\r\n  };\r\n\r\n  // Guard the `listening` argument from the public API.\r\n  var internalOn = function(obj, name, callback, context, listening) {\r\n    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\r\n      context: context,\r\n      ctx: obj,\r\n      listening: listening\r\n    });\r\n\r\n    if (listening) {\r\n      var listeners = obj._listeners || (obj._listeners = {});\r\n      listeners[listening.id] = listening;\r\n    }\r\n\r\n    return obj;\r\n  };\r\n\r\n  // Inversion-of-control versions of `on`. Tell *this* object to listen to\r\n  // an event in another object... keeping track of what it's listening to\r\n  // for easier unbinding later.\r\n  Events.listenTo = function(obj, name, callback) {\r\n    if (!obj) return this;\r\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\r\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\r\n    var listening = listeningTo[id];\r\n\r\n    // This object is not listening to any other events on `obj` yet.\r\n    // Setup the necessary references to track the listening callbacks.\r\n    if (!listening) {\r\n      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));\r\n      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\r\n    }\r\n\r\n    // Bind callbacks on obj, and keep track of them on listening.\r\n    internalOn(obj, name, callback, this, listening);\r\n    return this;\r\n  };\r\n\r\n  // The reducing API that adds a callback to the `events` object.\r\n  var onApi = function(events, name, callback, options) {\r\n    if (callback) {\r\n      var handlers = events[name] || (events[name] = []);\r\n      var context = options.context, ctx = options.ctx, listening = options.listening;\r\n      if (listening) listening.count++;\r\n\r\n      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});\r\n    }\r\n    return events;\r\n  };\r\n\r\n  // Remove one or many callbacks. If `context` is null, removes all\r\n  // callbacks with that function. If `callback` is null, removes all\r\n  // callbacks for the event. If `name` is null, removes all bound\r\n  // callbacks for all events.\r\n  Events.off = function(name, callback, context) {\r\n    if (!this._events) return this;\r\n    this._events = eventsApi(offApi, this._events, name, callback, {\r\n      context: context,\r\n      listeners: this._listeners\r\n    });\r\n    return this;\r\n  };\r\n\r\n  // Tell this object to stop listening to either specific events ... or\r\n  // to every object it's currently listening to.\r\n  Events.stopListening = function(obj, name, callback) {\r\n    var listeningTo = this._listeningTo;\r\n    if (!listeningTo) return this;\r\n\r\n    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\r\n\r\n    for (var i = 0; i < ids.length; i++) {\r\n      var listening = listeningTo[ids[i]];\r\n\r\n      // If listening doesn't exist, this object is not currently\r\n      // listening to obj. Break out early.\r\n      if (!listening) break;\r\n\r\n      listening.obj.off(name, callback, this);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  // The reducing API that removes a callback from the `events` object.\r\n  var offApi = function(events, name, callback, options) {\r\n    if (!events) return;\r\n\r\n    var i = 0, listening;\r\n    var context = options.context, listeners = options.listeners;\r\n\r\n    // Delete all events listeners and \"drop\" events.\r\n    if (!name && !callback && !context) {\r\n      var ids = _.keys(listeners);\r\n      for (; i < ids.length; i++) {\r\n        listening = listeners[ids[i]];\r\n        delete listeners[listening.id];\r\n        delete listening.listeningTo[listening.objId];\r\n      }\r\n      return;\r\n    }\r\n\r\n    var names = name ? [name] : _.keys(events);\r\n    for (; i < names.length; i++) {\r\n      name = names[i];\r\n      var handlers = events[name];\r\n\r\n      // Bail out if there are no events stored.\r\n      if (!handlers) break;\r\n\r\n      // Replace events if there are any remaining.  Otherwise, clean up.\r\n      var remaining = [];\r\n      for (var j = 0; j < handlers.length; j++) {\r\n        var handler = handlers[j];\r\n        if (\r\n          callback && callback !== handler.callback &&\r\n            callback !== handler.callback._callback ||\r\n              context && context !== handler.context\r\n        ) {\r\n          remaining.push(handler);\r\n        } else {\r\n          listening = handler.listening;\r\n          if (listening && --listening.count === 0) {\r\n            delete listeners[listening.id];\r\n            delete listening.listeningTo[listening.objId];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update tail event if the list has any events.  Otherwise, clean up.\r\n      if (remaining.length) {\r\n        events[name] = remaining;\r\n      } else {\r\n        delete events[name];\r\n      }\r\n    }\r\n    return events;\r\n  };\r\n\r\n  // Bind an event to only be triggered a single time. After the first time\r\n  // the callback is invoked, its listener will be removed. If multiple events\r\n  // are passed in using the space-separated syntax, the handler will fire\r\n  // once for each event, not once for a combination of all events.\r\n  Events.once = function(name, callback, context) {\r\n    // Map the event into a `{event: once}` object.\r\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));\r\n    if (typeof name === 'string' && context == null) callback = void 0;\r\n    return this.on(events, callback, context);\r\n  };\r\n\r\n  // Inversion-of-control versions of `once`.\r\n  Events.listenToOnce = function(obj, name, callback) {\r\n    // Map the event into a `{event: once}` object.\r\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));\r\n    return this.listenTo(obj, events);\r\n  };\r\n\r\n  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\r\n  // `offer` unbinds the `onceWrapper` after it has been called.\r\n  var onceMap = function(map, name, callback, offer) {\r\n    if (callback) {\r\n      var once = map[name] = _.once(function() {\r\n        offer(name, once);\r\n        callback.apply(this, arguments);\r\n      });\r\n      once._callback = callback;\r\n    }\r\n    return map;\r\n  };\r\n\r\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\r\n  // passed the same arguments as `trigger` is, apart from the event name\r\n  // (unless you're listening on `\"all\"`, which will cause your callback to\r\n  // receive the true name of the event as the first argument).\r\n  Events.trigger = function(name) {\r\n    if (!this._events) return this;\r\n\r\n    var length = Math.max(0, arguments.length - 1);\r\n    var args = Array(length);\r\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\r\n\r\n    eventsApi(triggerApi, this._events, name, void 0, args);\r\n    return this;\r\n  };\r\n\r\n  // Handles triggering the appropriate event callbacks.\r\n  var triggerApi = function(objEvents, name, callback, args) {\r\n    if (objEvents) {\r\n      var events = objEvents[name];\r\n      var allEvents = objEvents.all;\r\n      if (events && allEvents) allEvents = allEvents.slice();\r\n      if (events) triggerEvents(events, args);\r\n      if (allEvents) triggerEvents(allEvents, [name].concat(args));\r\n    }\r\n    return objEvents;\r\n  };\r\n\r\n  // A difficult-to-believe, but optimized internal dispatch function for\r\n  // triggering events. Tries to keep the usual cases speedy (most internal\r\n  // Backbone events have 3 arguments).\r\n  var triggerEvents = function(events, args) {\r\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\r\n    switch (args.length) {\r\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\r\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\r\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\r\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\r\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\r\n    }\r\n  };\r\n\r\n  // Aliases for backwards compatibility.\r\n  Events.bind   = Events.on;\r\n  Events.unbind = Events.off;\r\n\r\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\r\n  // want global \"pubsub\" in a convenient place.\r\n  _.extend(Backbone, Events);\r\n\r\n  // Backbone.Model\r\n  // --------------\r\n\r\n  // Backbone **Models** are the basic data object in the framework --\r\n  // frequently representing a row in a table in a database on your server.\r\n  // A discrete chunk of data and a bunch of useful, related methods for\r\n  // performing computations and transformations on that data.\r\n\r\n  // Create a new model with the specified attributes. A client id (`cid`)\r\n  // is automatically generated and assigned for you.\r\n  var Model = Backbone.Model = function(attributes, options) {\r\n    var attrs = attributes || {};\r\n    options || (options = {});\r\n    this.cid = _.uniqueId(this.cidPrefix);\r\n    this.attributes = {};\r\n    if (options.collection) this.collection = options.collection;\r\n    if (options.parse) attrs = this.parse(attrs, options) || {};\r\n    var defaults = _.result(this, 'defaults');\r\n    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\r\n    this.set(attrs, options);\r\n    this.changed = {};\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Attach all inheritable methods to the Model prototype.\r\n  _.extend(Model.prototype, Events, {\r\n\r\n    // A hash of attributes whose current and previous value differ.\r\n    changed: null,\r\n\r\n    // The value returned during the last failed validation.\r\n    validationError: null,\r\n\r\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n    // CouchDB users may want to set this to `\"_id\"`.\r\n    idAttribute: 'id',\r\n\r\n    // The prefix is used to create the client id which is used to identify models locally.\r\n    // You may want to override this if you're experiencing name clashes with model ids.\r\n    cidPrefix: 'c',\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Return a copy of the model's `attributes` object.\r\n    toJSON: function(options) {\r\n      return _.clone(this.attributes);\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default -- but override this if you need\r\n    // custom syncing semantics for *this* particular model.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the value of an attribute.\r\n    get: function(attr) {\r\n      return this.attributes[attr];\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    escape: function(attr) {\r\n      return _.escape(this.get(attr));\r\n    },\r\n\r\n    // Returns `true` if the attribute contains a value that is not null\r\n    // or undefined.\r\n    has: function(attr) {\r\n      return this.get(attr) != null;\r\n    },\r\n\r\n    // Special-cased proxy to underscore's `_.matches` method.\r\n    matches: function(attrs) {\r\n      return !!_.iteratee(attrs, this)(this.attributes);\r\n    },\r\n\r\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n    // the core primitive operation of a model, updating the data and notifying\r\n    // anyone who needs to know about the change in state. The heart of the beast.\r\n    set: function(key, val, options) {\r\n      if (key == null) return this;\r\n\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      var attrs;\r\n      if (typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options || (options = {});\r\n\r\n      // Run validation.\r\n      if (!this._validate(attrs, options)) return false;\r\n\r\n      // Extract attributes and options.\r\n      var unset      = options.unset;\r\n      var silent     = options.silent;\r\n      var changes    = [];\r\n      var changing   = this._changing;\r\n      this._changing = true;\r\n\r\n      if (!changing) {\r\n        this._previousAttributes = _.clone(this.attributes);\r\n        this.changed = {};\r\n      }\r\n\r\n      var current = this.attributes;\r\n      var changed = this.changed;\r\n      var prev    = this._previousAttributes;\r\n\r\n      // For each `set` attribute, update or delete the current value.\r\n      for (var attr in attrs) {\r\n        val = attrs[attr];\r\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\r\n        if (!_.isEqual(prev[attr], val)) {\r\n          changed[attr] = val;\r\n        } else {\r\n          delete changed[attr];\r\n        }\r\n        unset ? delete current[attr] : current[attr] = val;\r\n      }\r\n\r\n      // Update the `id`.\r\n      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\r\n\r\n      // Trigger all relevant attribute changes.\r\n      if (!silent) {\r\n        if (changes.length) this._pending = options;\r\n        for (var i = 0; i < changes.length; i++) {\r\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n        }\r\n      }\r\n\r\n      // You might be wondering why there's a `while` loop here. Changes can\r\n      // be recursively nested within `\"change\"` events.\r\n      if (changing) return this;\r\n      if (!silent) {\r\n        while (this._pending) {\r\n          options = this._pending;\r\n          this._pending = false;\r\n          this.trigger('change', this, options);\r\n        }\r\n      }\r\n      this._pending = false;\r\n      this._changing = false;\r\n      return this;\r\n    },\r\n\r\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n    // if the attribute doesn't exist.\r\n    unset: function(attr, options) {\r\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Clear all attributes on the model, firing `\"change\"`.\r\n    clear: function(options) {\r\n      var attrs = {};\r\n      for (var key in this.attributes) attrs[key] = void 0;\r\n      return this.set(attrs, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Determine if the model has changed since the last `\"change\"` event.\r\n    // If you specify an attribute name, determine if that attribute has changed.\r\n    hasChanged: function(attr) {\r\n      if (attr == null) return !_.isEmpty(this.changed);\r\n      return _.has(this.changed, attr);\r\n    },\r\n\r\n    // Return an object containing all the attributes that have changed, or\r\n    // false if there are no changed attributes. Useful for determining what\r\n    // parts of a view need to be updated and/or what attributes need to be\r\n    // persisted to the server. Unset attributes will be set to undefined.\r\n    // You can also pass an attributes object to diff against the model,\r\n    // determining if there *would be* a change.\r\n    changedAttributes: function(diff) {\r\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\r\n      var old = this._changing ? this._previousAttributes : this.attributes;\r\n      var changed = {};\r\n      for (var attr in diff) {\r\n        var val = diff[attr];\r\n        if (_.isEqual(old[attr], val)) continue;\r\n        changed[attr] = val;\r\n      }\r\n      return _.size(changed) ? changed : false;\r\n    },\r\n\r\n    // Get the previous value of an attribute, recorded at the time the last\r\n    // `\"change\"` event was fired.\r\n    previous: function(attr) {\r\n      if (attr == null || !this._previousAttributes) return null;\r\n      return this._previousAttributes[attr];\r\n    },\r\n\r\n    // Get all of the attributes of the model at the time of the previous\r\n    // `\"change\"` event.\r\n    previousAttributes: function() {\r\n      return _.clone(this._previousAttributes);\r\n    },\r\n\r\n    // Fetch the model from the server, merging the response with the model's\r\n    // local attributes. Any changed attributes will trigger a \"change\" event.\r\n    fetch: function(options) {\r\n      options = _.extend({parse: true}, options);\r\n      var model = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\r\n        if (!model.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, model, resp, options);\r\n        model.trigger('sync', model, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of model attributes, and sync the model to the server.\r\n    // If the server returns an attributes hash that differs, the model's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      var attrs;\r\n      if (key == null || typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options = _.extend({validate: true, parse: true}, options);\r\n      var wait = options.wait;\r\n\r\n      // If we're not waiting and attributes exist, save acts as\r\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\r\n      // the model will be valid when the attributes, if any, are set.\r\n      if (attrs && !wait) {\r\n        if (!this.set(attrs, options)) return false;\r\n      } else if (!this._validate(attrs, options)) {\r\n        return false;\r\n      }\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      var model = this;\r\n      var success = options.success;\r\n      var attributes = this.attributes;\r\n      options.success = function(resp) {\r\n        // Ensure attributes are restored during synchronous saves.\r\n        model.attributes = attributes;\r\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\r\n        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\r\n        if (serverAttrs && !model.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, model, resp, options);\r\n        model.trigger('sync', model, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n\r\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\r\n      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\r\n\r\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\r\n      var xhr = this.sync(method, this, options);\r\n\r\n      // Restore attributes.\r\n      this.attributes = attributes;\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this model on the server if it was already persisted.\r\n    // Optimistically removes the model from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? _.clone(options) : {};\r\n      var model = this;\r\n      var success = options.success;\r\n      var wait = options.wait;\r\n\r\n      var destroy = function() {\r\n        model.stopListening();\r\n        model.trigger('destroy', model, model.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (wait) destroy();\r\n        if (success) success.call(options.context, model, resp, options);\r\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\r\n      };\r\n\r\n      var xhr = false;\r\n      if (this.isNew()) {\r\n        _.defer(options.success);\r\n      } else {\r\n        wrapError(this, options);\r\n        xhr = this.sync('delete', this, options);\r\n      }\r\n      if (!wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the model's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base =\r\n        _.result(this, 'urlRoot') ||\r\n        _.result(this.collection, 'url') ||\r\n        urlError();\r\n      if (this.isNew()) return base;\r\n      var id = this.get(this.idAttribute);\r\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the model. The default implementation is just to pass the response along.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new model with identical attributes to this one.\r\n    clone: function() {\r\n      return new this.constructor(this.attributes);\r\n    },\r\n\r\n    // A model is new if it has never been saved to the server, and lacks an id.\r\n    isNew: function() {\r\n      return !this.has(this.idAttribute);\r\n    },\r\n\r\n    // Check if the model is currently in a valid state.\r\n    isValid: function(options) {\r\n      return this._validate({}, _.extend({}, options, {validate: true}));\r\n    },\r\n\r\n    // Run validation against the next complete set of model attributes,\r\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n    _validate: function(attrs, options) {\r\n      if (!options.validate || !this.validate) return true;\r\n      attrs = _.extend({}, this.attributes, attrs);\r\n      var error = this.validationError = this.validate(attrs, options) || null;\r\n      if (!error) return true;\r\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\r\n      return false;\r\n    }\r\n\r\n  });\r\n\r\n  // Underscore methods that we want to implement on the Model, mapped to the\r\n  // number of arguments they take.\r\n  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,\r\n      omit: 0, chain: 1, isEmpty: 1};\r\n\r\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\r\n  addUnderscoreMethods(Model, modelMethods, 'attributes');\r\n\r\n  // Backbone.Collection\r\n  // -------------------\r\n\r\n  // If models tend to represent a single row of data, a Backbone Collection is\r\n  // more analogous to a table full of data ... or a small slice or page of that\r\n  // table, or a collection of rows that belong together for a particular reason\r\n  // -- all of the messages in this particular folder, all of the documents\r\n  // belonging to this particular author, and so on. Collections maintain\r\n  // indexes of their models, both in order, and for lookup by `id`.\r\n\r\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\r\n  // If a `comparator` is specified, the Collection will maintain\r\n  // its models in sort order, as they're added and removed.\r\n  var Collection = Backbone.Collection = function(models, options) {\r\n    options || (options = {});\r\n    if (options.model) this.model = options.model;\r\n    if (options.comparator !== void 0) this.comparator = options.comparator;\r\n    this._reset();\r\n    this.initialize.apply(this, arguments);\r\n    if (models) this.reset(models, _.extend({silent: true}, options));\r\n  };\r\n\r\n  // Default options for `Collection#set`.\r\n  var setOptions = {add: true, remove: true, merge: true};\r\n  var addOptions = {add: true, remove: false};\r\n\r\n  // Splices `insert` into `array` at index `at`.\r\n  var splice = function(array, insert, at) {\r\n    at = Math.min(Math.max(at, 0), array.length);\r\n    var tail = Array(array.length - at);\r\n    var length = insert.length;\r\n    var i;\r\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\r\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\r\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\r\n  };\r\n\r\n  // Define the Collection's inheritable methods.\r\n  _.extend(Collection.prototype, Events, {\r\n\r\n    // The default model for a collection is just a **Backbone.Model**.\r\n    // This should be overridden in most cases.\r\n    model: Model,\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // The JSON representation of a Collection is an array of the\r\n    // models' attributes.\r\n    toJSON: function(options) {\r\n      return this.map(function(model) { return model.toJSON(options); });\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default.\r\n    sync: function() {\r\n      return Backbone.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Add a model, or list of models to the set. `models` may be Backbone\r\n    // Models or raw JavaScript objects to be converted to Models, or any\r\n    // combination of the two.\r\n    add: function(models, options) {\r\n      return this.set(models, _.extend({merge: false}, options, addOptions));\r\n    },\r\n\r\n    // Remove a model, or a list of models from the set.\r\n    remove: function(models, options) {\r\n      options = _.extend({}, options);\r\n      var singular = !_.isArray(models);\r\n      models = singular ? [models] : models.slice();\r\n      var removed = this._removeModels(models, options);\r\n      if (!options.silent && removed.length) {\r\n        options.changes = {added: [], merged: [], removed: removed};\r\n        this.trigger('update', this, options);\r\n      }\r\n      return singular ? removed[0] : removed;\r\n    },\r\n\r\n    // Update a collection by `set`-ing a new list of models, adding new ones,\r\n    // removing models that are no longer present, and merging models that\r\n    // already exist in the collection, as necessary. Similar to **Model#set**,\r\n    // the core operation for updating the data contained by the collection.\r\n    set: function(models, options) {\r\n      if (models == null) return;\r\n\r\n      options = _.extend({}, setOptions, options);\r\n      if (options.parse && !this._isModel(models)) {\r\n        models = this.parse(models, options) || [];\r\n      }\r\n\r\n      var singular = !_.isArray(models);\r\n      models = singular ? [models] : models.slice();\r\n\r\n      var at = options.at;\r\n      if (at != null) at = +at;\r\n      if (at > this.length) at = this.length;\r\n      if (at < 0) at += this.length + 1;\r\n\r\n      var set = [];\r\n      var toAdd = [];\r\n      var toMerge = [];\r\n      var toRemove = [];\r\n      var modelMap = {};\r\n\r\n      var add = options.add;\r\n      var merge = options.merge;\r\n      var remove = options.remove;\r\n\r\n      var sort = false;\r\n      var sortable = this.comparator && at == null && options.sort !== false;\r\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\r\n\r\n      // Turn bare objects into model references, and prevent invalid models\r\n      // from being added.\r\n      var model, i;\r\n      for (i = 0; i < models.length; i++) {\r\n        model = models[i];\r\n\r\n        // If a duplicate is found, prevent it from being added and\r\n        // optionally merge it into the existing model.\r\n        var existing = this.get(model);\r\n        if (existing) {\r\n          if (merge && model !== existing) {\r\n            var attrs = this._isModel(model) ? model.attributes : model;\r\n            if (options.parse) attrs = existing.parse(attrs, options);\r\n            existing.set(attrs, options);\r\n            toMerge.push(existing);\r\n            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\r\n          }\r\n          if (!modelMap[existing.cid]) {\r\n            modelMap[existing.cid] = true;\r\n            set.push(existing);\r\n          }\r\n          models[i] = existing;\r\n\r\n        // If this is a new, valid model, push it to the `toAdd` list.\r\n        } else if (add) {\r\n          model = models[i] = this._prepareModel(model, options);\r\n          if (model) {\r\n            toAdd.push(model);\r\n            this._addReference(model, options);\r\n            modelMap[model.cid] = true;\r\n            set.push(model);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove stale models.\r\n      if (remove) {\r\n        for (i = 0; i < this.length; i++) {\r\n          model = this.models[i];\r\n          if (!modelMap[model.cid]) toRemove.push(model);\r\n        }\r\n        if (toRemove.length) this._removeModels(toRemove, options);\r\n      }\r\n\r\n      // See if sorting is needed, update `length` and splice in new models.\r\n      var orderChanged = false;\r\n      var replace = !sortable && add && remove;\r\n      if (set.length && replace) {\r\n        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\r\n          return m !== set[index];\r\n        });\r\n        this.models.length = 0;\r\n        splice(this.models, set, 0);\r\n        this.length = this.models.length;\r\n      } else if (toAdd.length) {\r\n        if (sortable) sort = true;\r\n        splice(this.models, toAdd, at == null ? this.length : at);\r\n        this.length = this.models.length;\r\n      }\r\n\r\n      // Silently sort the collection if appropriate.\r\n      if (sort) this.sort({silent: true});\r\n\r\n      // Unless silenced, it's time to fire all appropriate add/sort/update events.\r\n      if (!options.silent) {\r\n        for (i = 0; i < toAdd.length; i++) {\r\n          if (at != null) options.index = at + i;\r\n          model = toAdd[i];\r\n          model.trigger('add', model, this, options);\r\n        }\r\n        if (sort || orderChanged) this.trigger('sort', this, options);\r\n        if (toAdd.length || toRemove.length || toMerge.length) {\r\n          options.changes = {\r\n            added: toAdd,\r\n            removed: toRemove,\r\n            merged: toMerge\r\n          };\r\n          this.trigger('update', this, options);\r\n        }\r\n      }\r\n\r\n      // Return the added (or merged) model (or models).\r\n      return singular ? models[0] : models;\r\n    },\r\n\r\n    // When you have more items than you want to add or remove individually,\r\n    // you can reset the entire set with a new list of models, without firing\r\n    // any granular `add` or `remove` events. Fires `reset` when finished.\r\n    // Useful for bulk operations and optimizations.\r\n    reset: function(models, options) {\r\n      options = options ? _.clone(options) : {};\r\n      for (var i = 0; i < this.models.length; i++) {\r\n        this._removeReference(this.models[i], options);\r\n      }\r\n      options.previousModels = this.models;\r\n      this._reset();\r\n      models = this.add(models, _.extend({silent: true}, options));\r\n      if (!options.silent) this.trigger('reset', this, options);\r\n      return models;\r\n    },\r\n\r\n    // Add a model to the end of the collection.\r\n    push: function(model, options) {\r\n      return this.add(model, _.extend({at: this.length}, options));\r\n    },\r\n\r\n    // Remove a model from the end of the collection.\r\n    pop: function(options) {\r\n      var model = this.at(this.length - 1);\r\n      return this.remove(model, options);\r\n    },\r\n\r\n    // Add a model to the beginning of the collection.\r\n    unshift: function(model, options) {\r\n      return this.add(model, _.extend({at: 0}, options));\r\n    },\r\n\r\n    // Remove a model from the beginning of the collection.\r\n    shift: function(options) {\r\n      var model = this.at(0);\r\n      return this.remove(model, options);\r\n    },\r\n\r\n    // Slice out a sub-array of models from the collection.\r\n    slice: function() {\r\n      return slice.apply(this.models, arguments);\r\n    },\r\n\r\n    // Get a model from the set by id, cid, model object with id or cid\r\n    // properties, or an attributes object that is transformed through modelId.\r\n    get: function(obj) {\r\n      if (obj == null) return void 0;\r\n      return this._byId[obj] ||\r\n        this._byId[this.modelId(obj.attributes || obj)] ||\r\n        obj.cid && this._byId[obj.cid];\r\n    },\r\n\r\n    // Returns `true` if the model is in the collection.\r\n    has: function(obj) {\r\n      return this.get(obj) != null;\r\n    },\r\n\r\n    // Get the model at the given index.\r\n    at: function(index) {\r\n      if (index < 0) index += this.length;\r\n      return this.models[index];\r\n    },\r\n\r\n    // Return models with matching attributes. Useful for simple cases of\r\n    // `filter`.\r\n    where: function(attrs, first) {\r\n      return this[first ? 'find' : 'filter'](attrs);\r\n    },\r\n\r\n    // Return the first model with matching attributes. Useful for simple cases\r\n    // of `find`.\r\n    findWhere: function(attrs) {\r\n      return this.where(attrs, true);\r\n    },\r\n\r\n    // Force the collection to re-sort itself. You don't need to call this under\r\n    // normal circumstances, as the set will maintain sort order as each item\r\n    // is added.\r\n    sort: function(options) {\r\n      var comparator = this.comparator;\r\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\r\n      options || (options = {});\r\n\r\n      var length = comparator.length;\r\n      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);\r\n\r\n      // Run sort based on type of `comparator`.\r\n      if (length === 1 || _.isString(comparator)) {\r\n        this.models = this.sortBy(comparator);\r\n      } else {\r\n        this.models.sort(comparator);\r\n      }\r\n      if (!options.silent) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Pluck an attribute from each model in the collection.\r\n    pluck: function(attr) {\r\n      return this.map(attr + '');\r\n    },\r\n\r\n    // Fetch the default set of models for this collection, resetting the\r\n    // collection when they arrive. If `reset: true` is passed, the response\r\n    // data will be passed through the `reset` method instead of `set`.\r\n    fetch: function(options) {\r\n      options = _.extend({parse: true}, options);\r\n      var success = options.success;\r\n      var collection = this;\r\n      options.success = function(resp) {\r\n        var method = options.reset ? 'reset' : 'set';\r\n        collection[method](resp, options);\r\n        if (success) success.call(options.context, collection, resp, options);\r\n        collection.trigger('sync', collection, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Create a new instance of a model in this collection. Add the model to the\r\n    // collection immediately, unless `wait: true` is passed, in which case we\r\n    // wait for the server to agree.\r\n    create: function(model, options) {\r\n      options = options ? _.clone(options) : {};\r\n      var wait = options.wait;\r\n      model = this._prepareModel(model, options);\r\n      if (!model) return false;\r\n      if (!wait) this.add(model, options);\r\n      var collection = this;\r\n      var success = options.success;\r\n      options.success = function(m, resp, callbackOpts) {\r\n        if (wait) collection.add(m, callbackOpts);\r\n        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\r\n      };\r\n      model.save(null, options);\r\n      return model;\r\n    },\r\n\r\n    // **parse** converts a response into a list of models to be added to the\r\n    // collection. The default implementation is just to pass it through.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new collection with an identical list of models as this one.\r\n    clone: function() {\r\n      return new this.constructor(this.models, {\r\n        model: this.model,\r\n        comparator: this.comparator\r\n      });\r\n    },\r\n\r\n    // Define how to uniquely identify models in the collection.\r\n    modelId: function(attrs) {\r\n      return attrs[this.model.prototype.idAttribute || 'id'];\r\n    },\r\n\r\n    // Private method to reset all internal state. Called when the collection\r\n    // is first initialized or reset.\r\n    _reset: function() {\r\n      this.length = 0;\r\n      this.models = [];\r\n      this._byId  = {};\r\n    },\r\n\r\n    // Prepare a hash of attributes (or other model) to be added to this\r\n    // collection.\r\n    _prepareModel: function(attrs, options) {\r\n      if (this._isModel(attrs)) {\r\n        if (!attrs.collection) attrs.collection = this;\r\n        return attrs;\r\n      }\r\n      options = options ? _.clone(options) : {};\r\n      options.collection = this;\r\n      var model = new this.model(attrs, options);\r\n      if (!model.validationError) return model;\r\n      this.trigger('invalid', this, model.validationError, options);\r\n      return false;\r\n    },\r\n\r\n    // Internal method called by both remove and set.\r\n    _removeModels: function(models, options) {\r\n      var removed = [];\r\n      for (var i = 0; i < models.length; i++) {\r\n        var model = this.get(models[i]);\r\n        if (!model) continue;\r\n\r\n        var index = this.indexOf(model);\r\n        this.models.splice(index, 1);\r\n        this.length--;\r\n\r\n        // Remove references before triggering 'remove' event to prevent an\r\n        // infinite loop. #3693\r\n        delete this._byId[model.cid];\r\n        var id = this.modelId(model.attributes);\r\n        if (id != null) delete this._byId[id];\r\n\r\n        if (!options.silent) {\r\n          options.index = index;\r\n          model.trigger('remove', model, this, options);\r\n        }\r\n\r\n        removed.push(model);\r\n        this._removeReference(model, options);\r\n      }\r\n      return removed;\r\n    },\r\n\r\n    // Method for checking whether an object should be considered a model for\r\n    // the purposes of adding to the collection.\r\n    _isModel: function(model) {\r\n      return model instanceof Model;\r\n    },\r\n\r\n    // Internal method to create a model's ties to a collection.\r\n    _addReference: function(model, options) {\r\n      this._byId[model.cid] = model;\r\n      var id = this.modelId(model.attributes);\r\n      if (id != null) this._byId[id] = model;\r\n      model.on('all', this._onModelEvent, this);\r\n    },\r\n\r\n    // Internal method to sever a model's ties to a collection.\r\n    _removeReference: function(model, options) {\r\n      delete this._byId[model.cid];\r\n      var id = this.modelId(model.attributes);\r\n      if (id != null) delete this._byId[id];\r\n      if (this === model.collection) delete model.collection;\r\n      model.off('all', this._onModelEvent, this);\r\n    },\r\n\r\n    // Internal method called every time a model in the set fires an event.\r\n    // Sets need to update their indexes when models change ids. All other\r\n    // events simply proxy through. \"add\" and \"remove\" events that originate\r\n    // in other collections are ignored.\r\n    _onModelEvent: function(event, model, collection, options) {\r\n      if (model) {\r\n        if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n        if (event === 'destroy') this.remove(model, options);\r\n        if (event === 'change') {\r\n          var prevId = this.modelId(model.previousAttributes());\r\n          var id = this.modelId(model.attributes);\r\n          if (prevId !== id) {\r\n            if (prevId != null) delete this._byId[prevId];\r\n            if (id != null) this._byId[id] = model;\r\n          }\r\n        }\r\n      }\r\n      this.trigger.apply(this, arguments);\r\n    }\r\n\r\n  });\r\n\r\n  // Underscore methods that we want to implement on the Collection.\r\n  // 90% of the core usefulness of Backbone Collections is actually implemented\r\n  // right here:\r\n  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,\r\n      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,\r\n      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,\r\n      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,\r\n      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,\r\n      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,\r\n      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,\r\n      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};\r\n\r\n  // Mix in each Underscore method as a proxy to `Collection#models`.\r\n  addUnderscoreMethods(Collection, collectionMethods, 'models');\r\n\r\n  // Backbone.View\r\n  // -------------\r\n\r\n  // Backbone Views are almost more convention than they are actual code. A View\r\n  // is simply a JavaScript object that represents a logical chunk of UI in the\r\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\r\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\r\n  // UI as a **View** allows you to define your DOM events declaratively, without\r\n  // having to worry about render order ... and makes it easy for the view to\r\n  // react to specific changes in the state of your models.\r\n\r\n  // Creating a Backbone.View creates its initial element outside of the DOM,\r\n  // if an existing element is not provided...\r\n  var View = Backbone.View = function(options) {\r\n    this.cid = _.uniqueId('view');\r\n    _.extend(this, _.pick(options, viewOptions));\r\n    this._ensureElement();\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Cached regex to split keys for `delegate`.\r\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\r\n\r\n  // List of view options to be set as properties.\r\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\r\n\r\n  // Set up all inheritable **Backbone.View** properties and methods.\r\n  _.extend(View.prototype, Events, {\r\n\r\n    // The default `tagName` of a View's element is `\"div\"`.\r\n    tagName: 'div',\r\n\r\n    // jQuery delegate for element lookup, scoped to DOM elements within the\r\n    // current view. This should be preferred to global lookups where possible.\r\n    $: function(selector) {\r\n      return this.$el.find(selector);\r\n    },\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // **render** is the core function that your view should override, in order\r\n    // to populate its element (`this.el`), with the appropriate HTML. The\r\n    // convention is for **render** to always return `this`.\r\n    render: function() {\r\n      return this;\r\n    },\r\n\r\n    // Remove this view by taking the element out of the DOM, and removing any\r\n    // applicable Backbone.Events listeners.\r\n    remove: function() {\r\n      this._removeElement();\r\n      this.stopListening();\r\n      return this;\r\n    },\r\n\r\n    // Remove this view's element from the document and all event listeners\r\n    // attached to it. Exposed for subclasses using an alternative DOM\r\n    // manipulation API.\r\n    _removeElement: function() {\r\n      this.$el.remove();\r\n    },\r\n\r\n    // Change the view's element (`this.el` property) and re-delegate the\r\n    // view's events on the new element.\r\n    setElement: function(element) {\r\n      this.undelegateEvents();\r\n      this._setElement(element);\r\n      this.delegateEvents();\r\n      return this;\r\n    },\r\n\r\n    // Creates the `this.el` and `this.$el` references for this view using the\r\n    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\r\n    // context or an element. Subclasses can override this to utilize an\r\n    // alternative DOM manipulation API and are only required to set the\r\n    // `this.el` property.\r\n    _setElement: function(el) {\r\n      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\r\n      this.el = this.$el[0];\r\n    },\r\n\r\n    // Set callbacks, where `this.events` is a hash of\r\n    //\r\n    // *{\"event selector\": \"callback\"}*\r\n    //\r\n    //     {\r\n    //       'mousedown .title':  'edit',\r\n    //       'click .button':     'save',\r\n    //       'click .open':       function(e) { ... }\r\n    //     }\r\n    //\r\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\r\n    // Uses event delegation for efficiency.\r\n    // Omitting the selector binds the event to `this.el`.\r\n    delegateEvents: function(events) {\r\n      events || (events = _.result(this, 'events'));\r\n      if (!events) return this;\r\n      this.undelegateEvents();\r\n      for (var key in events) {\r\n        var method = events[key];\r\n        if (!_.isFunction(method)) method = this[method];\r\n        if (!method) continue;\r\n        var match = key.match(delegateEventSplitter);\r\n        this.delegate(match[1], match[2], _.bind(method, this));\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Add a single event listener to the view's element (or a child element\r\n    // using `selector`). This only works for delegate-able events: not `focus`,\r\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\r\n    delegate: function(eventName, selector, listener) {\r\n      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\r\n      return this;\r\n    },\r\n\r\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\r\n    // You usually don't need to use this, but may wish to if you have multiple\r\n    // Backbone views attached to the same DOM element.\r\n    undelegateEvents: function() {\r\n      if (this.$el) this.$el.off('.delegateEvents' + this.cid);\r\n      return this;\r\n    },\r\n\r\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\r\n    // `selector` and `listener` are both optional.\r\n    undelegate: function(eventName, selector, listener) {\r\n      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\r\n      return this;\r\n    },\r\n\r\n    // Produces a DOM element to be assigned to your view. Exposed for\r\n    // subclasses using an alternative DOM manipulation API.\r\n    _createElement: function(tagName) {\r\n      return document.createElement(tagName);\r\n    },\r\n\r\n    // Ensure that the View has a DOM element to render into.\r\n    // If `this.el` is a string, pass it through `$()`, take the first\r\n    // matching element, and re-assign it to `el`. Otherwise, create\r\n    // an element from the `id`, `className` and `tagName` properties.\r\n    _ensureElement: function() {\r\n      if (!this.el) {\r\n        var attrs = _.extend({}, _.result(this, 'attributes'));\r\n        if (this.id) attrs.id = _.result(this, 'id');\r\n        if (this.className) attrs['class'] = _.result(this, 'className');\r\n        this.setElement(this._createElement(_.result(this, 'tagName')));\r\n        this._setAttributes(attrs);\r\n      } else {\r\n        this.setElement(_.result(this, 'el'));\r\n      }\r\n    },\r\n\r\n    // Set attributes from a hash on this view's element.  Exposed for\r\n    // subclasses using an alternative DOM manipulation API.\r\n    _setAttributes: function(attributes) {\r\n      this.$el.attr(attributes);\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.sync\r\n  // -------------\r\n\r\n  // Override this function to change the manner in which Backbone persists\r\n  // models to the server. You will be passed the type of request, and the\r\n  // model in question. By default, makes a RESTful Ajax request\r\n  // to the model's `url()`. Some possible customizations could be:\r\n  //\r\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\r\n  // * Send up the models as XML instead of JSON.\r\n  // * Persist models via WebSockets instead of Ajax.\r\n  //\r\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\r\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\r\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\r\n  // instead of `application/json` with the model in a param named `model`.\r\n  // Useful when interfacing with server-side languages like **PHP** that make\r\n  // it difficult to read the body of `PUT` requests.\r\n  Backbone.sync = function(method, model, options) {\r\n    var type = methodMap[method];\r\n\r\n    // Default options, unless specified.\r\n    _.defaults(options || (options = {}), {\r\n      emulateHTTP: Backbone.emulateHTTP,\r\n      emulateJSON: Backbone.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = {type: type, dataType: 'json'};\r\n\r\n    // Ensure that we have a URL.\r\n    if (!options.url) {\r\n      params.url = _.result(model, 'url') || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\r\n      params.contentType = 'application/json';\r\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if (options.emulateJSON) {\r\n      params.contentType = 'application/x-www-form-urlencoded';\r\n      params.data = params.data ? {model: params.data} : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\r\n      params.type = 'POST';\r\n      if (options.emulateJSON) params.data._method = type;\r\n      var beforeSend = options.beforeSend;\r\n      options.beforeSend = function(xhr) {\r\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\r\n        if (beforeSend) return beforeSend.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if (params.type !== 'GET' && !options.emulateJSON) {\r\n      params.processData = false;\r\n    }\r\n\r\n    // Pass along `textStatus` and `errorThrown` from jQuery.\r\n    var error = options.error;\r\n    options.error = function(xhr, textStatus, errorThrown) {\r\n      options.textStatus = textStatus;\r\n      options.errorThrown = errorThrown;\r\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\r\n    };\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\r\n    model.trigger('request', model, xhr, options);\r\n    return xhr;\r\n  };\r\n\r\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\n  var methodMap = {\r\n    'create': 'POST',\r\n    'update': 'PUT',\r\n    'patch': 'PATCH',\r\n    'delete': 'DELETE',\r\n    'read': 'GET'\r\n  };\r\n\r\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\r\n  // Override this if you'd like to use a different library.\r\n  Backbone.ajax = function() {\r\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\r\n  };\r\n\r\n  // Backbone.Router\r\n  // ---------------\r\n\r\n  // Routers map faux-URLs to actions, and fire events when routes are\r\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\r\n  var Router = Backbone.Router = function(options) {\r\n    options || (options = {});\r\n    if (options.routes) this.routes = options.routes;\r\n    this._bindRoutes();\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Cached regular expressions for matching named param parts and splatted\r\n  // parts of route strings.\r\n  var optionalParam = /\\((.*?)\\)/g;\r\n  var namedParam    = /(\\(\\?)?:\\w+/g;\r\n  var splatParam    = /\\*\\w+/g;\r\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\n\r\n  // Set up all inheritable **Backbone.Router** properties and methods.\r\n  _.extend(Router.prototype, Events, {\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Manually bind a single named route to a callback. For example:\r\n    //\r\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\r\n    //       ...\r\n    //     });\r\n    //\r\n    route: function(route, name, callback) {\r\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\r\n      if (_.isFunction(name)) {\r\n        callback = name;\r\n        name = '';\r\n      }\r\n      if (!callback) callback = this[name];\r\n      var router = this;\r\n      Backbone.history.route(route, function(fragment) {\r\n        var args = router._extractParameters(route, fragment);\r\n        if (router.execute(callback, args, name) !== false) {\r\n          router.trigger.apply(router, ['route:' + name].concat(args));\r\n          router.trigger('route', name, args);\r\n          Backbone.history.trigger('route', router, name, args);\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // Execute a route handler with the provided parameters.  This is an\r\n    // excellent place to do pre-route setup or post-route cleanup.\r\n    execute: function(callback, args, name) {\r\n      if (callback) callback.apply(this, args);\r\n    },\r\n\r\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\r\n    navigate: function(fragment, options) {\r\n      Backbone.history.navigate(fragment, options);\r\n      return this;\r\n    },\r\n\r\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\r\n    // order of the routes here to support behavior where the most general\r\n    // routes can be defined at the bottom of the route map.\r\n    _bindRoutes: function() {\r\n      if (!this.routes) return;\r\n      this.routes = _.result(this, 'routes');\r\n      var route, routes = _.keys(this.routes);\r\n      while ((route = routes.pop()) != null) {\r\n        this.route(route, this.routes[route]);\r\n      }\r\n    },\r\n\r\n    // Convert a route string into a regular expression, suitable for matching\r\n    // against the current location hash.\r\n    _routeToRegExp: function(route) {\r\n      route = route.replace(escapeRegExp, '\\\\$&')\r\n                   .replace(optionalParam, '(?:$1)?')\r\n                   .replace(namedParam, function(match, optional) {\r\n                     return optional ? match : '([^/?]+)';\r\n                   })\r\n                   .replace(splatParam, '([^?]*?)');\r\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\r\n    },\r\n\r\n    // Given a route, and a URL fragment that it matches, return the array of\r\n    // extracted decoded parameters. Empty or unmatched parameters will be\r\n    // treated as `null` to normalize cross-browser behavior.\r\n    _extractParameters: function(route, fragment) {\r\n      var params = route.exec(fragment).slice(1);\r\n      return _.map(params, function(param, i) {\r\n        // Don't decode the search params.\r\n        if (i === params.length - 1) return param || null;\r\n        return param ? decodeURIComponent(param) : null;\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.History\r\n  // ----------------\r\n\r\n  // Handles cross-browser history management, based on either\r\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n  // and URL fragments. If the browser supports neither (old IE, natch),\r\n  // falls back to polling.\r\n  var History = Backbone.History = function() {\r\n    this.handlers = [];\r\n    this.checkUrl = _.bind(this.checkUrl, this);\r\n\r\n    // Ensure that `History` can be used outside of the browser.\r\n    if (typeof window !== 'undefined') {\r\n      this.location = window.location;\r\n      this.history = window.history;\r\n    }\r\n  };\r\n\r\n  // Cached regex for stripping a leading hash/slash and trailing space.\r\n  var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n  // Cached regex for stripping leading and trailing slashes.\r\n  var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n  // Cached regex for stripping urls of hash.\r\n  var pathStripper = /#.*$/;\r\n\r\n  // Has the history handling already been started?\r\n  History.started = false;\r\n\r\n  // Set up all inheritable **Backbone.History** properties and methods.\r\n  _.extend(History.prototype, Events, {\r\n\r\n    // The default interval to poll for hash changes, if necessary, is\r\n    // twenty times a second.\r\n    interval: 50,\r\n\r\n    // Are we at the app root?\r\n    atRoot: function() {\r\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\r\n      return path === this.root && !this.getSearch();\r\n    },\r\n\r\n    // Does the pathname match the root?\r\n    matchRoot: function() {\r\n      var path = this.decodeFragment(this.location.pathname);\r\n      var rootPath = path.slice(0, this.root.length - 1) + '/';\r\n      return rootPath === this.root;\r\n    },\r\n\r\n    // Unicode characters in `location.pathname` are percent encoded so they're\r\n    // decoded for comparison. `%25` should not be decoded since it may be part\r\n    // of an encoded parameter.\r\n    decodeFragment: function(fragment) {\r\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\r\n    },\r\n\r\n    // In IE6, the hash fragment and search params are incorrect if the\r\n    // fragment contains `?`.\r\n    getSearch: function() {\r\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\r\n      return match ? match[0] : '';\r\n    },\r\n\r\n    // Gets the true hash value. Cannot use location.hash directly due to bug\r\n    // in Firefox where location.hash will always be decoded.\r\n    getHash: function(window) {\r\n      var match = (window || this).location.href.match(/#(.*)$/);\r\n      return match ? match[1] : '';\r\n    },\r\n\r\n    // Get the pathname and search params, without the root.\r\n    getPath: function() {\r\n      var path = this.decodeFragment(\r\n        this.location.pathname + this.getSearch()\r\n      ).slice(this.root.length - 1);\r\n      return path.charAt(0) === '/' ? path.slice(1) : path;\r\n    },\r\n\r\n    // Get the cross-browser normalized URL fragment from the path or hash.\r\n    getFragment: function(fragment) {\r\n      if (fragment == null) {\r\n        if (this._usePushState || !this._wantsHashChange) {\r\n          fragment = this.getPath();\r\n        } else {\r\n          fragment = this.getHash();\r\n        }\r\n      }\r\n      return fragment.replace(routeStripper, '');\r\n    },\r\n\r\n    // Start the hash change handling, returning `true` if the current URL matches\r\n    // an existing route, and `false` otherwise.\r\n    start: function(options) {\r\n      if (History.started) throw new Error('Backbone.history has already been started');\r\n      History.started = true;\r\n\r\n      // Figure out the initial configuration. Do we need an iframe?\r\n      // Is pushState desired ... is it available?\r\n      this.options          = _.extend({root: '/'}, this.options, options);\r\n      this.root             = this.options.root;\r\n      this._wantsHashChange = this.options.hashChange !== false;\r\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\r\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\r\n      this._wantsPushState  = !!this.options.pushState;\r\n      this._hasPushState    = !!(this.history && this.history.pushState);\r\n      this._usePushState    = this._wantsPushState && this._hasPushState;\r\n      this.fragment         = this.getFragment();\r\n\r\n      // Normalize root to always include a leading and trailing slash.\r\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n      // Transition from hashChange to pushState or vice versa if both are\r\n      // requested.\r\n      if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n        // If we've started off with a route from a `pushState`-enabled\r\n        // browser, but we're currently in a browser that doesn't support it...\r\n        if (!this._hasPushState && !this.atRoot()) {\r\n          var rootPath = this.root.slice(0, -1) || '/';\r\n          this.location.replace(rootPath + '#' + this.getPath());\r\n          // Return immediately as browser will do redirect to new url\r\n          return true;\r\n\r\n        // Or if we've started out with a hash-based route, but we're currently\r\n        // in a browser where it could be `pushState`-based instead...\r\n        } else if (this._hasPushState && this.atRoot()) {\r\n          this.navigate(this.getHash(), {replace: true});\r\n        }\r\n\r\n      }\r\n\r\n      // Proxy an iframe to handle location events if the browser doesn't\r\n      // support the `hashchange` event, HTML5 history, or the user wants\r\n      // `hashChange` but not `pushState`.\r\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\r\n        this.iframe = document.createElement('iframe');\r\n        this.iframe.src = 'javascript:0';\r\n        this.iframe.style.display = 'none';\r\n        this.iframe.tabIndex = -1;\r\n        var body = document.body;\r\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\r\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\r\n        iWindow.document.open();\r\n        iWindow.document.close();\r\n        iWindow.location.hash = '#' + this.fragment;\r\n      }\r\n\r\n      // Add a cross-platform `addEventListener` shim for older browsers.\r\n      var addEventListener = window.addEventListener || function(eventName, listener) {\r\n        return attachEvent('on' + eventName, listener);\r\n      };\r\n\r\n      // Depending on whether we're using pushState or hashes, and whether\r\n      // 'onhashchange' is supported, determine how we check the URL state.\r\n      if (this._usePushState) {\r\n        addEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        addEventListener('hashchange', this.checkUrl, false);\r\n      } else if (this._wantsHashChange) {\r\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\r\n      }\r\n\r\n      if (!this.options.silent) return this.loadUrl();\r\n    },\r\n\r\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\r\n    // but possibly useful for unit testing Routers.\r\n    stop: function() {\r\n      // Add a cross-platform `removeEventListener` shim for older browsers.\r\n      var removeEventListener = window.removeEventListener || function(eventName, listener) {\r\n        return detachEvent('on' + eventName, listener);\r\n      };\r\n\r\n      // Remove window listeners.\r\n      if (this._usePushState) {\r\n        removeEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        removeEventListener('hashchange', this.checkUrl, false);\r\n      }\r\n\r\n      // Clean up the iframe if necessary.\r\n      if (this.iframe) {\r\n        document.body.removeChild(this.iframe);\r\n        this.iframe = null;\r\n      }\r\n\r\n      // Some environments will throw when clearing an undefined interval.\r\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\r\n      History.started = false;\r\n    },\r\n\r\n    // Add a route to be tested when the fragment changes. Routes added later\r\n    // may override previous routes.\r\n    route: function(route, callback) {\r\n      this.handlers.unshift({route: route, callback: callback});\r\n    },\r\n\r\n    // Checks the current URL to see if it has changed, and if it has,\r\n    // calls `loadUrl`, normalizing across the hidden iframe.\r\n    checkUrl: function(e) {\r\n      var current = this.getFragment();\r\n\r\n      // If the user pressed the back button, the iframe's hash will have\r\n      // changed and we should use that for comparison.\r\n      if (current === this.fragment && this.iframe) {\r\n        current = this.getHash(this.iframe.contentWindow);\r\n      }\r\n\r\n      if (current === this.fragment) return false;\r\n      if (this.iframe) this.navigate(current);\r\n      this.loadUrl();\r\n    },\r\n\r\n    // Attempt to load the current URL fragment. If a route succeeds with a\r\n    // match, returns `true`. If no defined routes matches the fragment,\r\n    // returns `false`.\r\n    loadUrl: function(fragment) {\r\n      // If the root doesn't match, no routes can match either.\r\n      if (!this.matchRoot()) return false;\r\n      fragment = this.fragment = this.getFragment(fragment);\r\n      return _.some(this.handlers, function(handler) {\r\n        if (handler.route.test(fragment)) {\r\n          handler.callback(fragment);\r\n          return true;\r\n        }\r\n      });\r\n    },\r\n\r\n    // Save a fragment into the hash history, or replace the URL state if the\r\n    // 'replace' option is passed. You are responsible for properly URL-encoding\r\n    // the fragment in advance.\r\n    //\r\n    // The options object can contain `trigger: true` if you wish to have the\r\n    // route callback be fired (not usually desirable), or `replace: true`, if\r\n    // you wish to modify the current URL without adding an entry to the history.\r\n    navigate: function(fragment, options) {\r\n      if (!History.started) return false;\r\n      if (!options || options === true) options = {trigger: !!options};\r\n\r\n      // Normalize the fragment.\r\n      fragment = this.getFragment(fragment || '');\r\n\r\n      // Don't include a trailing slash on the root.\r\n      var rootPath = this.root;\r\n      if (fragment === '' || fragment.charAt(0) === '?') {\r\n        rootPath = rootPath.slice(0, -1) || '/';\r\n      }\r\n      var url = rootPath + fragment;\r\n\r\n      // Strip the hash and decode for matching.\r\n      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));\r\n\r\n      if (this.fragment === fragment) return;\r\n      this.fragment = fragment;\r\n\r\n      // If pushState is available, we use it to set the fragment as a real URL.\r\n      if (this._usePushState) {\r\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n      // If hash changes haven't been explicitly disabled, update the hash\r\n      // fragment to store history.\r\n      } else if (this._wantsHashChange) {\r\n        this._updateHash(this.location, fragment, options.replace);\r\n        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\r\n          var iWindow = this.iframe.contentWindow;\r\n\r\n          // Opening and closing the iframe tricks IE7 and earlier to push a\r\n          // history entry on hash-tag change.  When replace is true, we don't\r\n          // want this.\r\n          if (!options.replace) {\r\n            iWindow.document.open();\r\n            iWindow.document.close();\r\n          }\r\n\r\n          this._updateHash(iWindow.location, fragment, options.replace);\r\n        }\r\n\r\n      // If you've told us that you explicitly don't want fallback hashchange-\r\n      // based history, then `navigate` becomes a page refresh.\r\n      } else {\r\n        return this.location.assign(url);\r\n      }\r\n      if (options.trigger) return this.loadUrl(fragment);\r\n    },\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    _updateHash: function(location, fragment, replace) {\r\n      if (replace) {\r\n        var href = location.href.replace(/(javascript:|#).*$/, '');\r\n        location.replace(href + '#' + fragment);\r\n      } else {\r\n        // Some browsers require that `hash` contains a leading #.\r\n        location.hash = '#' + fragment;\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Create the default Backbone.history.\r\n  Backbone.history = new History;\r\n\r\n  // Helpers\r\n  // -------\r\n\r\n  // Helper function to correctly set up the prototype chain for subclasses.\r\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\r\n  // class properties to be extended.\r\n  var extend = function(protoProps, staticProps) {\r\n    var parent = this;\r\n    var child;\r\n\r\n    // The constructor function for the new subclass is either defined by you\r\n    // (the \"constructor\" property in your `extend` definition), or defaulted\r\n    // by us to simply call the parent constructor.\r\n    if (protoProps && _.has(protoProps, 'constructor')) {\r\n      child = protoProps.constructor;\r\n    } else {\r\n      child = function(){ return parent.apply(this, arguments); };\r\n    }\r\n\r\n    // Add static properties to the constructor function, if supplied.\r\n    _.extend(child, parent, staticProps);\r\n\r\n    // Set the prototype chain to inherit from `parent`, without calling\r\n    // `parent`'s constructor function and add the prototype properties.\r\n    child.prototype = _.create(parent.prototype, protoProps);\r\n    child.prototype.constructor = child;\r\n\r\n    // Set a convenience property in case the parent's prototype is needed\r\n    // later.\r\n    child.__super__ = parent.prototype;\r\n\r\n    return child;\r\n  };\r\n\r\n  // Set up inheritance for the model, collection, router, view and history.\r\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\r\n\r\n  // Throw an error when a URL is needed, and none is supplied.\r\n  var urlError = function() {\r\n    throw new Error('A \"url\" property or function must be specified');\r\n  };\r\n\r\n  // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n  return Backbone;\r\n});\r\n"

/***/ }),

/***/ 253:
/***/ (function(module, exports) {

module.exports = "/*!\r\n * Bootstrap v3.3.7 (http://getbootstrap.com)\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under the MIT license\r\n */\r\n\r\nif (typeof jQuery === 'undefined') {\r\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\r\n}\r\n\r\n+function ($) {\r\n  'use strict';\r\n  var version = $.fn.jquery.split(' ')[0].split('.')\r\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {\r\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')\r\n  }\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: transition.js v3.3.7\r\n * http://getbootstrap.com/javascript/#transitions\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\r\n  // ============================================================\r\n\r\n  function transitionEnd() {\r\n    var el = document.createElement('bootstrap')\r\n\r\n    var transEndEventNames = {\r\n      WebkitTransition : 'webkitTransitionEnd',\r\n      MozTransition    : 'transitionend',\r\n      OTransition      : 'oTransitionEnd otransitionend',\r\n      transition       : 'transitionend'\r\n    }\r\n\r\n    for (var name in transEndEventNames) {\r\n      if (el.style[name] !== undefined) {\r\n        return { end: transEndEventNames[name] }\r\n      }\r\n    }\r\n\r\n    return false // explicit for ie8 (  ._.)\r\n  }\r\n\r\n  // http://blog.alexmaccaw.com/css-transitions\r\n  $.fn.emulateTransitionEnd = function (duration) {\r\n    var called = false\r\n    var $el = this\r\n    $(this).one('bsTransitionEnd', function () { called = true })\r\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\r\n    setTimeout(callback, duration)\r\n    return this\r\n  }\r\n\r\n  $(function () {\r\n    $.support.transition = transitionEnd()\r\n\r\n    if (!$.support.transition) return\r\n\r\n    $.event.special.bsTransitionEnd = {\r\n      bindType: $.support.transition.end,\r\n      delegateType: $.support.transition.end,\r\n      handle: function (e) {\r\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\r\n      }\r\n    }\r\n  })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: alert.js v3.3.7\r\n * http://getbootstrap.com/javascript/#alerts\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // ALERT CLASS DEFINITION\r\n  // ======================\r\n\r\n  var dismiss = '[data-dismiss=\"alert\"]'\r\n  var Alert   = function (el) {\r\n    $(el).on('click', dismiss, this.close)\r\n  }\r\n\r\n  Alert.VERSION = '3.3.7'\r\n\r\n  Alert.TRANSITION_DURATION = 150\r\n\r\n  Alert.prototype.close = function (e) {\r\n    var $this    = $(this)\r\n    var selector = $this.attr('data-target')\r\n\r\n    if (!selector) {\r\n      selector = $this.attr('href')\r\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\r\n    }\r\n\r\n    var $parent = $(selector === '#' ? [] : selector)\r\n\r\n    if (e) e.preventDefault()\r\n\r\n    if (!$parent.length) {\r\n      $parent = $this.closest('.alert')\r\n    }\r\n\r\n    $parent.trigger(e = $.Event('close.bs.alert'))\r\n\r\n    if (e.isDefaultPrevented()) return\r\n\r\n    $parent.removeClass('in')\r\n\r\n    function removeElement() {\r\n      // detach from parent, fire event then clean up data\r\n      $parent.detach().trigger('closed.bs.alert').remove()\r\n    }\r\n\r\n    $.support.transition && $parent.hasClass('fade') ?\r\n      $parent\r\n        .one('bsTransitionEnd', removeElement)\r\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\r\n      removeElement()\r\n  }\r\n\r\n\r\n  // ALERT PLUGIN DEFINITION\r\n  // =======================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n      var data  = $this.data('bs.alert')\r\n\r\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\r\n      if (typeof option == 'string') data[option].call($this)\r\n    })\r\n  }\r\n\r\n  var old = $.fn.alert\r\n\r\n  $.fn.alert             = Plugin\r\n  $.fn.alert.Constructor = Alert\r\n\r\n\r\n  // ALERT NO CONFLICT\r\n  // =================\r\n\r\n  $.fn.alert.noConflict = function () {\r\n    $.fn.alert = old\r\n    return this\r\n  }\r\n\r\n\r\n  // ALERT DATA-API\r\n  // ==============\r\n\r\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: button.js v3.3.7\r\n * http://getbootstrap.com/javascript/#buttons\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // BUTTON PUBLIC CLASS DEFINITION\r\n  // ==============================\r\n\r\n  var Button = function (element, options) {\r\n    this.$element  = $(element)\r\n    this.options   = $.extend({}, Button.DEFAULTS, options)\r\n    this.isLoading = false\r\n  }\r\n\r\n  Button.VERSION  = '3.3.7'\r\n\r\n  Button.DEFAULTS = {\r\n    loadingText: 'loading...'\r\n  }\r\n\r\n  Button.prototype.setState = function (state) {\r\n    var d    = 'disabled'\r\n    var $el  = this.$element\r\n    var val  = $el.is('input') ? 'val' : 'html'\r\n    var data = $el.data()\r\n\r\n    state += 'Text'\r\n\r\n    if (data.resetText == null) $el.data('resetText', $el[val]())\r\n\r\n    // push to event loop to allow forms to submit\r\n    setTimeout($.proxy(function () {\r\n      $el[val](data[state] == null ? this.options[state] : data[state])\r\n\r\n      if (state == 'loadingText') {\r\n        this.isLoading = true\r\n        $el.addClass(d).attr(d, d).prop(d, true)\r\n      } else if (this.isLoading) {\r\n        this.isLoading = false\r\n        $el.removeClass(d).removeAttr(d).prop(d, false)\r\n      }\r\n    }, this), 0)\r\n  }\r\n\r\n  Button.prototype.toggle = function () {\r\n    var changed = true\r\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\r\n\r\n    if ($parent.length) {\r\n      var $input = this.$element.find('input')\r\n      if ($input.prop('type') == 'radio') {\r\n        if ($input.prop('checked')) changed = false\r\n        $parent.find('.active').removeClass('active')\r\n        this.$element.addClass('active')\r\n      } else if ($input.prop('type') == 'checkbox') {\r\n        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false\r\n        this.$element.toggleClass('active')\r\n      }\r\n      $input.prop('checked', this.$element.hasClass('active'))\r\n      if (changed) $input.trigger('change')\r\n    } else {\r\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\r\n      this.$element.toggleClass('active')\r\n    }\r\n  }\r\n\r\n\r\n  // BUTTON PLUGIN DEFINITION\r\n  // ========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.button')\r\n      var options = typeof option == 'object' && option\r\n\r\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\r\n\r\n      if (option == 'toggle') data.toggle()\r\n      else if (option) data.setState(option)\r\n    })\r\n  }\r\n\r\n  var old = $.fn.button\r\n\r\n  $.fn.button             = Plugin\r\n  $.fn.button.Constructor = Button\r\n\r\n\r\n  // BUTTON NO CONFLICT\r\n  // ==================\r\n\r\n  $.fn.button.noConflict = function () {\r\n    $.fn.button = old\r\n    return this\r\n  }\r\n\r\n\r\n  // BUTTON DATA-API\r\n  // ===============\r\n\r\n  $(document)\r\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\r\n      var $btn = $(e.target).closest('.btn')\r\n      Plugin.call($btn, 'toggle')\r\n      if (!($(e.target).is('input[type=\"radio\"], input[type=\"checkbox\"]'))) {\r\n        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes\r\n        e.preventDefault()\r\n        // The target component still receive the focus\r\n        if ($btn.is('input,button')) $btn.trigger('focus')\r\n        else $btn.find('input:visible,button:visible').first().trigger('focus')\r\n      }\r\n    })\r\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\r\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\r\n    })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: carousel.js v3.3.7\r\n * http://getbootstrap.com/javascript/#carousel\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // CAROUSEL CLASS DEFINITION\r\n  // =========================\r\n\r\n  var Carousel = function (element, options) {\r\n    this.$element    = $(element)\r\n    this.$indicators = this.$element.find('.carousel-indicators')\r\n    this.options     = options\r\n    this.paused      = null\r\n    this.sliding     = null\r\n    this.interval    = null\r\n    this.$active     = null\r\n    this.$items      = null\r\n\r\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\r\n\r\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\r\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\r\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\r\n  }\r\n\r\n  Carousel.VERSION  = '3.3.7'\r\n\r\n  Carousel.TRANSITION_DURATION = 600\r\n\r\n  Carousel.DEFAULTS = {\r\n    interval: 5000,\r\n    pause: 'hover',\r\n    wrap: true,\r\n    keyboard: true\r\n  }\r\n\r\n  Carousel.prototype.keydown = function (e) {\r\n    if (/input|textarea/i.test(e.target.tagName)) return\r\n    switch (e.which) {\r\n      case 37: this.prev(); break\r\n      case 39: this.next(); break\r\n      default: return\r\n    }\r\n\r\n    e.preventDefault()\r\n  }\r\n\r\n  Carousel.prototype.cycle = function (e) {\r\n    e || (this.paused = false)\r\n\r\n    this.interval && clearInterval(this.interval)\r\n\r\n    this.options.interval\r\n      && !this.paused\r\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\r\n\r\n    return this\r\n  }\r\n\r\n  Carousel.prototype.getItemIndex = function (item) {\r\n    this.$items = item.parent().children('.item')\r\n    return this.$items.index(item || this.$active)\r\n  }\r\n\r\n  Carousel.prototype.getItemForDirection = function (direction, active) {\r\n    var activeIndex = this.getItemIndex(active)\r\n    var willWrap = (direction == 'prev' && activeIndex === 0)\r\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\r\n    if (willWrap && !this.options.wrap) return active\r\n    var delta = direction == 'prev' ? -1 : 1\r\n    var itemIndex = (activeIndex + delta) % this.$items.length\r\n    return this.$items.eq(itemIndex)\r\n  }\r\n\r\n  Carousel.prototype.to = function (pos) {\r\n    var that        = this\r\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\r\n\r\n    if (pos > (this.$items.length - 1) || pos < 0) return\r\n\r\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\r\n    if (activeIndex == pos) return this.pause().cycle()\r\n\r\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\r\n  }\r\n\r\n  Carousel.prototype.pause = function (e) {\r\n    e || (this.paused = true)\r\n\r\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\r\n      this.$element.trigger($.support.transition.end)\r\n      this.cycle(true)\r\n    }\r\n\r\n    this.interval = clearInterval(this.interval)\r\n\r\n    return this\r\n  }\r\n\r\n  Carousel.prototype.next = function () {\r\n    if (this.sliding) return\r\n    return this.slide('next')\r\n  }\r\n\r\n  Carousel.prototype.prev = function () {\r\n    if (this.sliding) return\r\n    return this.slide('prev')\r\n  }\r\n\r\n  Carousel.prototype.slide = function (type, next) {\r\n    var $active   = this.$element.find('.item.active')\r\n    var $next     = next || this.getItemForDirection(type, $active)\r\n    var isCycling = this.interval\r\n    var direction = type == 'next' ? 'left' : 'right'\r\n    var that      = this\r\n\r\n    if ($next.hasClass('active')) return (this.sliding = false)\r\n\r\n    var relatedTarget = $next[0]\r\n    var slideEvent = $.Event('slide.bs.carousel', {\r\n      relatedTarget: relatedTarget,\r\n      direction: direction\r\n    })\r\n    this.$element.trigger(slideEvent)\r\n    if (slideEvent.isDefaultPrevented()) return\r\n\r\n    this.sliding = true\r\n\r\n    isCycling && this.pause()\r\n\r\n    if (this.$indicators.length) {\r\n      this.$indicators.find('.active').removeClass('active')\r\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\r\n      $nextIndicator && $nextIndicator.addClass('active')\r\n    }\r\n\r\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\r\n    if ($.support.transition && this.$element.hasClass('slide')) {\r\n      $next.addClass(type)\r\n      $next[0].offsetWidth // force reflow\r\n      $active.addClass(direction)\r\n      $next.addClass(direction)\r\n      $active\r\n        .one('bsTransitionEnd', function () {\r\n          $next.removeClass([type, direction].join(' ')).addClass('active')\r\n          $active.removeClass(['active', direction].join(' '))\r\n          that.sliding = false\r\n          setTimeout(function () {\r\n            that.$element.trigger(slidEvent)\r\n          }, 0)\r\n        })\r\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\r\n    } else {\r\n      $active.removeClass('active')\r\n      $next.addClass('active')\r\n      this.sliding = false\r\n      this.$element.trigger(slidEvent)\r\n    }\r\n\r\n    isCycling && this.cycle()\r\n\r\n    return this\r\n  }\r\n\r\n\r\n  // CAROUSEL PLUGIN DEFINITION\r\n  // ==========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.carousel')\r\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\r\n      var action  = typeof option == 'string' ? option : options.slide\r\n\r\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\r\n      if (typeof option == 'number') data.to(option)\r\n      else if (action) data[action]()\r\n      else if (options.interval) data.pause().cycle()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.carousel\r\n\r\n  $.fn.carousel             = Plugin\r\n  $.fn.carousel.Constructor = Carousel\r\n\r\n\r\n  // CAROUSEL NO CONFLICT\r\n  // ====================\r\n\r\n  $.fn.carousel.noConflict = function () {\r\n    $.fn.carousel = old\r\n    return this\r\n  }\r\n\r\n\r\n  // CAROUSEL DATA-API\r\n  // =================\r\n\r\n  var clickHandler = function (e) {\r\n    var href\r\n    var $this   = $(this)\r\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\r\n    if (!$target.hasClass('carousel')) return\r\n    var options = $.extend({}, $target.data(), $this.data())\r\n    var slideIndex = $this.attr('data-slide-to')\r\n    if (slideIndex) options.interval = false\r\n\r\n    Plugin.call($target, options)\r\n\r\n    if (slideIndex) {\r\n      $target.data('bs.carousel').to(slideIndex)\r\n    }\r\n\r\n    e.preventDefault()\r\n  }\r\n\r\n  $(document)\r\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\r\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\r\n\r\n  $(window).on('load', function () {\r\n    $('[data-ride=\"carousel\"]').each(function () {\r\n      var $carousel = $(this)\r\n      Plugin.call($carousel, $carousel.data())\r\n    })\r\n  })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: collapse.js v3.3.7\r\n * http://getbootstrap.com/javascript/#collapse\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n/* jshint latedef: false */\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // COLLAPSE PUBLIC CLASS DEFINITION\r\n  // ================================\r\n\r\n  var Collapse = function (element, options) {\r\n    this.$element      = $(element)\r\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\r\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\r\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\r\n    this.transitioning = null\r\n\r\n    if (this.options.parent) {\r\n      this.$parent = this.getParent()\r\n    } else {\r\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\r\n    }\r\n\r\n    if (this.options.toggle) this.toggle()\r\n  }\r\n\r\n  Collapse.VERSION  = '3.3.7'\r\n\r\n  Collapse.TRANSITION_DURATION = 350\r\n\r\n  Collapse.DEFAULTS = {\r\n    toggle: true\r\n  }\r\n\r\n  Collapse.prototype.dimension = function () {\r\n    var hasWidth = this.$element.hasClass('width')\r\n    return hasWidth ? 'width' : 'height'\r\n  }\r\n\r\n  Collapse.prototype.show = function () {\r\n    if (this.transitioning || this.$element.hasClass('in')) return\r\n\r\n    var activesData\r\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\r\n\r\n    if (actives && actives.length) {\r\n      activesData = actives.data('bs.collapse')\r\n      if (activesData && activesData.transitioning) return\r\n    }\r\n\r\n    var startEvent = $.Event('show.bs.collapse')\r\n    this.$element.trigger(startEvent)\r\n    if (startEvent.isDefaultPrevented()) return\r\n\r\n    if (actives && actives.length) {\r\n      Plugin.call(actives, 'hide')\r\n      activesData || actives.data('bs.collapse', null)\r\n    }\r\n\r\n    var dimension = this.dimension()\r\n\r\n    this.$element\r\n      .removeClass('collapse')\r\n      .addClass('collapsing')[dimension](0)\r\n      .attr('aria-expanded', true)\r\n\r\n    this.$trigger\r\n      .removeClass('collapsed')\r\n      .attr('aria-expanded', true)\r\n\r\n    this.transitioning = 1\r\n\r\n    var complete = function () {\r\n      this.$element\r\n        .removeClass('collapsing')\r\n        .addClass('collapse in')[dimension]('')\r\n      this.transitioning = 0\r\n      this.$element\r\n        .trigger('shown.bs.collapse')\r\n    }\r\n\r\n    if (!$.support.transition) return complete.call(this)\r\n\r\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\r\n\r\n    this.$element\r\n      .one('bsTransitionEnd', $.proxy(complete, this))\r\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\r\n  }\r\n\r\n  Collapse.prototype.hide = function () {\r\n    if (this.transitioning || !this.$element.hasClass('in')) return\r\n\r\n    var startEvent = $.Event('hide.bs.collapse')\r\n    this.$element.trigger(startEvent)\r\n    if (startEvent.isDefaultPrevented()) return\r\n\r\n    var dimension = this.dimension()\r\n\r\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\r\n\r\n    this.$element\r\n      .addClass('collapsing')\r\n      .removeClass('collapse in')\r\n      .attr('aria-expanded', false)\r\n\r\n    this.$trigger\r\n      .addClass('collapsed')\r\n      .attr('aria-expanded', false)\r\n\r\n    this.transitioning = 1\r\n\r\n    var complete = function () {\r\n      this.transitioning = 0\r\n      this.$element\r\n        .removeClass('collapsing')\r\n        .addClass('collapse')\r\n        .trigger('hidden.bs.collapse')\r\n    }\r\n\r\n    if (!$.support.transition) return complete.call(this)\r\n\r\n    this.$element\r\n      [dimension](0)\r\n      .one('bsTransitionEnd', $.proxy(complete, this))\r\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\r\n  }\r\n\r\n  Collapse.prototype.toggle = function () {\r\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\r\n  }\r\n\r\n  Collapse.prototype.getParent = function () {\r\n    return $(this.options.parent)\r\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\r\n      .each($.proxy(function (i, element) {\r\n        var $element = $(element)\r\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\r\n      }, this))\r\n      .end()\r\n  }\r\n\r\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\r\n    var isOpen = $element.hasClass('in')\r\n\r\n    $element.attr('aria-expanded', isOpen)\r\n    $trigger\r\n      .toggleClass('collapsed', !isOpen)\r\n      .attr('aria-expanded', isOpen)\r\n  }\r\n\r\n  function getTargetFromTrigger($trigger) {\r\n    var href\r\n    var target = $trigger.attr('data-target')\r\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\r\n\r\n    return $(target)\r\n  }\r\n\r\n\r\n  // COLLAPSE PLUGIN DEFINITION\r\n  // ==========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.collapse')\r\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\r\n\r\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\r\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.collapse\r\n\r\n  $.fn.collapse             = Plugin\r\n  $.fn.collapse.Constructor = Collapse\r\n\r\n\r\n  // COLLAPSE NO CONFLICT\r\n  // ====================\r\n\r\n  $.fn.collapse.noConflict = function () {\r\n    $.fn.collapse = old\r\n    return this\r\n  }\r\n\r\n\r\n  // COLLAPSE DATA-API\r\n  // =================\r\n\r\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\r\n    var $this   = $(this)\r\n\r\n    if (!$this.attr('data-target')) e.preventDefault()\r\n\r\n    var $target = getTargetFromTrigger($this)\r\n    var data    = $target.data('bs.collapse')\r\n    var option  = data ? 'toggle' : $this.data()\r\n\r\n    Plugin.call($target, option)\r\n  })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: dropdown.js v3.3.7\r\n * http://getbootstrap.com/javascript/#dropdowns\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // DROPDOWN CLASS DEFINITION\r\n  // =========================\r\n\r\n  var backdrop = '.dropdown-backdrop'\r\n  var toggle   = '[data-toggle=\"dropdown\"]'\r\n  var Dropdown = function (element) {\r\n    $(element).on('click.bs.dropdown', this.toggle)\r\n  }\r\n\r\n  Dropdown.VERSION = '3.3.7'\r\n\r\n  function getParent($this) {\r\n    var selector = $this.attr('data-target')\r\n\r\n    if (!selector) {\r\n      selector = $this.attr('href')\r\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\r\n    }\r\n\r\n    var $parent = selector && $(selector)\r\n\r\n    return $parent && $parent.length ? $parent : $this.parent()\r\n  }\r\n\r\n  function clearMenus(e) {\r\n    if (e && e.which === 3) return\r\n    $(backdrop).remove()\r\n    $(toggle).each(function () {\r\n      var $this         = $(this)\r\n      var $parent       = getParent($this)\r\n      var relatedTarget = { relatedTarget: this }\r\n\r\n      if (!$parent.hasClass('open')) return\r\n\r\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\r\n\r\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\r\n\r\n      if (e.isDefaultPrevented()) return\r\n\r\n      $this.attr('aria-expanded', 'false')\r\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\r\n    })\r\n  }\r\n\r\n  Dropdown.prototype.toggle = function (e) {\r\n    var $this = $(this)\r\n\r\n    if ($this.is('.disabled, :disabled')) return\r\n\r\n    var $parent  = getParent($this)\r\n    var isActive = $parent.hasClass('open')\r\n\r\n    clearMenus()\r\n\r\n    if (!isActive) {\r\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\r\n        // if mobile we use a backdrop because click events don't delegate\r\n        $(document.createElement('div'))\r\n          .addClass('dropdown-backdrop')\r\n          .insertAfter($(this))\r\n          .on('click', clearMenus)\r\n      }\r\n\r\n      var relatedTarget = { relatedTarget: this }\r\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\r\n\r\n      if (e.isDefaultPrevented()) return\r\n\r\n      $this\r\n        .trigger('focus')\r\n        .attr('aria-expanded', 'true')\r\n\r\n      $parent\r\n        .toggleClass('open')\r\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  Dropdown.prototype.keydown = function (e) {\r\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\r\n\r\n    var $this = $(this)\r\n\r\n    e.preventDefault()\r\n    e.stopPropagation()\r\n\r\n    if ($this.is('.disabled, :disabled')) return\r\n\r\n    var $parent  = getParent($this)\r\n    var isActive = $parent.hasClass('open')\r\n\r\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\r\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\r\n      return $this.trigger('click')\r\n    }\r\n\r\n    var desc = ' li:not(.disabled):visible a'\r\n    var $items = $parent.find('.dropdown-menu' + desc)\r\n\r\n    if (!$items.length) return\r\n\r\n    var index = $items.index(e.target)\r\n\r\n    if (e.which == 38 && index > 0)                 index--         // up\r\n    if (e.which == 40 && index < $items.length - 1) index++         // down\r\n    if (!~index)                                    index = 0\r\n\r\n    $items.eq(index).trigger('focus')\r\n  }\r\n\r\n\r\n  // DROPDOWN PLUGIN DEFINITION\r\n  // ==========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n      var data  = $this.data('bs.dropdown')\r\n\r\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\r\n      if (typeof option == 'string') data[option].call($this)\r\n    })\r\n  }\r\n\r\n  var old = $.fn.dropdown\r\n\r\n  $.fn.dropdown             = Plugin\r\n  $.fn.dropdown.Constructor = Dropdown\r\n\r\n\r\n  // DROPDOWN NO CONFLICT\r\n  // ====================\r\n\r\n  $.fn.dropdown.noConflict = function () {\r\n    $.fn.dropdown = old\r\n    return this\r\n  }\r\n\r\n\r\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\r\n  // ===================================\r\n\r\n  $(document)\r\n    .on('click.bs.dropdown.data-api', clearMenus)\r\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\r\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\r\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\r\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: modal.js v3.3.7\r\n * http://getbootstrap.com/javascript/#modals\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // MODAL CLASS DEFINITION\r\n  // ======================\r\n\r\n  var Modal = function (element, options) {\r\n    this.options             = options\r\n    this.$body               = $(document.body)\r\n    this.$element            = $(element)\r\n    this.$dialog             = this.$element.find('.modal-dialog')\r\n    this.$backdrop           = null\r\n    this.isShown             = null\r\n    this.originalBodyPad     = null\r\n    this.scrollbarWidth      = 0\r\n    this.ignoreBackdropClick = false\r\n\r\n    if (this.options.remote) {\r\n      this.$element\r\n        .find('.modal-content')\r\n        .load(this.options.remote, $.proxy(function () {\r\n          this.$element.trigger('loaded.bs.modal')\r\n        }, this))\r\n    }\r\n  }\r\n\r\n  Modal.VERSION  = '3.3.7'\r\n\r\n  Modal.TRANSITION_DURATION = 300\r\n  Modal.BACKDROP_TRANSITION_DURATION = 150\r\n\r\n  Modal.DEFAULTS = {\r\n    backdrop: true,\r\n    keyboard: true,\r\n    show: true\r\n  }\r\n\r\n  Modal.prototype.toggle = function (_relatedTarget) {\r\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\r\n  }\r\n\r\n  Modal.prototype.show = function (_relatedTarget) {\r\n    var that = this\r\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\r\n\r\n    this.$element.trigger(e)\r\n\r\n    if (this.isShown || e.isDefaultPrevented()) return\r\n\r\n    this.isShown = true\r\n\r\n    this.checkScrollbar()\r\n    this.setScrollbar()\r\n    this.$body.addClass('modal-open')\r\n\r\n    this.escape()\r\n    this.resize()\r\n\r\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\r\n\r\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\r\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\r\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\r\n      })\r\n    })\r\n\r\n    this.backdrop(function () {\r\n      var transition = $.support.transition && that.$element.hasClass('fade')\r\n\r\n      if (!that.$element.parent().length) {\r\n        that.$element.appendTo(that.$body) // don't move modals dom position\r\n      }\r\n\r\n      that.$element\r\n        .show()\r\n        .scrollTop(0)\r\n\r\n      that.adjustDialog()\r\n\r\n      if (transition) {\r\n        that.$element[0].offsetWidth // force reflow\r\n      }\r\n\r\n      that.$element.addClass('in')\r\n\r\n      that.enforceFocus()\r\n\r\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\r\n\r\n      transition ?\r\n        that.$dialog // wait for modal to slide in\r\n          .one('bsTransitionEnd', function () {\r\n            that.$element.trigger('focus').trigger(e)\r\n          })\r\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\r\n        that.$element.trigger('focus').trigger(e)\r\n    })\r\n  }\r\n\r\n  Modal.prototype.hide = function (e) {\r\n    if (e) e.preventDefault()\r\n\r\n    e = $.Event('hide.bs.modal')\r\n\r\n    this.$element.trigger(e)\r\n\r\n    if (!this.isShown || e.isDefaultPrevented()) return\r\n\r\n    this.isShown = false\r\n\r\n    this.escape()\r\n    this.resize()\r\n\r\n    $(document).off('focusin.bs.modal')\r\n\r\n    this.$element\r\n      .removeClass('in')\r\n      .off('click.dismiss.bs.modal')\r\n      .off('mouseup.dismiss.bs.modal')\r\n\r\n    this.$dialog.off('mousedown.dismiss.bs.modal')\r\n\r\n    $.support.transition && this.$element.hasClass('fade') ?\r\n      this.$element\r\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\r\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\r\n      this.hideModal()\r\n  }\r\n\r\n  Modal.prototype.enforceFocus = function () {\r\n    $(document)\r\n      .off('focusin.bs.modal') // guard against infinite focus loop\r\n      .on('focusin.bs.modal', $.proxy(function (e) {\r\n        if (document !== e.target &&\r\n            this.$element[0] !== e.target &&\r\n            !this.$element.has(e.target).length) {\r\n          this.$element.trigger('focus')\r\n        }\r\n      }, this))\r\n  }\r\n\r\n  Modal.prototype.escape = function () {\r\n    if (this.isShown && this.options.keyboard) {\r\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\r\n        e.which == 27 && this.hide()\r\n      }, this))\r\n    } else if (!this.isShown) {\r\n      this.$element.off('keydown.dismiss.bs.modal')\r\n    }\r\n  }\r\n\r\n  Modal.prototype.resize = function () {\r\n    if (this.isShown) {\r\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\r\n    } else {\r\n      $(window).off('resize.bs.modal')\r\n    }\r\n  }\r\n\r\n  Modal.prototype.hideModal = function () {\r\n    var that = this\r\n    this.$element.hide()\r\n    this.backdrop(function () {\r\n      that.$body.removeClass('modal-open')\r\n      that.resetAdjustments()\r\n      that.resetScrollbar()\r\n      that.$element.trigger('hidden.bs.modal')\r\n    })\r\n  }\r\n\r\n  Modal.prototype.removeBackdrop = function () {\r\n    this.$backdrop && this.$backdrop.remove()\r\n    this.$backdrop = null\r\n  }\r\n\r\n  Modal.prototype.backdrop = function (callback) {\r\n    var that = this\r\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\r\n\r\n    if (this.isShown && this.options.backdrop) {\r\n      var doAnimate = $.support.transition && animate\r\n\r\n      this.$backdrop = $(document.createElement('div'))\r\n        .addClass('modal-backdrop ' + animate)\r\n        .appendTo(this.$body)\r\n\r\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\r\n        if (this.ignoreBackdropClick) {\r\n          this.ignoreBackdropClick = false\r\n          return\r\n        }\r\n        if (e.target !== e.currentTarget) return\r\n        this.options.backdrop == 'static'\r\n          ? this.$element[0].focus()\r\n          : this.hide()\r\n      }, this))\r\n\r\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\r\n\r\n      this.$backdrop.addClass('in')\r\n\r\n      if (!callback) return\r\n\r\n      doAnimate ?\r\n        this.$backdrop\r\n          .one('bsTransitionEnd', callback)\r\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\r\n        callback()\r\n\r\n    } else if (!this.isShown && this.$backdrop) {\r\n      this.$backdrop.removeClass('in')\r\n\r\n      var callbackRemove = function () {\r\n        that.removeBackdrop()\r\n        callback && callback()\r\n      }\r\n      $.support.transition && this.$element.hasClass('fade') ?\r\n        this.$backdrop\r\n          .one('bsTransitionEnd', callbackRemove)\r\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\r\n        callbackRemove()\r\n\r\n    } else if (callback) {\r\n      callback()\r\n    }\r\n  }\r\n\r\n  // these following methods are used to handle overflowing modals\r\n\r\n  Modal.prototype.handleUpdate = function () {\r\n    this.adjustDialog()\r\n  }\r\n\r\n  Modal.prototype.adjustDialog = function () {\r\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\r\n\r\n    this.$element.css({\r\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\r\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\r\n    })\r\n  }\r\n\r\n  Modal.prototype.resetAdjustments = function () {\r\n    this.$element.css({\r\n      paddingLeft: '',\r\n      paddingRight: ''\r\n    })\r\n  }\r\n\r\n  Modal.prototype.checkScrollbar = function () {\r\n    var fullWindowWidth = window.innerWidth\r\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\r\n      var documentElementRect = document.documentElement.getBoundingClientRect()\r\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\r\n    }\r\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\r\n    this.scrollbarWidth = this.measureScrollbar()\r\n  }\r\n\r\n  Modal.prototype.setScrollbar = function () {\r\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\r\n    this.originalBodyPad = document.body.style.paddingRight || ''\r\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\r\n  }\r\n\r\n  Modal.prototype.resetScrollbar = function () {\r\n    this.$body.css('padding-right', this.originalBodyPad)\r\n  }\r\n\r\n  Modal.prototype.measureScrollbar = function () { // thx walsh\r\n    var scrollDiv = document.createElement('div')\r\n    scrollDiv.className = 'modal-scrollbar-measure'\r\n    this.$body.append(scrollDiv)\r\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\r\n    this.$body[0].removeChild(scrollDiv)\r\n    return scrollbarWidth\r\n  }\r\n\r\n\r\n  // MODAL PLUGIN DEFINITION\r\n  // =======================\r\n\r\n  function Plugin(option, _relatedTarget) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.modal')\r\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\r\n\r\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\r\n      if (typeof option == 'string') data[option](_relatedTarget)\r\n      else if (options.show) data.show(_relatedTarget)\r\n    })\r\n  }\r\n\r\n  var old = $.fn.modal\r\n\r\n  $.fn.modal             = Plugin\r\n  $.fn.modal.Constructor = Modal\r\n\r\n\r\n  // MODAL NO CONFLICT\r\n  // =================\r\n\r\n  $.fn.modal.noConflict = function () {\r\n    $.fn.modal = old\r\n    return this\r\n  }\r\n\r\n\r\n  // MODAL DATA-API\r\n  // ==============\r\n\r\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\r\n    var $this   = $(this)\r\n    var href    = $this.attr('href')\r\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\r\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\r\n\r\n    if ($this.is('a')) e.preventDefault()\r\n\r\n    $target.one('show.bs.modal', function (showEvent) {\r\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\r\n      $target.one('hidden.bs.modal', function () {\r\n        $this.is(':visible') && $this.trigger('focus')\r\n      })\r\n    })\r\n    Plugin.call($target, option, this)\r\n  })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: tooltip.js v3.3.7\r\n * http://getbootstrap.com/javascript/#tooltip\r\n * Inspired by the original jQuery.tipsy by Jason Frame\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // TOOLTIP PUBLIC CLASS DEFINITION\r\n  // ===============================\r\n\r\n  var Tooltip = function (element, options) {\r\n    this.type       = null\r\n    this.options    = null\r\n    this.enabled    = null\r\n    this.timeout    = null\r\n    this.hoverState = null\r\n    this.$element   = null\r\n    this.inState    = null\r\n\r\n    this.init('tooltip', element, options)\r\n  }\r\n\r\n  Tooltip.VERSION  = '3.3.7'\r\n\r\n  Tooltip.TRANSITION_DURATION = 150\r\n\r\n  Tooltip.DEFAULTS = {\r\n    animation: true,\r\n    placement: 'top',\r\n    selector: false,\r\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\r\n    trigger: 'hover focus',\r\n    title: '',\r\n    delay: 0,\r\n    html: false,\r\n    container: false,\r\n    viewport: {\r\n      selector: 'body',\r\n      padding: 0\r\n    }\r\n  }\r\n\r\n  Tooltip.prototype.init = function (type, element, options) {\r\n    this.enabled   = true\r\n    this.type      = type\r\n    this.$element  = $(element)\r\n    this.options   = this.getOptions(options)\r\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\r\n    this.inState   = { click: false, hover: false, focus: false }\r\n\r\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\r\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\r\n    }\r\n\r\n    var triggers = this.options.trigger.split(' ')\r\n\r\n    for (var i = triggers.length; i--;) {\r\n      var trigger = triggers[i]\r\n\r\n      if (trigger == 'click') {\r\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\r\n      } else if (trigger != 'manual') {\r\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\r\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\r\n\r\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\r\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\r\n      }\r\n    }\r\n\r\n    this.options.selector ?\r\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\r\n      this.fixTitle()\r\n  }\r\n\r\n  Tooltip.prototype.getDefaults = function () {\r\n    return Tooltip.DEFAULTS\r\n  }\r\n\r\n  Tooltip.prototype.getOptions = function (options) {\r\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\r\n\r\n    if (options.delay && typeof options.delay == 'number') {\r\n      options.delay = {\r\n        show: options.delay,\r\n        hide: options.delay\r\n      }\r\n    }\r\n\r\n    return options\r\n  }\r\n\r\n  Tooltip.prototype.getDelegateOptions = function () {\r\n    var options  = {}\r\n    var defaults = this.getDefaults()\r\n\r\n    this._options && $.each(this._options, function (key, value) {\r\n      if (defaults[key] != value) options[key] = value\r\n    })\r\n\r\n    return options\r\n  }\r\n\r\n  Tooltip.prototype.enter = function (obj) {\r\n    var self = obj instanceof this.constructor ?\r\n      obj : $(obj.currentTarget).data('bs.' + this.type)\r\n\r\n    if (!self) {\r\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\r\n      $(obj.currentTarget).data('bs.' + this.type, self)\r\n    }\r\n\r\n    if (obj instanceof $.Event) {\r\n      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true\r\n    }\r\n\r\n    if (self.tip().hasClass('in') || self.hoverState == 'in') {\r\n      self.hoverState = 'in'\r\n      return\r\n    }\r\n\r\n    clearTimeout(self.timeout)\r\n\r\n    self.hoverState = 'in'\r\n\r\n    if (!self.options.delay || !self.options.delay.show) return self.show()\r\n\r\n    self.timeout = setTimeout(function () {\r\n      if (self.hoverState == 'in') self.show()\r\n    }, self.options.delay.show)\r\n  }\r\n\r\n  Tooltip.prototype.isInStateTrue = function () {\r\n    for (var key in this.inState) {\r\n      if (this.inState[key]) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  Tooltip.prototype.leave = function (obj) {\r\n    var self = obj instanceof this.constructor ?\r\n      obj : $(obj.currentTarget).data('bs.' + this.type)\r\n\r\n    if (!self) {\r\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\r\n      $(obj.currentTarget).data('bs.' + this.type, self)\r\n    }\r\n\r\n    if (obj instanceof $.Event) {\r\n      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false\r\n    }\r\n\r\n    if (self.isInStateTrue()) return\r\n\r\n    clearTimeout(self.timeout)\r\n\r\n    self.hoverState = 'out'\r\n\r\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\r\n\r\n    self.timeout = setTimeout(function () {\r\n      if (self.hoverState == 'out') self.hide()\r\n    }, self.options.delay.hide)\r\n  }\r\n\r\n  Tooltip.prototype.show = function () {\r\n    var e = $.Event('show.bs.' + this.type)\r\n\r\n    if (this.hasContent() && this.enabled) {\r\n      this.$element.trigger(e)\r\n\r\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\r\n      if (e.isDefaultPrevented() || !inDom) return\r\n      var that = this\r\n\r\n      var $tip = this.tip()\r\n\r\n      var tipId = this.getUID(this.type)\r\n\r\n      this.setContent()\r\n      $tip.attr('id', tipId)\r\n      this.$element.attr('aria-describedby', tipId)\r\n\r\n      if (this.options.animation) $tip.addClass('fade')\r\n\r\n      var placement = typeof this.options.placement == 'function' ?\r\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\r\n        this.options.placement\r\n\r\n      var autoToken = /\\s?auto?\\s?/i\r\n      var autoPlace = autoToken.test(placement)\r\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n      $tip\r\n        .detach()\r\n        .css({ top: 0, left: 0, display: 'block' })\r\n        .addClass(placement)\r\n        .data('bs.' + this.type, this)\r\n\r\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\r\n      this.$element.trigger('inserted.bs.' + this.type)\r\n\r\n      var pos          = this.getPosition()\r\n      var actualWidth  = $tip[0].offsetWidth\r\n      var actualHeight = $tip[0].offsetHeight\r\n\r\n      if (autoPlace) {\r\n        var orgPlacement = placement\r\n        var viewportDim = this.getPosition(this.$viewport)\r\n\r\n        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :\r\n                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :\r\n                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :\r\n                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :\r\n                    placement\r\n\r\n        $tip\r\n          .removeClass(orgPlacement)\r\n          .addClass(placement)\r\n      }\r\n\r\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n\r\n      this.applyPlacement(calculatedOffset, placement)\r\n\r\n      var complete = function () {\r\n        var prevHoverState = that.hoverState\r\n        that.$element.trigger('shown.bs.' + that.type)\r\n        that.hoverState = null\r\n\r\n        if (prevHoverState == 'out') that.leave(that)\r\n      }\r\n\r\n      $.support.transition && this.$tip.hasClass('fade') ?\r\n        $tip\r\n          .one('bsTransitionEnd', complete)\r\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\r\n        complete()\r\n    }\r\n  }\r\n\r\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\r\n    var $tip   = this.tip()\r\n    var width  = $tip[0].offsetWidth\r\n    var height = $tip[0].offsetHeight\r\n\r\n    // manually read margins because getBoundingClientRect includes difference\r\n    var marginTop = parseInt($tip.css('margin-top'), 10)\r\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\r\n\r\n    // we must check for NaN for ie 8/9\r\n    if (isNaN(marginTop))  marginTop  = 0\r\n    if (isNaN(marginLeft)) marginLeft = 0\r\n\r\n    offset.top  += marginTop\r\n    offset.left += marginLeft\r\n\r\n    // $.fn.offset doesn't round pixel values\r\n    // so we use setOffset directly with our own function B-0\r\n    $.offset.setOffset($tip[0], $.extend({\r\n      using: function (props) {\r\n        $tip.css({\r\n          top: Math.round(props.top),\r\n          left: Math.round(props.left)\r\n        })\r\n      }\r\n    }, offset), 0)\r\n\r\n    $tip.addClass('in')\r\n\r\n    // check to see if placing tip in new offset caused the tip to resize itself\r\n    var actualWidth  = $tip[0].offsetWidth\r\n    var actualHeight = $tip[0].offsetHeight\r\n\r\n    if (placement == 'top' && actualHeight != height) {\r\n      offset.top = offset.top + height - actualHeight\r\n    }\r\n\r\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\r\n\r\n    if (delta.left) offset.left += delta.left\r\n    else offset.top += delta.top\r\n\r\n    var isVertical          = /top|bottom/.test(placement)\r\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\r\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\r\n\r\n    $tip.offset(offset)\r\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\r\n  }\r\n\r\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\r\n    this.arrow()\r\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n      .css(isVertical ? 'top' : 'left', '')\r\n  }\r\n\r\n  Tooltip.prototype.setContent = function () {\r\n    var $tip  = this.tip()\r\n    var title = this.getTitle()\r\n\r\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\r\n    $tip.removeClass('fade in top bottom left right')\r\n  }\r\n\r\n  Tooltip.prototype.hide = function (callback) {\r\n    var that = this\r\n    var $tip = $(this.$tip)\r\n    var e    = $.Event('hide.bs.' + this.type)\r\n\r\n    function complete() {\r\n      if (that.hoverState != 'in') $tip.detach()\r\n      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.\r\n        that.$element\r\n          .removeAttr('aria-describedby')\r\n          .trigger('hidden.bs.' + that.type)\r\n      }\r\n      callback && callback()\r\n    }\r\n\r\n    this.$element.trigger(e)\r\n\r\n    if (e.isDefaultPrevented()) return\r\n\r\n    $tip.removeClass('in')\r\n\r\n    $.support.transition && $tip.hasClass('fade') ?\r\n      $tip\r\n        .one('bsTransitionEnd', complete)\r\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\r\n      complete()\r\n\r\n    this.hoverState = null\r\n\r\n    return this\r\n  }\r\n\r\n  Tooltip.prototype.fixTitle = function () {\r\n    var $e = this.$element\r\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\r\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\r\n    }\r\n  }\r\n\r\n  Tooltip.prototype.hasContent = function () {\r\n    return this.getTitle()\r\n  }\r\n\r\n  Tooltip.prototype.getPosition = function ($element) {\r\n    $element   = $element || this.$element\r\n\r\n    var el     = $element[0]\r\n    var isBody = el.tagName == 'BODY'\r\n\r\n    var elRect    = el.getBoundingClientRect()\r\n    if (elRect.width == null) {\r\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\r\n    }\r\n    var isSvg = window.SVGElement && el instanceof window.SVGElement\r\n    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.\r\n    // See https://github.com/twbs/bootstrap/issues/20280\r\n    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())\r\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\r\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\r\n\r\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\r\n  }\r\n\r\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\r\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\r\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\r\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\r\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\r\n\r\n  }\r\n\r\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\r\n    var delta = { top: 0, left: 0 }\r\n    if (!this.$viewport) return delta\r\n\r\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\r\n    var viewportDimensions = this.getPosition(this.$viewport)\r\n\r\n    if (/right|left/.test(placement)) {\r\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\r\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\r\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n        delta.top = viewportDimensions.top - topEdgeOffset\r\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\r\n      }\r\n    } else {\r\n      var leftEdgeOffset  = pos.left - viewportPadding\r\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\r\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n        delta.left = viewportDimensions.left - leftEdgeOffset\r\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\r\n      }\r\n    }\r\n\r\n    return delta\r\n  }\r\n\r\n  Tooltip.prototype.getTitle = function () {\r\n    var title\r\n    var $e = this.$element\r\n    var o  = this.options\r\n\r\n    title = $e.attr('data-original-title')\r\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\r\n\r\n    return title\r\n  }\r\n\r\n  Tooltip.prototype.getUID = function (prefix) {\r\n    do prefix += ~~(Math.random() * 1000000)\r\n    while (document.getElementById(prefix))\r\n    return prefix\r\n  }\r\n\r\n  Tooltip.prototype.tip = function () {\r\n    if (!this.$tip) {\r\n      this.$tip = $(this.options.template)\r\n      if (this.$tip.length != 1) {\r\n        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\r\n      }\r\n    }\r\n    return this.$tip\r\n  }\r\n\r\n  Tooltip.prototype.arrow = function () {\r\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\r\n  }\r\n\r\n  Tooltip.prototype.enable = function () {\r\n    this.enabled = true\r\n  }\r\n\r\n  Tooltip.prototype.disable = function () {\r\n    this.enabled = false\r\n  }\r\n\r\n  Tooltip.prototype.toggleEnabled = function () {\r\n    this.enabled = !this.enabled\r\n  }\r\n\r\n  Tooltip.prototype.toggle = function (e) {\r\n    var self = this\r\n    if (e) {\r\n      self = $(e.currentTarget).data('bs.' + this.type)\r\n      if (!self) {\r\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\r\n        $(e.currentTarget).data('bs.' + this.type, self)\r\n      }\r\n    }\r\n\r\n    if (e) {\r\n      self.inState.click = !self.inState.click\r\n      if (self.isInStateTrue()) self.enter(self)\r\n      else self.leave(self)\r\n    } else {\r\n      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\r\n    }\r\n  }\r\n\r\n  Tooltip.prototype.destroy = function () {\r\n    var that = this\r\n    clearTimeout(this.timeout)\r\n    this.hide(function () {\r\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\r\n      if (that.$tip) {\r\n        that.$tip.detach()\r\n      }\r\n      that.$tip = null\r\n      that.$arrow = null\r\n      that.$viewport = null\r\n      that.$element = null\r\n    })\r\n  }\r\n\r\n\r\n  // TOOLTIP PLUGIN DEFINITION\r\n  // =========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.tooltip')\r\n      var options = typeof option == 'object' && option\r\n\r\n      if (!data && /destroy|hide/.test(option)) return\r\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.tooltip\r\n\r\n  $.fn.tooltip             = Plugin\r\n  $.fn.tooltip.Constructor = Tooltip\r\n\r\n\r\n  // TOOLTIP NO CONFLICT\r\n  // ===================\r\n\r\n  $.fn.tooltip.noConflict = function () {\r\n    $.fn.tooltip = old\r\n    return this\r\n  }\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: popover.js v3.3.7\r\n * http://getbootstrap.com/javascript/#popovers\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // POPOVER PUBLIC CLASS DEFINITION\r\n  // ===============================\r\n\r\n  var Popover = function (element, options) {\r\n    this.init('popover', element, options)\r\n  }\r\n\r\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\r\n\r\n  Popover.VERSION  = '3.3.7'\r\n\r\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\r\n    placement: 'right',\r\n    trigger: 'click',\r\n    content: '',\r\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\r\n  })\r\n\r\n\r\n  // NOTE: POPOVER EXTENDS tooltip.js\r\n  // ================================\r\n\r\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\r\n\r\n  Popover.prototype.constructor = Popover\r\n\r\n  Popover.prototype.getDefaults = function () {\r\n    return Popover.DEFAULTS\r\n  }\r\n\r\n  Popover.prototype.setContent = function () {\r\n    var $tip    = this.tip()\r\n    var title   = this.getTitle()\r\n    var content = this.getContent()\r\n\r\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\r\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\r\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\r\n    ](content)\r\n\r\n    $tip.removeClass('fade top bottom left right in')\r\n\r\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\r\n    // this manually by checking the contents.\r\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\r\n  }\r\n\r\n  Popover.prototype.hasContent = function () {\r\n    return this.getTitle() || this.getContent()\r\n  }\r\n\r\n  Popover.prototype.getContent = function () {\r\n    var $e = this.$element\r\n    var o  = this.options\r\n\r\n    return $e.attr('data-content')\r\n      || (typeof o.content == 'function' ?\r\n            o.content.call($e[0]) :\r\n            o.content)\r\n  }\r\n\r\n  Popover.prototype.arrow = function () {\r\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\r\n  }\r\n\r\n\r\n  // POPOVER PLUGIN DEFINITION\r\n  // =========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.popover')\r\n      var options = typeof option == 'object' && option\r\n\r\n      if (!data && /destroy|hide/.test(option)) return\r\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.popover\r\n\r\n  $.fn.popover             = Plugin\r\n  $.fn.popover.Constructor = Popover\r\n\r\n\r\n  // POPOVER NO CONFLICT\r\n  // ===================\r\n\r\n  $.fn.popover.noConflict = function () {\r\n    $.fn.popover = old\r\n    return this\r\n  }\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: scrollspy.js v3.3.7\r\n * http://getbootstrap.com/javascript/#scrollspy\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // SCROLLSPY CLASS DEFINITION\r\n  // ==========================\r\n\r\n  function ScrollSpy(element, options) {\r\n    this.$body          = $(document.body)\r\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\r\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\r\n    this.selector       = (this.options.target || '') + ' .nav li > a'\r\n    this.offsets        = []\r\n    this.targets        = []\r\n    this.activeTarget   = null\r\n    this.scrollHeight   = 0\r\n\r\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\r\n    this.refresh()\r\n    this.process()\r\n  }\r\n\r\n  ScrollSpy.VERSION  = '3.3.7'\r\n\r\n  ScrollSpy.DEFAULTS = {\r\n    offset: 10\r\n  }\r\n\r\n  ScrollSpy.prototype.getScrollHeight = function () {\r\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\r\n  }\r\n\r\n  ScrollSpy.prototype.refresh = function () {\r\n    var that          = this\r\n    var offsetMethod  = 'offset'\r\n    var offsetBase    = 0\r\n\r\n    this.offsets      = []\r\n    this.targets      = []\r\n    this.scrollHeight = this.getScrollHeight()\r\n\r\n    if (!$.isWindow(this.$scrollElement[0])) {\r\n      offsetMethod = 'position'\r\n      offsetBase   = this.$scrollElement.scrollTop()\r\n    }\r\n\r\n    this.$body\r\n      .find(this.selector)\r\n      .map(function () {\r\n        var $el   = $(this)\r\n        var href  = $el.data('target') || $el.attr('href')\r\n        var $href = /^#./.test(href) && $(href)\r\n\r\n        return ($href\r\n          && $href.length\r\n          && $href.is(':visible')\r\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\r\n      })\r\n      .sort(function (a, b) { return a[0] - b[0] })\r\n      .each(function () {\r\n        that.offsets.push(this[0])\r\n        that.targets.push(this[1])\r\n      })\r\n  }\r\n\r\n  ScrollSpy.prototype.process = function () {\r\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\r\n    var scrollHeight = this.getScrollHeight()\r\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\r\n    var offsets      = this.offsets\r\n    var targets      = this.targets\r\n    var activeTarget = this.activeTarget\r\n    var i\r\n\r\n    if (this.scrollHeight != scrollHeight) {\r\n      this.refresh()\r\n    }\r\n\r\n    if (scrollTop >= maxScroll) {\r\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\r\n    }\r\n\r\n    if (activeTarget && scrollTop < offsets[0]) {\r\n      this.activeTarget = null\r\n      return this.clear()\r\n    }\r\n\r\n    for (i = offsets.length; i--;) {\r\n      activeTarget != targets[i]\r\n        && scrollTop >= offsets[i]\r\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\r\n        && this.activate(targets[i])\r\n    }\r\n  }\r\n\r\n  ScrollSpy.prototype.activate = function (target) {\r\n    this.activeTarget = target\r\n\r\n    this.clear()\r\n\r\n    var selector = this.selector +\r\n      '[data-target=\"' + target + '\"],' +\r\n      this.selector + '[href=\"' + target + '\"]'\r\n\r\n    var active = $(selector)\r\n      .parents('li')\r\n      .addClass('active')\r\n\r\n    if (active.parent('.dropdown-menu').length) {\r\n      active = active\r\n        .closest('li.dropdown')\r\n        .addClass('active')\r\n    }\r\n\r\n    active.trigger('activate.bs.scrollspy')\r\n  }\r\n\r\n  ScrollSpy.prototype.clear = function () {\r\n    $(this.selector)\r\n      .parentsUntil(this.options.target, '.active')\r\n      .removeClass('active')\r\n  }\r\n\r\n\r\n  // SCROLLSPY PLUGIN DEFINITION\r\n  // ===========================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.scrollspy')\r\n      var options = typeof option == 'object' && option\r\n\r\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.scrollspy\r\n\r\n  $.fn.scrollspy             = Plugin\r\n  $.fn.scrollspy.Constructor = ScrollSpy\r\n\r\n\r\n  // SCROLLSPY NO CONFLICT\r\n  // =====================\r\n\r\n  $.fn.scrollspy.noConflict = function () {\r\n    $.fn.scrollspy = old\r\n    return this\r\n  }\r\n\r\n\r\n  // SCROLLSPY DATA-API\r\n  // ==================\r\n\r\n  $(window).on('load.bs.scrollspy.data-api', function () {\r\n    $('[data-spy=\"scroll\"]').each(function () {\r\n      var $spy = $(this)\r\n      Plugin.call($spy, $spy.data())\r\n    })\r\n  })\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: tab.js v3.3.7\r\n * http://getbootstrap.com/javascript/#tabs\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // TAB CLASS DEFINITION\r\n  // ====================\r\n\r\n  var Tab = function (element) {\r\n    // jscs:disable requireDollarBeforejQueryAssignment\r\n    this.element = $(element)\r\n    // jscs:enable requireDollarBeforejQueryAssignment\r\n  }\r\n\r\n  Tab.VERSION = '3.3.7'\r\n\r\n  Tab.TRANSITION_DURATION = 150\r\n\r\n  Tab.prototype.show = function () {\r\n    var $this    = this.element\r\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\r\n    var selector = $this.data('target')\r\n\r\n    if (!selector) {\r\n      selector = $this.attr('href')\r\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\r\n    }\r\n\r\n    if ($this.parent('li').hasClass('active')) return\r\n\r\n    var $previous = $ul.find('.active:last a')\r\n    var hideEvent = $.Event('hide.bs.tab', {\r\n      relatedTarget: $this[0]\r\n    })\r\n    var showEvent = $.Event('show.bs.tab', {\r\n      relatedTarget: $previous[0]\r\n    })\r\n\r\n    $previous.trigger(hideEvent)\r\n    $this.trigger(showEvent)\r\n\r\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\r\n\r\n    var $target = $(selector)\r\n\r\n    this.activate($this.closest('li'), $ul)\r\n    this.activate($target, $target.parent(), function () {\r\n      $previous.trigger({\r\n        type: 'hidden.bs.tab',\r\n        relatedTarget: $this[0]\r\n      })\r\n      $this.trigger({\r\n        type: 'shown.bs.tab',\r\n        relatedTarget: $previous[0]\r\n      })\r\n    })\r\n  }\r\n\r\n  Tab.prototype.activate = function (element, container, callback) {\r\n    var $active    = container.find('> .active')\r\n    var transition = callback\r\n      && $.support.transition\r\n      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)\r\n\r\n    function next() {\r\n      $active\r\n        .removeClass('active')\r\n        .find('> .dropdown-menu > .active')\r\n          .removeClass('active')\r\n        .end()\r\n        .find('[data-toggle=\"tab\"]')\r\n          .attr('aria-expanded', false)\r\n\r\n      element\r\n        .addClass('active')\r\n        .find('[data-toggle=\"tab\"]')\r\n          .attr('aria-expanded', true)\r\n\r\n      if (transition) {\r\n        element[0].offsetWidth // reflow for transition\r\n        element.addClass('in')\r\n      } else {\r\n        element.removeClass('fade')\r\n      }\r\n\r\n      if (element.parent('.dropdown-menu').length) {\r\n        element\r\n          .closest('li.dropdown')\r\n            .addClass('active')\r\n          .end()\r\n          .find('[data-toggle=\"tab\"]')\r\n            .attr('aria-expanded', true)\r\n      }\r\n\r\n      callback && callback()\r\n    }\r\n\r\n    $active.length && transition ?\r\n      $active\r\n        .one('bsTransitionEnd', next)\r\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\r\n      next()\r\n\r\n    $active.removeClass('in')\r\n  }\r\n\r\n\r\n  // TAB PLUGIN DEFINITION\r\n  // =====================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n      var data  = $this.data('bs.tab')\r\n\r\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.tab\r\n\r\n  $.fn.tab             = Plugin\r\n  $.fn.tab.Constructor = Tab\r\n\r\n\r\n  // TAB NO CONFLICT\r\n  // ===============\r\n\r\n  $.fn.tab.noConflict = function () {\r\n    $.fn.tab = old\r\n    return this\r\n  }\r\n\r\n\r\n  // TAB DATA-API\r\n  // ============\r\n\r\n  var clickHandler = function (e) {\r\n    e.preventDefault()\r\n    Plugin.call($(this), 'show')\r\n  }\r\n\r\n  $(document)\r\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\r\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\r\n\r\n}(jQuery);\r\n\r\n/* ========================================================================\r\n * Bootstrap: affix.js v3.3.7\r\n * http://getbootstrap.com/javascript/#affix\r\n * ========================================================================\r\n * Copyright 2011-2016 Twitter, Inc.\r\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\r\n * ======================================================================== */\r\n\r\n\r\n+function ($) {\r\n  'use strict';\r\n\r\n  // AFFIX CLASS DEFINITION\r\n  // ======================\r\n\r\n  var Affix = function (element, options) {\r\n    this.options = $.extend({}, Affix.DEFAULTS, options)\r\n\r\n    this.$target = $(this.options.target)\r\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\r\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\r\n\r\n    this.$element     = $(element)\r\n    this.affixed      = null\r\n    this.unpin        = null\r\n    this.pinnedOffset = null\r\n\r\n    this.checkPosition()\r\n  }\r\n\r\n  Affix.VERSION  = '3.3.7'\r\n\r\n  Affix.RESET    = 'affix affix-top affix-bottom'\r\n\r\n  Affix.DEFAULTS = {\r\n    offset: 0,\r\n    target: window\r\n  }\r\n\r\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\r\n    var scrollTop    = this.$target.scrollTop()\r\n    var position     = this.$element.offset()\r\n    var targetHeight = this.$target.height()\r\n\r\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\r\n\r\n    if (this.affixed == 'bottom') {\r\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\r\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\r\n    }\r\n\r\n    var initializing   = this.affixed == null\r\n    var colliderTop    = initializing ? scrollTop : position.top\r\n    var colliderHeight = initializing ? targetHeight : height\r\n\r\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\r\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\r\n\r\n    return false\r\n  }\r\n\r\n  Affix.prototype.getPinnedOffset = function () {\r\n    if (this.pinnedOffset) return this.pinnedOffset\r\n    this.$element.removeClass(Affix.RESET).addClass('affix')\r\n    var scrollTop = this.$target.scrollTop()\r\n    var position  = this.$element.offset()\r\n    return (this.pinnedOffset = position.top - scrollTop)\r\n  }\r\n\r\n  Affix.prototype.checkPositionWithEventLoop = function () {\r\n    setTimeout($.proxy(this.checkPosition, this), 1)\r\n  }\r\n\r\n  Affix.prototype.checkPosition = function () {\r\n    if (!this.$element.is(':visible')) return\r\n\r\n    var height       = this.$element.height()\r\n    var offset       = this.options.offset\r\n    var offsetTop    = offset.top\r\n    var offsetBottom = offset.bottom\r\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\r\n\r\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\r\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\r\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\r\n\r\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\r\n\r\n    if (this.affixed != affix) {\r\n      if (this.unpin != null) this.$element.css('top', '')\r\n\r\n      var affixType = 'affix' + (affix ? '-' + affix : '')\r\n      var e         = $.Event(affixType + '.bs.affix')\r\n\r\n      this.$element.trigger(e)\r\n\r\n      if (e.isDefaultPrevented()) return\r\n\r\n      this.affixed = affix\r\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\r\n\r\n      this.$element\r\n        .removeClass(Affix.RESET)\r\n        .addClass(affixType)\r\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\r\n    }\r\n\r\n    if (affix == 'bottom') {\r\n      this.$element.offset({\r\n        top: scrollHeight - height - offsetBottom\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  // AFFIX PLUGIN DEFINITION\r\n  // =======================\r\n\r\n  function Plugin(option) {\r\n    return this.each(function () {\r\n      var $this   = $(this)\r\n      var data    = $this.data('bs.affix')\r\n      var options = typeof option == 'object' && option\r\n\r\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  var old = $.fn.affix\r\n\r\n  $.fn.affix             = Plugin\r\n  $.fn.affix.Constructor = Affix\r\n\r\n\r\n  // AFFIX NO CONFLICT\r\n  // =================\r\n\r\n  $.fn.affix.noConflict = function () {\r\n    $.fn.affix = old\r\n    return this\r\n  }\r\n\r\n\r\n  // AFFIX DATA-API\r\n  // ==============\r\n\r\n  $(window).on('load', function () {\r\n    $('[data-spy=\"affix\"]').each(function () {\r\n      var $spy = $(this)\r\n      var data = $spy.data()\r\n\r\n      data.offset = data.offset || {}\r\n\r\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\r\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\r\n\r\n      Plugin.call($spy, data)\r\n    })\r\n  })\r\n\r\n}(jQuery);\r\n"

/***/ }),

/***/ 254:
/***/ (function(module, exports) {

module.exports = "/*! JointJS v1.1.0 (2017-03-31) - JavaScript diagramming library\r\n\r\n\r\nThis Source Code Form is subject to the terms of the Mozilla Public\r\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\r\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n*/\r\n(function(root, factory) {\r\n\r\n    if (typeof define === 'function' && define.amd) {\r\n\r\n        // For AMD.\r\n\r\n        define(['backbone', 'lodash', 'jquery'], function(Backbone, _, $) {\r\n\r\n            Backbone.$ = $;\r\n\r\n            return factory(root, Backbone, _, $);\r\n        });\r\n\r\n    } else if (typeof exports !== 'undefined') {\r\n\r\n        // For Node.js or CommonJS.\r\n\r\n        var Backbone = require('backbone');\r\n        var _ = require('lodash');\r\n        var $ = Backbone.$ = require('jquery');\r\n\r\n        module.exports = factory(root, Backbone, _, $);\r\n\r\n    } else {\r\n\r\n        // As a browser global.\r\n\r\n        var Backbone = root.Backbone;\r\n        var _ = root._;\r\n        var $ = Backbone.$ = root.jQuery || root.$;\r\n\r\n        root.joint = factory(root, Backbone, _, $);\r\n        root.g = root.joint.g;\r\n        root.V = root.Vectorizer = root.joint.V;\r\n    }\r\n\r\n}(this, function(root, Backbone, _, $) {\r\n\r\n(function() {\r\n\r\n    /**\r\n     * version: 0.3.0\r\n     * git://github.com/davidchambers/Base64.js.git\r\n     */\r\n\r\n    var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\r\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n\r\n    function InvalidCharacterError(message) {\r\n        this.message = message;\r\n    }\r\n\r\n    InvalidCharacterError.prototype = new Error;\r\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\r\n\r\n    // encoder\r\n    // [https://gist.github.com/999166] by [https://github.com/nignag]\r\n    object.btoa || (\r\n        object.btoa = function(input) {\r\n            var str = String(input);\r\n            for (\r\n                // initialize result and counter\r\n                var block, charCode, idx = 0, map = chars, output = '';\r\n                // if the next str index does not exist:\r\n                //   change the mapping table to \"=\"\r\n                //   check if d has no fractional digits\r\n                str.charAt(idx | 0) || (map = '=', idx % 1);\r\n                // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\r\n                output += map.charAt(63 & block >> 8 - idx % 1 * 8)\r\n            ) {\r\n                charCode = str.charCodeAt(idx += 3 / 4);\r\n                if (charCode > 0xFF) {\r\n                    throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\r\n                }\r\n                block = block << 8 | charCode;\r\n            }\r\n            return output;\r\n        });\r\n\r\n    // decoder\r\n    // [https://gist.github.com/1020396] by [https://github.com/atk]\r\n    object.atob || (\r\n        object.atob = function(input) {\r\n            var str = String(input).replace(/=+$/, '');\r\n            if (str.length % 4 == 1) {\r\n                throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\r\n            }\r\n            for (\r\n                // initialize result and counters\r\n                var bc = 0, bs, buffer, idx = 0, output = '';\r\n                // get next character\r\n                // eslint-disable-next-line no-cond-assign\r\n                buffer = str.charAt(idx++);\r\n                // character found in table? initialize bit storage and add its ascii value;\r\n                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\r\n                    // and if not first of each 4 characters,\r\n                    // convert the first 8 bits to one ascii character\r\n                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\r\n            ) {\r\n                // try to find character in table (0-63, not found => -1)\r\n                buffer = chars.indexOf(buffer);\r\n            }\r\n            return output;\r\n        });\r\n\r\n}());\r\n\r\n(function() {\r\n\r\n    if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    function subarray(start, end) {\r\n        return this.slice(start, end);\r\n    }\r\n\r\n    function set_(array, offset) {\r\n\r\n        if (arguments.length < 2) {\r\n            offset = 0;\r\n        }\r\n        for (var i = 0, n = array.length; i < n; ++i, ++offset) {\r\n            this[offset] = array[i] & 0xFF;\r\n        }\r\n    }\r\n\r\n    // we need typed arrays\r\n    function TypedArray(arg1) {\r\n\r\n        var result;\r\n        if (typeof arg1 === 'number') {\r\n            result = new Array(arg1);\r\n            for (var i = 0; i < arg1; ++i) {\r\n                result[i] = 0;\r\n            }\r\n        } else {\r\n            result = arg1.slice(0);\r\n        }\r\n        result.subarray = subarray;\r\n        result.buffer = result;\r\n        result.byteLength = result.length;\r\n        result.set = set_;\r\n        if (typeof arg1 === 'object' && arg1.buffer) {\r\n            result.buffer = arg1.buffer;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    window.Uint8Array = TypedArray;\r\n    window.Uint32Array = TypedArray;\r\n    window.Int32Array = TypedArray;\r\n})();\r\n\r\n/**\r\n * make xhr.response = 'arraybuffer' available for the IE9\r\n */\r\n(function() {\r\n\r\n    if (typeof XMLHttpRequest === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    if ('response' in XMLHttpRequest.prototype ||\r\n        'mozResponseArrayBuffer' in XMLHttpRequest.prototype ||\r\n        'mozResponse' in XMLHttpRequest.prototype ||\r\n        'responseArrayBuffer' in XMLHttpRequest.prototype) {\r\n        return;\r\n    }\r\n\r\n    Object.defineProperty(XMLHttpRequest.prototype, 'response', {\r\n        get: function() {\r\n            return new Uint8Array(new VBArray(this.responseBody).toArray());\r\n        }\r\n    });\r\n})();\r\n\r\n\r\n//      Geometry library.\r\n\r\nvar g = (function() {\r\n\r\n    var g = {};\r\n\r\n    // Declare shorthands to the most used math functions.\r\n    var math = Math;\r\n    var abs = math.abs;\r\n    var cos = math.cos;\r\n    var sin = math.sin;\r\n    var sqrt = math.sqrt;\r\n    var mmin = math.min;\r\n    var mmax = math.max;\r\n    var atan2 = math.atan2;\r\n    var round = math.round;\r\n    var floor = math.floor;\r\n    var PI = math.PI;\r\n    var random = math.random;\r\n    var pow = math.pow;\r\n\r\n    g.bezier = {\r\n\r\n        // Cubic Bezier curve path through points.\r\n        // Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\r\n        // @param {array} points Array of points through which the smooth line will go.\r\n        // @return {array} SVG Path commands as an array\r\n        curveThroughPoints: function(points) {\r\n\r\n            var controlPoints = this.getCurveControlPoints(points);\r\n            var path = ['M', points[0].x, points[0].y];\r\n\r\n            for (var i = 0; i < controlPoints[0].length; i++) {\r\n                path.push('C', controlPoints[0][i].x, controlPoints[0][i].y, controlPoints[1][i].x, controlPoints[1][i].y, points[i + 1].x, points[i + 1].y);\r\n            }\r\n\r\n            return path;\r\n        },\r\n\r\n        // Get open-ended Bezier Spline Control Points.\r\n        // @param knots Input Knot Bezier spline points (At least two points!).\r\n        // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\r\n        // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\r\n        getCurveControlPoints: function(knots) {\r\n\r\n            var firstControlPoints = [];\r\n            var secondControlPoints = [];\r\n            var n = knots.length - 1;\r\n            var i;\r\n\r\n            // Special case: Bezier curve should be a straight line.\r\n            if (n == 1) {\r\n                // 3P1 = 2P0 + P3\r\n                firstControlPoints[0] = Point((2 * knots[0].x + knots[1].x) / 3,\r\n                                              (2 * knots[0].y + knots[1].y) / 3);\r\n                // P2 = 2P1  P0\r\n                secondControlPoints[0] = Point(2 * firstControlPoints[0].x - knots[0].x,\r\n                                               2 * firstControlPoints[0].y - knots[0].y);\r\n                return [firstControlPoints, secondControlPoints];\r\n            }\r\n\r\n            // Calculate first Bezier control points.\r\n            // Right hand side vector.\r\n            var rhs = [];\r\n\r\n            // Set right hand side X values.\r\n            for (i = 1; i < n - 1; i++) {\r\n                rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\r\n            }\r\n            rhs[0] = knots[0].x + 2 * knots[1].x;\r\n            rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\r\n            // Get first control points X-values.\r\n            var x = this.getFirstControlPoints(rhs);\r\n\r\n            // Set right hand side Y values.\r\n            for (i = 1; i < n - 1; ++i) {\r\n                rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\r\n            }\r\n            rhs[0] = knots[0].y + 2 * knots[1].y;\r\n            rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\r\n            // Get first control points Y-values.\r\n            var y = this.getFirstControlPoints(rhs);\r\n\r\n            // Fill output arrays.\r\n            for (i = 0; i < n; i++) {\r\n                // First control point.\r\n                firstControlPoints.push(Point(x[i], y[i]));\r\n                // Second control point.\r\n                if (i < n - 1) {\r\n                    secondControlPoints.push(Point(2 * knots [i + 1].x - x[i + 1],\r\n                                                   2 * knots[i + 1].y - y[i + 1]));\r\n                } else {\r\n                    secondControlPoints.push(Point((knots[n].x + x[n - 1]) / 2,\r\n                                                   (knots[n].y + y[n - 1]) / 2));\r\n                }\r\n            }\r\n            return [firstControlPoints, secondControlPoints];\r\n        },\r\n\r\n        // Divide a Bezier curve into two at point defined by value 't' <0,1>.\r\n        // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\r\n        // @param control points (start, control start, control end, end)\r\n        // @return a function accepts t and returns 2 curves each defined by 4 control points.\r\n        getCurveDivider: function(p0, p1, p2, p3) {\r\n\r\n            return function divideCurve(t) {\r\n\r\n                var l = Line(p0, p1).pointAt(t);\r\n                var m = Line(p1, p2).pointAt(t);\r\n                var n = Line(p2, p3).pointAt(t);\r\n                var p = Line(l, m).pointAt(t);\r\n                var q = Line(m, n).pointAt(t);\r\n                var r = Line(p, q).pointAt(t);\r\n                return [{ p0: p0, p1: l, p2: p, p3: r }, { p0: r, p1: q, p2: n, p3: p3 }];\r\n            };\r\n        },\r\n\r\n        // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\r\n        // @param rhs Right hand side vector.\r\n        // @return Solution vector.\r\n        getFirstControlPoints: function(rhs) {\r\n\r\n            var n = rhs.length;\r\n            // `x` is a solution vector.\r\n            var x = [];\r\n            var tmp = [];\r\n            var b = 2.0;\r\n\r\n            x[0] = rhs[0] / b;\r\n            // Decomposition and forward substitution.\r\n            for (var i = 1; i < n; i++) {\r\n                tmp[i] = 1 / b;\r\n                b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\r\n                x[i] = (rhs[i] - x[i - 1]) / b;\r\n            }\r\n            for (i = 1; i < n; i++) {\r\n                // Backsubstitution.\r\n                x[n - i - 1] -= tmp[n - i] * x[n - i];\r\n            }\r\n            return x;\r\n        },\r\n\r\n        // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\r\n        // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\r\n        // which corresponds to that point.\r\n        // @param control points (start, control start, control end, end)\r\n        // @return a function accepts a point and returns t.\r\n        getInversionSolver: function(p0, p1, p2, p3) {\r\n\r\n            var pts = arguments;\r\n            function l(i, j) {\r\n                // calculates a determinant 3x3\r\n                // [p.x  p.y  1]\r\n                // [pi.x pi.y 1]\r\n                // [pj.x pj.y 1]\r\n                var pi = pts[i];\r\n                var pj = pts[j];\r\n                return function(p) {\r\n                    var w = (i % 3 ? 3 : 1) * (j % 3 ? 3 : 1);\r\n                    var lij = p.x * (pi.y - pj.y) + p.y * (pj.x - pi.x) + pi.x * pj.y - pi.y * pj.x;\r\n                    return w * lij;\r\n                };\r\n            }\r\n            return function solveInversion(p) {\r\n                var ct = 3 * l(2, 3)(p1);\r\n                var c1 = l(1, 3)(p0) / ct;\r\n                var c2 = -l(2, 3)(p0) / ct;\r\n                var la = c1 * l(3, 1)(p) + c2 * (l(3, 0)(p) + l(2, 1)(p)) + l(2, 0)(p);\r\n                var lb = c1 * l(3, 0)(p) + c2 * l(2, 0)(p) + l(1, 0)(p);\r\n                return lb / (lb - la);\r\n            };\r\n        }\r\n    };\r\n\r\n    var Ellipse = g.Ellipse = function(c, a, b) {\r\n\r\n        if (!(this instanceof Ellipse)) {\r\n            return new Ellipse(c, a, b);\r\n        }\r\n\r\n        if (c instanceof Ellipse) {\r\n            return new Ellipse(Point(c), c.a, c.b);\r\n        }\r\n\r\n        c = Point(c);\r\n        this.x = c.x;\r\n        this.y = c.y;\r\n        this.a = a;\r\n        this.b = b;\r\n    };\r\n\r\n    g.Ellipse.fromRect = function(rect) {\r\n\r\n        rect = Rect(rect);\r\n        return Ellipse(rect.center(), rect.width / 2, rect.height / 2);\r\n    };\r\n\r\n    g.Ellipse.prototype = {\r\n\r\n        bbox: function() {\r\n\r\n            return Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\r\n        },\r\n\r\n        clone: function() {\r\n\r\n            return Ellipse(this);\r\n        },\r\n\r\n        /**\r\n         * @param {g.Point} point\r\n         * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\r\n         */\r\n        normalizedDistance: function(point) {\r\n\r\n            var x0 = point.x;\r\n            var y0 = point.y;\r\n            var a = this.a;\r\n            var b = this.b;\r\n            var x = this.x;\r\n            var y = this.y;\r\n\r\n            return ((x0 - x) * (x0 - x)) / (a * a ) + ((y0 - y) * (y0 - y)) / (b * b);\r\n        },\r\n\r\n        // inflate by dx and dy\r\n        // @param dx {delta_x} representing additional size to x\r\n        // @param dy {delta_y} representing additional size to y -\r\n        // dy param is not required -> in that case y is sized by dx\r\n        inflate: function(dx, dy) {\r\n            if (dx === undefined) {\r\n                dx = 0;\r\n            }\r\n\r\n            if (dy === undefined) {\r\n                dy = dx;\r\n            }\r\n\r\n            this.a += 2 * dx;\r\n            this.b += 2 * dy;\r\n\r\n            return this;\r\n        },\r\n\r\n\r\n        /**\r\n         * @param {g.Point} p\r\n         * @returns {boolean}\r\n         */\r\n        containsPoint: function(p) {\r\n\r\n            return this.normalizedDistance(p) <= 1;\r\n        },\r\n\r\n        /**\r\n         * @returns {g.Point}\r\n         */\r\n        center: function() {\r\n\r\n            return Point(this.x, this.y);\r\n        },\r\n\r\n        /** Compute angle between tangent and x axis\r\n         * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\r\n         * @returns {number} angle between tangent and x axis\r\n         */\r\n        tangentTheta: function(p) {\r\n\r\n            var refPointDelta = 30;\r\n            var x0 = p.x;\r\n            var y0 = p.y;\r\n            var a = this.a;\r\n            var b = this.b;\r\n            var center = this.bbox().center();\r\n            var m = center.x;\r\n            var n = center.y;\r\n\r\n            var q1 = x0 > center.x + a / 2;\r\n            var q3 = x0 < center.x - a / 2;\r\n\r\n            var y, x;\r\n            if (q1 || q3) {\r\n                y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\r\n                x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\r\n            } else {\r\n                x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\r\n                y = ( b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\r\n            }\r\n\r\n            return g.point(x, y).theta(p);\r\n\r\n        },\r\n\r\n        equals: function(ellipse) {\r\n\r\n            ellipse = Ellipse(ellipse);\r\n            return ellipse.x === this.x &&\r\n                    ellipse.y === this.y &&\r\n                    ellipse.a === this.a &&\r\n                    ellipse.b === this.b;\r\n        },\r\n\r\n        // Find point on me where line from my center to\r\n        // point p intersects my boundary.\r\n        // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\r\n        intersectionWithLineFromCenterToPoint: function(p, angle) {\r\n\r\n            p = Point(p);\r\n            if (angle) p.rotate(Point(this.x, this.y), angle);\r\n            var dx = p.x - this.x;\r\n            var dy = p.y - this.y;\r\n            var result;\r\n            if (dx === 0) {\r\n                result = this.bbox().pointNearestToPoint(p);\r\n                if (angle) return result.rotate(Point(this.x, this.y), -angle);\r\n                return result;\r\n            }\r\n            var m = dy / dx;\r\n            var mSquared = m * m;\r\n            var aSquared = this.a * this.a;\r\n            var bSquared = this.b * this.b;\r\n            var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\r\n\r\n            x = dx < 0 ? -x : x;\r\n            var y = m * x;\r\n            result = Point(this.x + x, this.y + y);\r\n            if (angle) return result.rotate(Point(this.x, this.y), -angle);\r\n            return result;\r\n        },\r\n\r\n        toString: function() {\r\n\r\n            return Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\r\n        }\r\n    };\r\n\r\n    var Line = g.Line = function(p1, p2) {\r\n\r\n        if (!(this instanceof Line)) {\r\n            return new Line(p1, p2);\r\n        }\r\n\r\n        this.start = Point(p1);\r\n        this.end = Point(p2);\r\n    };\r\n\r\n    g.Line.prototype = {\r\n\r\n        // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\r\n        // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\r\n        bearing: function() {\r\n\r\n            var lat1 = toRad(this.start.y);\r\n            var lat2 = toRad(this.end.y);\r\n            var lon1 = this.start.x;\r\n            var lon2 = this.end.x;\r\n            var dLon = toRad(lon2 - lon1);\r\n            var y = sin(dLon) * cos(lat2);\r\n            var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\r\n            var brng = toDeg(atan2(y, x));\r\n\r\n            var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\r\n\r\n            var index = brng - 22.5;\r\n            if (index < 0)\r\n                index += 360;\r\n            index = parseInt(index / 45);\r\n\r\n            return bearings[index];\r\n        },\r\n\r\n        clone: function() {\r\n\r\n            return Line(this);\r\n        },\r\n\r\n        equals: function(l) {\r\n\r\n            return this.start.x === l.start.x &&\r\n                    this.start.y === l.start.y &&\r\n                    this.end.x === l.end.x &&\r\n                    this.end.y === l.end.y;\r\n        },\r\n\r\n        // @return {point} Point where I'm intersecting a line.\r\n        // @return [point] Points where I'm intersecting a rectangle.\r\n        // @see Squeak Smalltalk, LineSegment>>intersectionWith:\r\n        intersect: function(l) {\r\n\r\n            if (l instanceof Line) {\r\n                // Passed in parameter is a line.\r\n\r\n                var pt1Dir = Point(this.end.x - this.start.x, this.end.y - this.start.y);\r\n                var pt2Dir = Point(l.end.x - l.start.x, l.end.y - l.start.y);\r\n                var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\r\n                var deltaPt = Point(l.start.x - this.start.x, l.start.y - this.start.y);\r\n                var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\r\n                var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\r\n\r\n                if (det === 0 ||\r\n                    alpha * det < 0 ||\r\n                    beta * det < 0) {\r\n                    // No intersection found.\r\n                    return null;\r\n                }\r\n                if (det > 0) {\r\n                    if (alpha > det || beta > det) {\r\n                        return null;\r\n                    }\r\n                } else {\r\n                    if (alpha < det || beta < det) {\r\n                        return null;\r\n                    }\r\n                }\r\n                return Point(this.start.x + (alpha * pt1Dir.x / det),\r\n                             this.start.y + (alpha * pt1Dir.y / det));\r\n\r\n            } else if (l instanceof Rect) {\r\n                // Passed in parameter is a rectangle.\r\n\r\n                var r = l;\r\n                var rectLines = [ r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine() ];\r\n                var points = [];\r\n                var dedupeArr = [];\r\n                var pt, i;\r\n\r\n                for (i = 0; i < rectLines.length; i ++) {\r\n                    pt = this.intersect(rectLines[i]);\r\n                    if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\r\n                        points.push(pt);\r\n                        dedupeArr.push(pt.toString());\r\n                    }\r\n                }\r\n\r\n                return points.length > 0 ? points : null;\r\n            }\r\n\r\n            // Passed in parameter is neither a Line nor a Rectangle.\r\n            return null;\r\n        },\r\n\r\n        // @return {double} length of the line\r\n        length: function() {\r\n            return sqrt(this.squaredLength());\r\n        },\r\n\r\n        // @return {point} my midpoint\r\n        midpoint: function() {\r\n            return Point((this.start.x + this.end.x) / 2,\r\n                         (this.start.y + this.end.y) / 2);\r\n        },\r\n\r\n        // @return {point} my point at 't' <0,1>\r\n        pointAt: function(t) {\r\n\r\n            var x = (1 - t) * this.start.x + t * this.end.x;\r\n            var y = (1 - t) * this.start.y + t * this.end.y;\r\n            return Point(x, y);\r\n        },\r\n\r\n        // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\r\n        pointOffset: function(p) {\r\n\r\n            // Find the sign of the determinant of vectors (start,end), where p is the query point.\r\n            return ((this.end.x - this.start.x) * (p.y - this.start.y) - (this.end.y - this.start.y) * (p.x - this.start.x)) / 2;\r\n        },\r\n\r\n        // @return {integer} length without sqrt\r\n        // @note for applications where the exact length is not necessary (e.g. compare only)\r\n        squaredLength: function() {\r\n            var x0 = this.start.x;\r\n            var y0 = this.start.y;\r\n            var x1 = this.end.x;\r\n            var y1 = this.end.y;\r\n            return (x0 -= x1) * x0 + (y0 -= y1) * y0;\r\n        },\r\n\r\n        toString: function() {\r\n            return this.start.toString() + ' ' + this.end.toString();\r\n        }\r\n    };\r\n\r\n    // For backwards compatibility:\r\n    g.Line.prototype.intersection = g.Line.prototype.intersect;\r\n\r\n    /*\r\n        Point is the most basic object consisting of x/y coordinate.\r\n\r\n        Possible instantiations are:\r\n        * `Point(10, 20)`\r\n        * `new Point(10, 20)`\r\n        * `Point('10 20')`\r\n        * `Point(Point(10, 20))`\r\n    */\r\n    var Point = g.Point = function(x, y) {\r\n\r\n        if (!(this instanceof Point)) {\r\n            return new Point(x, y);\r\n        }\r\n\r\n        if (typeof x === 'string') {\r\n            var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\r\n            x = parseInt(xy[0], 10);\r\n            y = parseInt(xy[1], 10);\r\n        } else if (Object(x) === x) {\r\n            y = x.y;\r\n            x = x.x;\r\n        }\r\n\r\n        this.x = x === undefined ? 0 : x;\r\n        this.y = y === undefined ? 0 : y;\r\n    };\r\n\r\n    // Alternative constructor, from polar coordinates.\r\n    // @param {number} Distance.\r\n    // @param {number} Angle in radians.\r\n    // @param {point} [optional] Origin.\r\n    g.Point.fromPolar = function(distance, angle, origin) {\r\n\r\n        origin = (origin && Point(origin)) || Point(0, 0);\r\n        var x = abs(distance * cos(angle));\r\n        var y = abs(distance * sin(angle));\r\n        var deg = normalizeAngle(toDeg(angle));\r\n\r\n        if (deg < 90) {\r\n            y = -y;\r\n        } else if (deg < 180) {\r\n            x = -x;\r\n            y = -y;\r\n        } else if (deg < 270) {\r\n            x = -x;\r\n        }\r\n\r\n        return Point(origin.x + x, origin.y + y);\r\n    };\r\n\r\n    // Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\r\n    g.Point.random = function(x1, x2, y1, y2) {\r\n\r\n        return Point(floor(random() * (x2 - x1 + 1) + x1), floor(random() * (y2 - y1 + 1) + y1));\r\n    };\r\n\r\n    g.Point.prototype = {\r\n\r\n        // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\r\n        // otherwise return point itself.\r\n        // (see Squeak Smalltalk, Point>>adhereTo:)\r\n        adhereToRect: function(r) {\r\n\r\n            if (r.containsPoint(this)) {\r\n                return this;\r\n            }\r\n\r\n            this.x = mmin(mmax(this.x, r.x), r.x + r.width);\r\n            this.y = mmin(mmax(this.y, r.y), r.y + r.height);\r\n            return this;\r\n        },\r\n\r\n        // Return the bearing between me and the given point.\r\n        bearing: function(point) {\r\n\r\n            return Line(this, point).bearing();\r\n        },\r\n\r\n        // Returns change in angle from my previous position (-dx, -dy) to my new position\r\n        // relative to ref point.\r\n        changeInAngle: function(dx, dy, ref) {\r\n\r\n            // Revert the translation and measure the change in angle around x-axis.\r\n            return Point(this).offset(-dx, -dy).theta(ref) - this.theta(ref);\r\n        },\r\n\r\n        clone: function() {\r\n\r\n            return Point(this);\r\n        },\r\n\r\n        difference: function(dx, dy) {\r\n\r\n            if ((Object(dx) === dx)) {\r\n                dy = dx.y;\r\n                dx = dx.x;\r\n            }\r\n\r\n            return Point(this.x - (dx || 0), this.y - (dy || 0));\r\n        },\r\n\r\n        // Returns distance between me and point `p`.\r\n        distance: function(p) {\r\n\r\n            return Line(this, p).length();\r\n        },\r\n\r\n        equals: function(p) {\r\n\r\n            return this.x === p.x && this.y === p.y;\r\n        },\r\n\r\n        magnitude: function() {\r\n\r\n            return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\r\n        },\r\n\r\n        // Returns a manhattan (taxi-cab) distance between me and point `p`.\r\n        manhattanDistance: function(p) {\r\n\r\n            return abs(p.x - this.x) + abs(p.y - this.y);\r\n        },\r\n\r\n        // Move point on line starting from ref ending at me by\r\n        // distance distance.\r\n        move: function(ref, distance) {\r\n\r\n            var theta = toRad(Point(ref).theta(this));\r\n            return this.offset(cos(theta) * distance, -sin(theta) * distance);\r\n        },\r\n\r\n        // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\r\n        normalize: function(length) {\r\n\r\n            var scale = (length || 1) / this.magnitude();\r\n            return this.scale(scale, scale);\r\n        },\r\n\r\n        // Offset me by the specified amount.\r\n        offset: function(dx, dy) {\r\n\r\n            if ((Object(dx) === dx)) {\r\n                dy = dx.y;\r\n                dx = dx.x;\r\n            }\r\n\r\n            this.x += dx || 0;\r\n            this.y += dy || 0;\r\n            return this;\r\n        },\r\n\r\n        // Returns a point that is the reflection of me with\r\n        // the center of inversion in ref point.\r\n        reflection: function(ref) {\r\n\r\n            return Point(ref).move(this, this.distance(ref));\r\n        },\r\n\r\n        // Rotate point by angle around origin.\r\n        rotate: function(origin, angle) {\r\n\r\n            angle = (angle + 360) % 360;\r\n            this.toPolar(origin);\r\n            this.y += toRad(angle);\r\n            var point = Point.fromPolar(this.x, this.y, origin);\r\n            this.x = point.x;\r\n            this.y = point.y;\r\n            return this;\r\n        },\r\n\r\n        round: function(precision) {\r\n\r\n            var f = pow(10, precision || 0);\r\n            this.x = round(this.x * f) / f;\r\n            this.y = round(this.y * f) / f;\r\n            return this;\r\n        },\r\n\r\n        // Scale point with origin.\r\n        scale: function(sx, sy, origin) {\r\n\r\n            origin = (origin && Point(origin)) || Point(0, 0);\r\n            this.x = origin.x + sx * (this.x - origin.x);\r\n            this.y = origin.y + sy * (this.y - origin.y);\r\n            return this;\r\n        },\r\n\r\n        snapToGrid: function(gx, gy) {\r\n\r\n            this.x = snapToGrid(this.x, gx);\r\n            this.y = snapToGrid(this.y, gy || gx);\r\n            return this;\r\n        },\r\n\r\n        // Compute the angle between me and `p` and the x axis.\r\n        // (cartesian-to-polar coordinates conversion)\r\n        // Return theta angle in degrees.\r\n        theta: function(p) {\r\n\r\n            p = Point(p);\r\n            // Invert the y-axis.\r\n            var y = -(p.y - this.y);\r\n            var x = p.x - this.x;\r\n            // Makes sure that the comparison with zero takes rounding errors into account.\r\n            var PRECISION = 10;\r\n            // Note that `atan2` is not defined for `x`, `y` both equal zero.\r\n            var rad = (y.toFixed(PRECISION) == 0 && x.toFixed(PRECISION) == 0) ? 0 : atan2(y, x);\r\n\r\n            // Correction for III. and IV. quadrant.\r\n            if (rad < 0) {\r\n                rad = 2 * PI + rad;\r\n            }\r\n            return 180 * rad / PI;\r\n        },\r\n\r\n        toJSON: function() {\r\n\r\n            return { x: this.x, y: this.y };\r\n        },\r\n\r\n        // Converts rectangular to polar coordinates.\r\n        // An origin can be specified, otherwise it's 0@0.\r\n        toPolar: function(o) {\r\n\r\n            o = (o && Point(o)) || Point(0, 0);\r\n            var x = this.x;\r\n            var y = this.y;\r\n            this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\r\n            this.y = toRad(o.theta(Point(x, y)));\r\n            return this;\r\n        },\r\n\r\n        toString: function() {\r\n\r\n            return this.x + '@' + this.y;\r\n        },\r\n\r\n        update: function(x, y) {\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            return this;\r\n        }\r\n    };\r\n\r\n    var Rect = g.Rect = function(x, y, w, h) {\r\n\r\n        if (!(this instanceof Rect)) {\r\n            return new Rect(x, y, w, h);\r\n        }\r\n\r\n        if ((Object(x) === x)) {\r\n            y = x.y;\r\n            w = x.width;\r\n            h = x.height;\r\n            x = x.x;\r\n        }\r\n\r\n        this.x = x === undefined ? 0 : x;\r\n        this.y = y === undefined ? 0 : y;\r\n        this.width = w === undefined ? 0 : w;\r\n        this.height = h === undefined ? 0 : h;\r\n    };\r\n\r\n    g.Rect.fromEllipse = function(e) {\r\n\r\n        e = Ellipse(e);\r\n        return Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\r\n    };\r\n\r\n    g.Rect.prototype = {\r\n\r\n        // Find my bounding box when I'm rotated with the center of rotation in the center of me.\r\n        // @return r {rectangle} representing a bounding box\r\n        bbox: function(angle) {\r\n\r\n            var theta = toRad(angle || 0);\r\n            var st = abs(sin(theta));\r\n            var ct = abs(cos(theta));\r\n            var w = this.width * ct + this.height * st;\r\n            var h = this.width * st + this.height * ct;\r\n            return Rect(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\r\n        },\r\n\r\n        bottomLeft: function() {\r\n\r\n            return Point(this.x, this.y + this.height);\r\n        },\r\n\r\n        bottomLine: function() {\r\n\r\n            return Line(this.bottomLeft(), this.corner());\r\n        },\r\n\r\n        bottomMiddle: function() {\r\n\r\n            return Point(this.x + this.width / 2, this.y + this.height);\r\n        },\r\n\r\n        center: function() {\r\n\r\n            return Point(this.x + this.width / 2, this.y + this.height / 2);\r\n        },\r\n\r\n        clone: function() {\r\n\r\n            return Rect(this);\r\n        },\r\n\r\n        // @return {bool} true if point p is insight me\r\n        containsPoint: function(p) {\r\n\r\n            p = Point(p);\r\n            return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\r\n        },\r\n\r\n        // @return {bool} true if rectangle `r` is inside me.\r\n        containsRect: function(r) {\r\n\r\n            var r0 = Rect(this).normalize();\r\n            var r1 = Rect(r).normalize();\r\n            var w0 = r0.width;\r\n            var h0 = r0.height;\r\n            var w1 = r1.width;\r\n            var h1 = r1.height;\r\n\r\n            if (!w0 || !h0 || !w1 || !h1) {\r\n                // At least one of the dimensions is 0\r\n                return false;\r\n            }\r\n\r\n            var x0 = r0.x;\r\n            var y0 = r0.y;\r\n            var x1 = r1.x;\r\n            var y1 = r1.y;\r\n\r\n            w1 += x1;\r\n            w0 += x0;\r\n            h1 += y1;\r\n            h0 += y0;\r\n\r\n            return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\r\n        },\r\n\r\n        corner: function() {\r\n\r\n            return Point(this.x + this.width, this.y + this.height);\r\n        },\r\n\r\n        // @return {boolean} true if rectangles are equal.\r\n        equals: function(r) {\r\n\r\n            var mr = Rect(this).normalize();\r\n            var nr = Rect(r).normalize();\r\n            return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\r\n        },\r\n\r\n        // @return {rect} if rectangles intersect, {null} if not.\r\n        intersect: function(r) {\r\n\r\n            var myOrigin = this.origin();\r\n            var myCorner = this.corner();\r\n            var rOrigin = r.origin();\r\n            var rCorner = r.corner();\r\n\r\n            // No intersection found\r\n            if (rCorner.x <= myOrigin.x ||\r\n                rCorner.y <= myOrigin.y ||\r\n                rOrigin.x >= myCorner.x ||\r\n                rOrigin.y >= myCorner.y) return null;\r\n\r\n            var x = Math.max(myOrigin.x, rOrigin.x);\r\n            var y = Math.max(myOrigin.y, rOrigin.y);\r\n\r\n            return Rect(x, y, Math.min(myCorner.x, rCorner.x) - x, Math.min(myCorner.y, rCorner.y) - y);\r\n        },\r\n\r\n        // Find point on my boundary where line starting\r\n        // from my center ending in point p intersects me.\r\n        // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\r\n        intersectionWithLineFromCenterToPoint: function(p, angle) {\r\n\r\n            p = Point(p);\r\n            var center = Point(this.x + this.width / 2, this.y + this.height / 2);\r\n            var result;\r\n            if (angle) p.rotate(center, angle);\r\n\r\n            // (clockwise, starting from the top side)\r\n            var sides = [\r\n                Line(this.origin(), this.topRight()),\r\n                Line(this.topRight(), this.corner()),\r\n                Line(this.corner(), this.bottomLeft()),\r\n                Line(this.bottomLeft(), this.origin())\r\n            ];\r\n            var connector = Line(center, p);\r\n\r\n            for (var i = sides.length - 1; i >= 0; --i) {\r\n                var intersection = sides[i].intersection(connector);\r\n                if (intersection !== null) {\r\n                    result = intersection;\r\n                    break;\r\n                }\r\n            }\r\n            if (result && angle) result.rotate(center, -angle);\r\n            return result;\r\n        },\r\n\r\n        leftLine: function() {\r\n\r\n            return Line(this.origin(), this.bottomLeft());\r\n        },\r\n\r\n        leftMiddle: function() {\r\n\r\n            return Point(this.x , this.y + this.height / 2);\r\n        },\r\n\r\n        // Move and expand me.\r\n        // @param r {rectangle} representing deltas\r\n        moveAndExpand: function(r) {\r\n\r\n            this.x += r.x || 0;\r\n            this.y += r.y || 0;\r\n            this.width += r.width || 0;\r\n            this.height += r.height || 0;\r\n            return this;\r\n        },\r\n\r\n        // inflate by dx and dy, recompute origin [x, y]\r\n        // @param dx {delta_x} representing additional size to x\r\n        // @param dy {delta_y} representing additional size to y -\r\n        // dy param is not required -> in that case y is sized by dx\r\n        inflate: function(dx, dy) {\r\n            if (dx === undefined) {\r\n                dx = 0;\r\n            }\r\n\r\n            if (dy === undefined) {\r\n                dy = dx;\r\n            }\r\n\r\n            this.x -= dx;\r\n            this.y -= dy;\r\n            this.width += 2 * dx;\r\n            this.height += 2 * dy;\r\n\r\n            return this;\r\n        },\r\n\r\n        // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\r\n        // If width < 0 the function swaps the left and right corners,\r\n        // and it swaps the top and bottom corners if height < 0\r\n        // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\r\n        normalize: function() {\r\n\r\n            var newx = this.x;\r\n            var newy = this.y;\r\n            var newwidth = this.width;\r\n            var newheight = this.height;\r\n            if (this.width < 0) {\r\n                newx = this.x + this.width;\r\n                newwidth = -this.width;\r\n            }\r\n            if (this.height < 0) {\r\n                newy = this.y + this.height;\r\n                newheight = -this.height;\r\n            }\r\n            this.x = newx;\r\n            this.y = newy;\r\n            this.width = newwidth;\r\n            this.height = newheight;\r\n            return this;\r\n        },\r\n\r\n        origin: function() {\r\n\r\n            return Point(this.x, this.y);\r\n        },\r\n\r\n        // @return {point} a point on my boundary nearest to the given point.\r\n        // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\r\n        pointNearestToPoint: function(point) {\r\n\r\n            point = Point(point);\r\n            if (this.containsPoint(point)) {\r\n                var side = this.sideNearestToPoint(point);\r\n                switch (side){\r\n                    case 'right': return Point(this.x + this.width, point.y);\r\n                    case 'left': return Point(this.x, point.y);\r\n                    case 'bottom': return Point(point.x, this.y + this.height);\r\n                    case 'top': return Point(point.x, this.y);\r\n                }\r\n            }\r\n            return point.adhereToRect(this);\r\n        },\r\n\r\n        rightLine: function() {\r\n\r\n            return Line(this.topRight(), this.corner());\r\n        },\r\n\r\n        rightMiddle: function() {\r\n\r\n            return Point(this.x + this.width, this.y + this.height / 2);\r\n        },\r\n\r\n        round: function(precision) {\r\n\r\n            var f = pow(10, precision || 0);\r\n            this.x = round(this.x * f) / f;\r\n            this.y = round(this.y * f) / f;\r\n            this.width = round(this.width * f) / f;\r\n            this.height = round(this.height * f) / f;\r\n            return this;\r\n        },\r\n\r\n        // Scale rectangle with origin.\r\n        scale: function(sx, sy, origin) {\r\n\r\n            origin = this.origin().scale(sx, sy, origin);\r\n            this.x = origin.x;\r\n            this.y = origin.y;\r\n            this.width *= sx;\r\n            this.height *= sy;\r\n            return this;\r\n        },\r\n\r\n        maxRectScaleToFit: function(rect, origin) {\r\n\r\n            rect = g.Rect(rect);\r\n            origin || (origin = rect.center());\r\n\r\n            var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\r\n            var ox = origin.x;\r\n            var oy = origin.y;\r\n\r\n            // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\r\n            // so when the scale is applied the point is still inside the rectangle.\r\n\r\n            sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\r\n\r\n            // Top Left\r\n            var p1 = rect.origin();\r\n            if (p1.x < ox) {\r\n                sx1 = (this.x - ox) / (p1.x - ox);\r\n            }\r\n            if (p1.y < oy) {\r\n                sy1 = (this.y - oy) / (p1.y - oy);\r\n            }\r\n            // Bottom Right\r\n            var p2 = rect.corner();\r\n            if (p2.x > ox) {\r\n                sx2 = (this.x + this.width - ox) / (p2.x - ox);\r\n            }\r\n            if (p2.y > oy) {\r\n                sy2 = (this.y + this.height - oy) / (p2.y - oy);\r\n            }\r\n            // Top Right\r\n            var p3 = rect.topRight();\r\n            if (p3.x > ox) {\r\n                sx3 = (this.x + this.width - ox) / (p3.x - ox);\r\n            }\r\n            if (p3.y < oy) {\r\n                sy3 = (this.y - oy) / (p3.y - oy);\r\n            }\r\n            // Bottom Left\r\n            var p4 = rect.bottomLeft();\r\n            if (p4.x < ox) {\r\n                sx4 = (this.x - ox) / (p4.x - ox);\r\n            }\r\n            if (p4.y > oy) {\r\n                sy4 = (this.y + this.height - oy) / (p4.y - oy);\r\n            }\r\n\r\n            return {\r\n                sx: Math.min(sx1, sx2, sx3, sx4),\r\n                sy: Math.min(sy1, sy2, sy3, sy4)\r\n            };\r\n        },\r\n\r\n        maxRectUniformScaleToFit: function(rect, origin) {\r\n\r\n            var scale = this.maxRectScaleToFit(rect, origin);\r\n            return Math.min(scale.sx, scale.sy);\r\n        },\r\n\r\n        // @return {string} (left|right|top|bottom) side which is nearest to point\r\n        // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\r\n        sideNearestToPoint: function(point) {\r\n\r\n            point = Point(point);\r\n            var distToLeft = point.x - this.x;\r\n            var distToRight = (this.x + this.width) - point.x;\r\n            var distToTop = point.y - this.y;\r\n            var distToBottom = (this.y + this.height) - point.y;\r\n            var closest = distToLeft;\r\n            var side = 'left';\r\n\r\n            if (distToRight < closest) {\r\n                closest = distToRight;\r\n                side = 'right';\r\n            }\r\n            if (distToTop < closest) {\r\n                closest = distToTop;\r\n                side = 'top';\r\n            }\r\n            if (distToBottom < closest) {\r\n                closest = distToBottom;\r\n                side = 'bottom';\r\n            }\r\n            return side;\r\n        },\r\n\r\n        snapToGrid: function(gx, gy) {\r\n\r\n            var origin = this.origin().snapToGrid(gx, gy);\r\n            var corner = this.corner().snapToGrid(gx, gy);\r\n            this.x = origin.x;\r\n            this.y = origin.y;\r\n            this.width = corner.x - origin.x;\r\n            this.height = corner.y - origin.y;\r\n            return this;\r\n        },\r\n\r\n        topLine: function() {\r\n\r\n            return Line(this.origin(), this.topRight());\r\n        },\r\n\r\n        topMiddle: function() {\r\n\r\n            return Point(this.x + this.width / 2, this.y);\r\n        },\r\n\r\n        topRight: function() {\r\n\r\n            return Point(this.x + this.width, this.y);\r\n        },\r\n\r\n        toJSON: function() {\r\n\r\n            return { x: this.x, y: this.y, width: this.width, height: this.height };\r\n        },\r\n\r\n        toString: function() {\r\n\r\n            return this.origin().toString() + ' ' + this.corner().toString();\r\n        },\r\n\r\n        // @return {rect} representing the union of both rectangles.\r\n        union: function(rect) {\r\n\r\n            var myOrigin = this.origin();\r\n            var myCorner = this.corner();\r\n            var rOrigin = rect.origin();\r\n            var rCorner = rect.corner();\r\n\r\n            var originX = Math.min(myOrigin.x, rOrigin.x);\r\n            var originY = Math.min(myOrigin.y, rOrigin.y);\r\n            var cornerX = Math.max(myCorner.x, rCorner.x);\r\n            var cornerY = Math.max(myCorner.y, rCorner.y);\r\n\r\n            return Rect(originX, originY, cornerX - originX, cornerY - originY);\r\n        }\r\n    };\r\n\r\n    var normalizeAngle = g.normalizeAngle = function(angle) {\r\n\r\n        return (angle % 360) + (angle < 0 ? 360 : 0);\r\n    };\r\n\r\n    g.scale = {\r\n\r\n        // Return the `value` from the `domain` interval scaled to the `range` interval.\r\n        linear: function(domain, range, value) {\r\n\r\n            var domainSpan = domain[1] - domain[0];\r\n            var rangeSpan = range[1] - range[0];\r\n            return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\r\n        }\r\n    };\r\n\r\n    var snapToGrid = g.snapToGrid = function(value, gridSize) {\r\n\r\n        return gridSize * Math.round(value / gridSize);\r\n    };\r\n\r\n    var toDeg = g.toDeg = function(rad) {\r\n\r\n        return (180 * rad / PI) % 360;\r\n    };\r\n\r\n    var toRad = g.toRad = function(deg, over360) {\r\n\r\n        over360 = over360 || false;\r\n        deg = over360 ? deg : (deg % 360);\r\n        return deg * PI / 180;\r\n    };\r\n\r\n    // For backwards compatibility:\r\n    g.ellipse = g.Ellipse;\r\n    g.line = g.Line;\r\n    g.point = g.Point;\r\n    g.rect = g.Rect;\r\n\r\n    return g;\r\n\r\n})();\r\n\r\n// Vectorizer.\r\n// -----------\r\n\r\n// A tiny library for making your life easier when dealing with SVG.\r\n// The only Vectorizer dependency is the Geometry library.\r\n\r\n\r\nvar V;\r\nvar Vectorizer;\r\n\r\nV = Vectorizer = (function() {\r\n\r\n    'use strict';\r\n\r\n    var hasSvg = typeof window === 'object' &&\r\n                !!(\r\n                    window.SVGAngle ||\r\n                    document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\r\n                );\r\n\r\n    // SVG support is required.\r\n    if (!hasSvg) {\r\n\r\n        // Return a function that throws an error when it is used.\r\n        return function() {\r\n            throw new Error('SVG is required to use Vectorizer.');\r\n        };\r\n    }\r\n\r\n    // XML namespaces.\r\n    var ns = {\r\n        xmlns: 'http://www.w3.org/2000/svg',\r\n        xml: 'http://www.w3.org/XML/1998/namespace',\r\n        xlink: 'http://www.w3.org/1999/xlink'\r\n    };\r\n\r\n    var SVGversion = '1.1';\r\n\r\n    var V = function(el, attrs, children) {\r\n\r\n        // This allows using V() without the new keyword.\r\n        if (!(this instanceof V)) {\r\n            return V.apply(Object.create(V.prototype), arguments);\r\n        }\r\n\r\n        if (!el) return;\r\n\r\n        if (V.isV(el)) {\r\n            el = el.node;\r\n        }\r\n\r\n        attrs = attrs || {};\r\n\r\n        if (V.isString(el)) {\r\n\r\n            if (el.toLowerCase() === 'svg') {\r\n\r\n                // Create a new SVG canvas.\r\n                el = V.createSvgDocument();\r\n\r\n            } else if (el[0] === '<') {\r\n\r\n                // Create element from an SVG string.\r\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\r\n\r\n                var svgDoc = V.createSvgDocument(el);\r\n\r\n                // Note that `V()` might also return an array should the SVG string passed as\r\n                // the first argument contain more than one root element.\r\n                if (svgDoc.childNodes.length > 1) {\r\n\r\n                    // Map child nodes to `V`s.\r\n                    var arrayOfVels = [];\r\n                    var i, len;\r\n\r\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\r\n\r\n                        var childNode = svgDoc.childNodes[i];\r\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\r\n                    }\r\n\r\n                    return arrayOfVels;\r\n                }\r\n\r\n                el = document.importNode(svgDoc.firstChild, true);\r\n\r\n            } else {\r\n\r\n                el = document.createElementNS(ns.xmlns, el);\r\n            }\r\n\r\n            V.ensureId(el);\r\n        }\r\n\r\n        this.node = el;\r\n\r\n        this.setAttributes(attrs);\r\n\r\n        if (children) {\r\n            this.append(children);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param {SVGGElement} toElem\r\n     * @returns {SVGMatrix}\r\n     */\r\n    V.prototype.getTransformToElement = function(toElem) {\r\n        toElem = V.toNode(toElem);\r\n        return toElem.getScreenCTM().inverse().multiply(this.node.getScreenCTM());\r\n    };\r\n\r\n    /**\r\n     * @param {SVGMatrix} matrix\r\n     * @param {Object=} opt\r\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\r\n     */\r\n    V.prototype.transform = function(matrix, opt) {\r\n\r\n        var node = this.node;\r\n        if (V.isUndefined(matrix)) {\r\n            return V.transformStringToMatrix(this.attr('transform'));\r\n        }\r\n\r\n        if (opt && opt.absolute) {\r\n            return this.attr('transform', V.matrixToTransformString(matrix));\r\n        }\r\n\r\n        var svgTransform = V.createSVGTransform(matrix);\r\n        node.transform.baseVal.appendItem(svgTransform);\r\n        return this;\r\n    };\r\n\r\n    V.prototype.translate = function(tx, ty, opt) {\r\n\r\n        opt = opt || {};\r\n        ty = ty || 0;\r\n\r\n        var transformAttr = this.attr('transform') || '';\r\n        var transform = V.parseTransformString(transformAttr);\r\n        transformAttr = transform.value;\r\n        // Is it a getter?\r\n        if (V.isUndefined(tx)) {\r\n            return transform.translate;\r\n        }\r\n\r\n        transformAttr = transformAttr.replace(/translate\\([^\\)]*\\)/g, '').trim();\r\n\r\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\r\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\r\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\r\n\r\n        // Note that `translate()` is always the first transformation. This is\r\n        // usually the desired case.\r\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\r\n        return this;\r\n    };\r\n\r\n    V.prototype.rotate = function(angle, cx, cy, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var transformAttr = this.attr('transform') || '';\r\n        var transform = V.parseTransformString(transformAttr);\r\n        transformAttr = transform.value;\r\n\r\n        // Is it a getter?\r\n        if (V.isUndefined(angle)) {\r\n            return transform.rotate;\r\n        }\r\n\r\n        transformAttr = transformAttr.replace(/rotate\\([^\\)]*\\)/g, '').trim();\r\n\r\n        angle %= 360;\r\n\r\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\r\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\r\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\r\n\r\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\r\n        return this;\r\n    };\r\n\r\n    // Note that `scale` as the only transformation does not combine with previous values.\r\n    V.prototype.scale = function(sx, sy) {\r\n\r\n        sy = V.isUndefined(sy) ? sx : sy;\r\n\r\n        var transformAttr = this.attr('transform') || '';\r\n        var transform = V.parseTransformString(transformAttr);\r\n        transformAttr = transform.value;\r\n\r\n        // Is it a getter?\r\n        if (V.isUndefined(sx)) {\r\n            return transform.scale;\r\n        }\r\n\r\n        transformAttr = transformAttr.replace(/scale\\([^\\)]*\\)/g, '').trim();\r\n\r\n        var newScale = 'scale(' + sx + ',' + sy + ')';\r\n\r\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\r\n        return this;\r\n    };\r\n\r\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\r\n    // i.e. after transformations are applied.\r\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\r\n    V.prototype.bbox = function(withoutTransformations, target) {\r\n\r\n        // If the element is not in the live DOM, it does not have a bounding box defined and\r\n        // so fall back to 'zero' dimension element.\r\n        if (!this.node.ownerSVGElement) return { x: 0, y: 0, width: 0, height: 0 };\r\n\r\n        var box;\r\n        try {\r\n\r\n            box = this.node.getBBox();\r\n            // We are creating a new object as the standard says that you can't\r\n            // modify the attributes of a bbox.\r\n            box = { x: box.x, y: box.y, width: box.width, height: box.height };\r\n\r\n        } catch (e) {\r\n\r\n            // Fallback for IE.\r\n            box = {\r\n                x: this.node.clientLeft,\r\n                y: this.node.clientTop,\r\n                width: this.node.clientWidth,\r\n                height: this.node.clientHeight\r\n            };\r\n        }\r\n\r\n        if (withoutTransformations) {\r\n\r\n            return box;\r\n        }\r\n\r\n        var matrix = this.getTransformToElement(target || this.node.ownerSVGElement);\r\n\r\n        return V.transformRect(box, matrix);\r\n    };\r\n\r\n    V.prototype.text = function(content, opt) {\r\n\r\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\r\n        // IE would otherwise collapse all spaces into one.\r\n        content = V.sanitizeText(content);\r\n        opt = opt || {};\r\n        var lines = content.split('\\n');\r\n        var tspan;\r\n\r\n        // `alignment-baseline` does not work in Firefox.\r\n        // Setting `dominant-baseline` on the `<text>` element doesn't work in IE9.\r\n        // In order to have the 0,0 coordinate of the `<text>` element (or the first `<tspan>`)\r\n        // in the top left corner we translate the `<text>` element by `0.8em`.\r\n        // See `http://www.w3.org/Graphics/SVG/WG/wiki/How_to_determine_dominant_baseline`.\r\n        // See also `http://apike.ca/prog_svg_text_style.html`.\r\n        var y = this.attr('y');\r\n        if (!y) {\r\n            this.attr('y', '0.8em');\r\n        }\r\n\r\n        // An empty text gets rendered into the DOM in webkit-based browsers.\r\n        // In order to unify this behaviour across all browsers\r\n        // we rather hide the text element when it's empty.\r\n        if (content) {\r\n            this.removeAttr('display');\r\n        } else {\r\n            this.attr('display', 'none');\r\n        }\r\n\r\n        // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\r\n        this.attr('xml:space', 'preserve');\r\n\r\n        // Easy way to erase all `<tspan>` children;\r\n        this.node.textContent = '';\r\n\r\n        var textNode = this.node;\r\n\r\n        if (opt.textPath) {\r\n\r\n            // Wrap the text in the SVG <textPath> element that points\r\n            // to a path defined by `opt.textPath` inside the internal `<defs>` element.\r\n            var defs = this.find('defs');\r\n            if (defs.length === 0) {\r\n                defs = V('defs');\r\n                this.append(defs);\r\n            }\r\n\r\n            // If `opt.textPath` is a plain string, consider it to be directly the\r\n            // SVG path data for the text to go along (this is a shortcut).\r\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\r\n            var d = Object(opt.textPath) === opt.textPath ? opt.textPath.d : opt.textPath;\r\n            if (d) {\r\n                var path = V('path', { d: d });\r\n                defs.append(path);\r\n            }\r\n\r\n            var textPath = V('textPath');\r\n            // Set attributes on the `<textPath>`. The most important one\r\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\r\n            // Note that we also allow the following construct:\r\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\r\n            // In other words, one can completely skip the auto-creation of the path\r\n            // and use any other arbitrary path that is in the document.\r\n            if (!opt.textPath['xlink:href'] && path) {\r\n                textPath.attr('xlink:href', '#' + path.node.id);\r\n            }\r\n\r\n            if (Object(opt.textPath) === opt.textPath) {\r\n                textPath.attr(opt.textPath);\r\n            }\r\n            this.append(textPath);\r\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\r\n            textNode = textPath.node;\r\n        }\r\n\r\n        var offset = 0;\r\n        var x = this.attr('x') || 0;\r\n\r\n        // Shift all the <tspan> but first by one line (`1em`)\r\n        var lineHeight = opt.lineHeight || '1em';\r\n        if (opt.lineHeight === 'auto') {\r\n            lineHeight = '1.5em';\r\n        }\r\n\r\n        for (var i = 0; i < lines.length; i++) {\r\n\r\n            var line = lines[i];\r\n\r\n            var vLine = V('tspan', { 'class': 'v-line',  dy: (i == 0 ? '0em' : lineHeight), x: x });\r\n\r\n            if (line) {\r\n\r\n                if (opt.annotations) {\r\n\r\n                    // Get the line height based on the biggest font size in the annotations for this line.\r\n                    var maxFontSize = 0;\r\n\r\n                    // Find the *compacted* annotations for this line.\r\n                    var lineAnnotations = V.annotateString(lines[i], V.isArray(opt.annotations) ? opt.annotations : [opt.annotations], { offset: -offset, includeAnnotationIndices: opt.includeAnnotationIndices });\r\n                    for (var j = 0; j < lineAnnotations.length; j++) {\r\n\r\n                        var annotation = lineAnnotations[j];\r\n                        if (V.isObject(annotation)) {\r\n\r\n                            var fontSize = parseInt(annotation.attrs['font-size'], 10);\r\n                            if (fontSize && fontSize > maxFontSize) {\r\n                                maxFontSize = fontSize;\r\n                            }\r\n\r\n                            tspan = V('tspan', annotation.attrs);\r\n                            if (opt.includeAnnotationIndices) {\r\n                                // If `opt.includeAnnotationIndices` is `true`,\r\n                                // set the list of indices of all the applied annotations\r\n                                // in the `annotations` attribute. This list is a comma\r\n                                // separated list of indices.\r\n                                tspan.attr('annotations', annotation.annotations);\r\n                            }\r\n                            if (annotation.attrs['class']) {\r\n                                tspan.addClass(annotation.attrs['class']);\r\n                            }\r\n                            tspan.node.textContent = annotation.t;\r\n\r\n                        } else {\r\n\r\n                            tspan = document.createTextNode(annotation || ' ');\r\n\r\n                        }\r\n                        vLine.append(tspan);\r\n                    }\r\n\r\n                    if (opt.lineHeight === 'auto' && maxFontSize && i !== 0) {\r\n\r\n                        vLine.attr('dy', (maxFontSize * 1.2) + 'px');\r\n                    }\r\n\r\n                } else {\r\n\r\n                    vLine.node.textContent = line;\r\n                }\r\n\r\n            } else {\r\n\r\n                // Make sure the textContent is never empty. If it is, add a dummy\r\n                // character and make it invisible, making the following lines correctly\r\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\r\n                vLine.addClass('v-empty-line');\r\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\r\n                // is not applied in Firefox\r\n                vLine.node.style.fillOpacity = 0;\r\n                vLine.node.style.strokeOpacity = 0;\r\n                vLine.node.textContent = '-';\r\n            }\r\n\r\n            V(textNode).append(vLine);\r\n\r\n            offset += line.length + 1;      // + 1 = newline character.\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @public\r\n     * @param {string} name\r\n     * @returns {Vectorizer}\r\n     */\r\n    V.prototype.removeAttr = function(name) {\r\n\r\n        var qualifiedName = V.qualifyAttr(name);\r\n        var el = this.node;\r\n\r\n        if (qualifiedName.ns) {\r\n            if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) {\r\n                el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\r\n            }\r\n        } else if (el.hasAttribute(name)) {\r\n            el.removeAttribute(name);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    V.prototype.attr = function(name, value) {\r\n\r\n        if (V.isUndefined(name)) {\r\n\r\n            // Return all attributes.\r\n            var attributes = this.node.attributes;\r\n            var attrs = {};\r\n\r\n            for (var i = 0; i < attributes.length; i++) {\r\n                attrs[attributes[i].name] = attributes[i].value;\r\n            }\r\n\r\n            return attrs;\r\n        }\r\n\r\n        if (V.isString(name) && V.isUndefined(value)) {\r\n            return this.node.getAttribute(name);\r\n        }\r\n\r\n        if (typeof name === 'object') {\r\n\r\n            for (var attrName in name) {\r\n                if (name.hasOwnProperty(attrName)) {\r\n                    this.setAttribute(attrName, name[attrName]);\r\n                }\r\n            }\r\n\r\n        } else {\r\n\r\n            this.setAttribute(name, value);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.remove = function() {\r\n\r\n        if (this.node.parentNode) {\r\n            this.node.parentNode.removeChild(this.node);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.empty = function() {\r\n\r\n        while (this.node.firstChild) {\r\n            this.node.removeChild(this.node.firstChild);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.setAttributes = function(attrs) {\r\n\r\n        for (var key in attrs) {\r\n            if (attrs.hasOwnProperty(key)) {\r\n                this.setAttribute(key, attrs[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.append = function(els) {\r\n\r\n        if (!V.isArray(els)) {\r\n            els = [els];\r\n        }\r\n\r\n        for (var i = 0, len = els.length; i < len; i++) {\r\n            this.node.appendChild(V.toNode(els[i]));\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.prepend = function(els) {\r\n\r\n        var child = this.node.firstChild;\r\n        return child ? V(child).before(els) : this.append(els);\r\n    };\r\n\r\n    V.prototype.before = function(els) {\r\n\r\n        var node = this.node;\r\n        var parent = node.parentNode;\r\n\r\n        if (parent) {\r\n\r\n            if (!V.isArray(els)) {\r\n                els = [els];\r\n            }\r\n\r\n            for (var i = 0, len = els.length; i < len; i++) {\r\n                parent.insertBefore(V.toNode(els[i]), node);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.appendTo = function(node) {\r\n        V.toNode(node).appendChild(this.node);\r\n        return this;\r\n    },\r\n\r\n    V.prototype.svg = function() {\r\n\r\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\r\n    };\r\n\r\n    V.prototype.defs = function() {\r\n\r\n        var defs = this.svg().node.getElementsByTagName('defs');\r\n\r\n        return (defs && defs.length) ? V(defs[0]) : undefined;\r\n    };\r\n\r\n    V.prototype.clone = function() {\r\n\r\n        var clone = V(this.node.cloneNode(true/* deep */));\r\n        // Note that clone inherits also ID. Therefore, we need to change it here.\r\n        clone.node.id = V.uniqueId();\r\n        return clone;\r\n    };\r\n\r\n    V.prototype.findOne = function(selector) {\r\n\r\n        var found = this.node.querySelector(selector);\r\n        return found ? V(found) : undefined;\r\n    };\r\n\r\n    V.prototype.find = function(selector) {\r\n\r\n        var vels = [];\r\n        var nodes = this.node.querySelectorAll(selector);\r\n\r\n        if (nodes) {\r\n\r\n            // Map DOM elements to `V`s.\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                vels.push(V(nodes[i]));\r\n            }\r\n        }\r\n\r\n        return vels;\r\n    };\r\n\r\n    // Find an index of an element inside its container.\r\n    V.prototype.index = function() {\r\n\r\n        var index = 0;\r\n        var node = this.node.previousSibling;\r\n\r\n        while (node) {\r\n            // nodeType 1 for ELEMENT_NODE\r\n            if (node.nodeType === 1) index++;\r\n            node = node.previousSibling;\r\n        }\r\n\r\n        return index;\r\n    };\r\n\r\n    V.prototype.findParentByClass = function(className, terminator) {\r\n\r\n        var ownerSVGElement = this.node.ownerSVGElement;\r\n        var node = this.node.parentNode;\r\n\r\n        while (node && node !== terminator && node !== ownerSVGElement) {\r\n\r\n            var vel = V(node);\r\n            if (vel.hasClass(className)) {\r\n                return vel;\r\n            }\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    // https://jsperf.com/get-common-parent\r\n    V.prototype.contains = function(el) {\r\n\r\n        var a = this.node;\r\n        var b = V.toNode(el);\r\n        var bup = b && b.parentNode;\r\n\r\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\r\n    };\r\n\r\n    // Convert global point into the coordinate space of this element.\r\n    V.prototype.toLocalPoint = function(x, y) {\r\n\r\n        var svg = this.svg().node;\r\n\r\n        var p = svg.createSVGPoint();\r\n        p.x = x;\r\n        p.y = y;\r\n\r\n        try {\r\n\r\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\r\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\r\n\r\n        } catch (e) {\r\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\r\n            // We have to make do with the original coordianates.\r\n            return p;\r\n        }\r\n\r\n        return globalPoint.matrixTransform(globalToLocalMatrix);\r\n    };\r\n\r\n    V.prototype.translateCenterToPoint = function(p) {\r\n\r\n        var bbox = this.bbox();\r\n        var center = g.rect(bbox).center();\r\n\r\n        this.translate(p.x - center.x, p.y - center.y);\r\n    };\r\n\r\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\r\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\r\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\r\n    // being auto-oriented (properly rotated) towards the `reference` point.\r\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\r\n    V.prototype.translateAndAutoOrient = function(position, reference, target) {\r\n\r\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\r\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\r\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\r\n        // element is scaled by the factor 2, not 8.\r\n\r\n        var s = this.scale();\r\n        this.attr('transform', '');\r\n        this.scale(s.sx, s.sy);\r\n\r\n        var svg = this.svg().node;\r\n        var bbox = this.bbox(false, target);\r\n\r\n        // 1. Translate to origin.\r\n        var translateToOrigin = svg.createSVGTransform();\r\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\r\n\r\n        // 2. Rotate around origin.\r\n        var rotateAroundOrigin = svg.createSVGTransform();\r\n        var angle = g.point(position).changeInAngle(position.x - reference.x, position.y - reference.y, reference);\r\n        rotateAroundOrigin.setRotate(angle, 0, 0);\r\n\r\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\r\n        var translateFinal = svg.createSVGTransform();\r\n        var finalPosition = g.point(position).move(reference, bbox.width / 2);\r\n        translateFinal.setTranslate(position.x + (position.x - finalPosition.x), position.y + (position.y - finalPosition.y));\r\n\r\n        // 4. Apply transformations.\r\n        var ctm = this.getTransformToElement(target);\r\n        var transform = svg.createSVGTransform();\r\n        transform.setMatrix(\r\n            translateFinal.matrix.multiply(\r\n                rotateAroundOrigin.matrix.multiply(\r\n                    translateToOrigin.matrix.multiply(\r\n                        ctm)))\r\n        );\r\n\r\n        // Instead of directly setting the `matrix()` transform on the element, first, decompose\r\n        // the matrix into separate transforms. This allows us to use normal Vectorizer methods\r\n        // as they don't work on matrices. An example of this is to retrieve a scale of an element.\r\n        // this.node.transform.baseVal.initialize(transform);\r\n\r\n        var decomposition = V.decomposeMatrix(transform.matrix);\r\n\r\n        this.translate(decomposition.translateX, decomposition.translateY);\r\n        this.rotate(decomposition.rotation);\r\n        // Note that scale has been already applied, hence the following line stays commented. (it's here just for reference).\r\n        //this.scale(decomposition.scaleX, decomposition.scaleY);\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.animateAlongPath = function(attrs, path) {\r\n\r\n        path = V.toNode(path);\r\n\r\n        var id = V.ensureId(path);\r\n        var animateMotion = V('animateMotion', attrs);\r\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\r\n\r\n        animateMotion.append(mpath);\r\n\r\n        this.append(animateMotion);\r\n        try {\r\n            animateMotion.node.beginElement();\r\n        } catch (e) {\r\n            // Fallback for IE 9.\r\n            // Run the animation programatically if FakeSmile (`http://leunen.me/fakesmile/`) present\r\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\r\n\r\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\r\n                var animation = animateMotion.node;\r\n                animation.animators = [];\r\n\r\n                var animationID = animation.getAttribute('id');\r\n                if (animationID) id2anim[animationID] = animation;\r\n\r\n                var targets = getTargets(animation);\r\n                for (var i = 0, len = targets.length; i < len; i++) {\r\n                    var target = targets[i];\r\n                    var animator = new Animator(animation, target, i);\r\n                    animators.push(animator);\r\n                    animation.animators[i] = animator;\r\n                    animator.register();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    V.prototype.hasClass = function(className) {\r\n\r\n        return new RegExp('(\\\\s|^)' + className + '(\\\\s|$)').test(this.node.getAttribute('class'));\r\n    };\r\n\r\n    V.prototype.addClass = function(className) {\r\n\r\n        if (!this.hasClass(className)) {\r\n            var prevClasses = this.node.getAttribute('class') || '';\r\n            this.node.setAttribute('class', (prevClasses + ' ' + className).trim());\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.removeClass = function(className) {\r\n\r\n        if (this.hasClass(className)) {\r\n            var newClasses = this.node.getAttribute('class').replace(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)', 'g'), '$2');\r\n            this.node.setAttribute('class', newClasses);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    V.prototype.toggleClass = function(className, toAdd) {\r\n\r\n        var toRemove = V.isUndefined(toAdd) ? this.hasClass(className) : !toAdd;\r\n\r\n        if (toRemove) {\r\n            this.removeClass(className);\r\n        } else {\r\n            this.addClass(className);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // Interpolate path by discrete points. The precision of the sampling\r\n    // is controlled by `interval`. In other words, `sample()` will generate\r\n    // a point on the path starting at the beginning of the path going to the end\r\n    // every `interval` pixels.\r\n    // The sampler can be very useful for e.g. finding intersection between two\r\n    // paths (finding the two closest points from two samples).\r\n    V.prototype.sample = function(interval) {\r\n\r\n        interval = interval || 1;\r\n        var node = this.node;\r\n        var length = node.getTotalLength();\r\n        var samples = [];\r\n        var distance = 0;\r\n        var sample;\r\n        while (distance < length) {\r\n            sample = node.getPointAtLength(distance);\r\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\r\n            distance += interval;\r\n        }\r\n        return samples;\r\n    };\r\n\r\n    V.prototype.convertToPath = function() {\r\n\r\n        var path = V('path');\r\n        path.attr(this.attr());\r\n        var d = this.convertToPathData();\r\n        if (d) {\r\n            path.attr('d', d);\r\n        }\r\n        return path;\r\n    };\r\n\r\n    V.prototype.convertToPathData = function() {\r\n\r\n        var tagName = this.node.tagName.toUpperCase();\r\n\r\n        switch (tagName) {\r\n            case 'PATH':\r\n                return this.attr('d');\r\n            case 'LINE':\r\n                return V.convertLineToPathData(this.node);\r\n            case 'POLYGON':\r\n                return V.convertPolygonToPathData(this.node);\r\n            case 'POLYLINE':\r\n                return V.convertPolylineToPathData(this.node);\r\n            case 'ELLIPSE':\r\n                return V.convertEllipseToPathData(this.node);\r\n            case 'CIRCLE':\r\n                return V.convertCircleToPathData(this.node);\r\n            case 'RECT':\r\n                return V.convertRectToPathData(this.node);\r\n        }\r\n\r\n        throw new Error(tagName + ' cannot be converted to PATH.');\r\n    };\r\n\r\n    // Find the intersection of a line starting in the center\r\n    // of the SVG `node` ending in the point `ref`.\r\n    // `target` is an SVG element to which `node`s transformations are relative to.\r\n    // In JointJS, `target` is the `paper.viewport` SVG group element.\r\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\r\n    // Returns a point in the `target` coordinte system (the same system as `ref` is in) if\r\n    // an intersection is found. Returns `undefined` otherwise.\r\n    V.prototype.findIntersection = function(ref, target) {\r\n\r\n        var svg = this.svg().node;\r\n        target = target || svg;\r\n        var bbox = g.rect(this.bbox(false, target));\r\n        var center = bbox.center();\r\n\r\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\r\n\r\n        var spot;\r\n        var tagName = this.node.localName.toUpperCase();\r\n\r\n        // Little speed up optimalization for `<rect>` element. We do not do conversion\r\n        // to path element and sampling but directly calculate the intersection through\r\n        // a transformed geometrical rectangle.\r\n        if (tagName === 'RECT') {\r\n\r\n            var gRect = g.rect(\r\n                parseFloat(this.attr('x') || 0),\r\n                parseFloat(this.attr('y') || 0),\r\n                parseFloat(this.attr('width')),\r\n                parseFloat(this.attr('height'))\r\n            );\r\n            // Get the rect transformation matrix with regards to the SVG document.\r\n            var rectMatrix = this.getTransformToElement(target);\r\n            // Decompose the matrix to find the rotation angle.\r\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\r\n            // Now we want to rotate the rectangle back so that we\r\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\r\n            var resetRotation = svg.createSVGTransform();\r\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\r\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\r\n            spot = g.rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\r\n\r\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\r\n\r\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\r\n            var samples = pathNode.sample();\r\n            var minDistance = Infinity;\r\n            var closestSamples = [];\r\n\r\n            var i, sample, gp, centerDistance, refDistance, distance;\r\n\r\n            for (i = 0; i < samples.length; i++) {\r\n\r\n                sample = samples[i];\r\n                // Convert the sample point in the local coordinate system to the global coordinate system.\r\n                gp = V.createSVGPoint(sample.x, sample.y);\r\n                gp = gp.matrixTransform(this.getTransformToElement(target));\r\n                sample = g.point(gp);\r\n                centerDistance = sample.distance(center);\r\n                // Penalize a higher distance to the reference point by 10%.\r\n                // This gives better results. This is due to\r\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\r\n                refDistance = sample.distance(ref) * 1.1;\r\n                distance = centerDistance + refDistance;\r\n\r\n                if (distance < minDistance) {\r\n                    minDistance = distance;\r\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\r\n                } else if (distance < minDistance + 1) {\r\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\r\n                }\r\n            }\r\n\r\n            closestSamples.sort(function(a, b) {\r\n                return a.refDistance - b.refDistance;\r\n            });\r\n\r\n            if (closestSamples[0]) {\r\n                spot = closestSamples[0].sample;\r\n            }\r\n        }\r\n\r\n        return spot;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * @param {string} name\r\n     * @param {string} value\r\n     * @returns {Vectorizer}\r\n     */\r\n    V.prototype.setAttribute = function(name, value) {\r\n\r\n        var el = this.node;\r\n\r\n        if (value === null) {\r\n            this.removeAttr(name);\r\n            return this;\r\n        }\r\n\r\n        var qualifiedName = V.qualifyAttr(name);\r\n\r\n        if (qualifiedName.ns) {\r\n            // Attribute names can be namespaced. E.g. `image` elements\r\n            // have a `xlink:href` attribute to set the source of the image.\r\n            el.setAttributeNS(qualifiedName.ns, name, value);\r\n        } else if (name === 'id') {\r\n            el.id = value;\r\n        } else {\r\n            el.setAttribute(name, value);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // Create an SVG document element.\r\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\r\n    V.createSvgDocument = function(content) {\r\n\r\n        var svg = '<svg xmlns=\"' + ns.xmlns + '\" xmlns:xlink=\"' + ns.xlink + '\" version=\"' + SVGversion + '\">' + (content || '') + '</svg>';\r\n        var xml = V.parseXML(svg, { async: false });\r\n        return xml.documentElement;\r\n    };\r\n\r\n    V.idCounter = 0;\r\n\r\n    // A function returning a unique identifier for this client session with every call.\r\n    V.uniqueId = function() {\r\n\r\n        return 'v-' + (++V.idCounter);\r\n    };\r\n\r\n    V.ensureId = function(node) {\r\n\r\n        return node.id || (node.id = V.uniqueId());\r\n    };\r\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\r\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\r\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\r\n    // when you want to compare the actual DOM text content without having to add the unicode character in\r\n    // the place of all spaces.\r\n    V.sanitizeText = function(text) {\r\n\r\n        return (text || '').replace(/ /g, '\\u00A0');\r\n    };\r\n\r\n    V.isUndefined = function(value) {\r\n\r\n        return typeof value === 'undefined';\r\n    };\r\n\r\n    V.isString = function(value) {\r\n\r\n        return typeof value === 'string';\r\n    };\r\n\r\n    V.isObject = function(value) {\r\n\r\n        return value && (typeof value === 'object');\r\n    };\r\n\r\n    V.isArray = Array.isArray;\r\n\r\n    V.parseXML = function(data, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var xml;\r\n\r\n        try {\r\n            var parser = new DOMParser();\r\n\r\n            if (!V.isUndefined(opt.async)) {\r\n                parser.async = opt.async;\r\n            }\r\n\r\n            xml = parser.parseFromString(data, 'text/xml');\r\n        } catch (error) {\r\n            xml = undefined;\r\n        }\r\n\r\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\r\n            throw new Error('Invalid XML: ' + data);\r\n        }\r\n\r\n        return xml;\r\n    };\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\r\n     */\r\n    V.qualifyAttr = function(name) {\r\n\r\n        if (name.indexOf(':') !== -1) {\r\n            var combinedKey = name.split(':');\r\n            return {\r\n                ns: ns[combinedKey[0]],\r\n                local: combinedKey[1]\r\n            };\r\n        }\r\n\r\n        return {\r\n            ns: null,\r\n            local: name\r\n        };\r\n    };\r\n\r\n    V.transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\r\n    V.transformSeparatorRegex = /[ ,]+/;\r\n    V.transformationListRegex = /^(\\w+)\\((.*)\\)/;\r\n\r\n    V.transformStringToMatrix = function(transform) {\r\n\r\n        var transformationMatrix = V.createSVGMatrix();\r\n        var matches = transform && transform.match(V.transformRegex);\r\n        if (!matches) {\r\n            return transformationMatrix;\r\n        }\r\n\r\n        for (var i = 0, n = matches.length; i < n; i++) {\r\n            var transformationString = matches[i];\r\n\r\n            var transformationMatch = transformationString.match(V.transformationListRegex);\r\n            if (transformationMatch) {\r\n                var sx, sy, tx, ty, angle;\r\n                var ctm = V.createSVGMatrix();\r\n                var args = transformationMatch[2].split(V.transformSeparatorRegex);\r\n                switch (transformationMatch[1].toLowerCase()) {\r\n                    case 'scale':\r\n                        sx = parseFloat(args[0]);\r\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\r\n                        ctm = ctm.scaleNonUniform(sx, sy);\r\n                        break;\r\n                    case 'translate':\r\n                        tx = parseFloat(args[0]);\r\n                        ty = parseFloat(args[1]);\r\n                        ctm = ctm.translate(tx, ty);\r\n                        break;\r\n                    case 'rotate':\r\n                        angle = parseFloat(args[0]);\r\n                        tx = parseFloat(args[1]) || 0;\r\n                        ty = parseFloat(args[2]) || 0;\r\n                        if (tx !== 0 || ty !== 0) {\r\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\r\n                        } else {\r\n                            ctm = ctm.rotate(angle);\r\n                        }\r\n                        break;\r\n                    case 'skewx':\r\n                        angle = parseFloat(args[0]);\r\n                        ctm = ctm.skewX(angle);\r\n                        break;\r\n                    case 'skewy':\r\n                        angle = parseFloat(args[0]);\r\n                        ctm = ctm.skewY(angle);\r\n                        break;\r\n                    case 'matrix':\r\n                        ctm.a = parseFloat(args[0]);\r\n                        ctm.b = parseFloat(args[1]);\r\n                        ctm.c = parseFloat(args[2]);\r\n                        ctm.d = parseFloat(args[3]);\r\n                        ctm.e = parseFloat(args[4]);\r\n                        ctm.f = parseFloat(args[5]);\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n\r\n                transformationMatrix = transformationMatrix.multiply(ctm);\r\n            }\r\n\r\n        }\r\n        return transformationMatrix;\r\n    };\r\n\r\n    V.matrixToTransformString = function(matrix) {\r\n        matrix || (matrix = true);\r\n\r\n        return 'matrix(' +\r\n            (matrix.a || 1) + ',' +\r\n            (matrix.b || 0) + ',' +\r\n            (matrix.c || 0) + ',' +\r\n            (matrix.d || 1) + ',' +\r\n            (matrix.e || 0) + ',' +\r\n            (matrix.f || 0) +\r\n            ')';\r\n    };\r\n\r\n    V.parseTransformString = function(transform) {\r\n\r\n        var translate, rotate, scale;\r\n\r\n        if (transform) {\r\n\r\n            var separator = V.transformSeparatorRegex;\r\n\r\n            // Allow reading transform string with a single matrix\r\n            if (transform.trim().indexOf('matrix') >= 0) {\r\n\r\n                var matrix = V.transformStringToMatrix(transform);\r\n                var decomposedMatrix = V.decomposeMatrix(matrix);\r\n\r\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\r\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\r\n                rotate = [decomposedMatrix.rotation];\r\n\r\n                var transformations = [];\r\n                if (translate[0] !== 0 ||  translate[0] !== 0) {\r\n                    transformations.push('translate(' + translate + ')');\r\n                }\r\n                if (scale[0] !== 1 ||  scale[1] !== 1) {\r\n                    transformations.push('scale(' + scale + ')');\r\n                }\r\n                if (rotate[0] !== 0) {\r\n                    transformations.push('rotate(' + rotate + ')');\r\n                }\r\n                transform = transformations.join(' ');\r\n\r\n            } else {\r\n\r\n                var translateMatch = transform.match(/translate\\((.*)\\)/);\r\n                if (translateMatch) {\r\n                    translate = translateMatch[1].split(separator);\r\n                }\r\n                var rotateMatch = transform.match(/rotate\\((.*)\\)/);\r\n                if (rotateMatch) {\r\n                    rotate = rotateMatch[1].split(separator);\r\n                }\r\n                var scaleMatch = transform.match(/scale\\((.*)\\)/);\r\n                if (scaleMatch) {\r\n                    scale = scaleMatch[1].split(separator);\r\n                }\r\n            }\r\n        }\r\n\r\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\r\n\r\n        return {\r\n            value: transform,\r\n            translate: {\r\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\r\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\r\n            },\r\n            rotate: {\r\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\r\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\r\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\r\n            },\r\n            scale: {\r\n                sx: sx,\r\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\r\n            }\r\n        };\r\n    };\r\n\r\n    V.deltaTransformPoint = function(matrix, point) {\r\n\r\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\r\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\r\n        return { x: dx, y: dy };\r\n    };\r\n\r\n    V.decomposeMatrix = function(matrix) {\r\n\r\n        // @see https://gist.github.com/2052247\r\n\r\n        // calculate delta transform point\r\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\r\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\r\n\r\n        // calculate skew\r\n        var skewX = ((180 / Math.PI) * Math.atan2(px.y, px.x) - 90);\r\n        var skewY = ((180 / Math.PI) * Math.atan2(py.y, py.x));\r\n\r\n        return {\r\n\r\n            translateX: matrix.e,\r\n            translateY: matrix.f,\r\n            scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\r\n            scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\r\n            skewX: skewX,\r\n            skewY: skewY,\r\n            rotation: skewX // rotation is the same as skew x\r\n        };\r\n    };\r\n\r\n    // Return the `scale` transformation from the following equation:\r\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\r\n    V.matrixToScale = function(matrix) {\r\n\r\n        var a,b,c,d;\r\n        if (matrix) {\r\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\r\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\r\n            b = matrix.b;\r\n            c = matrix.c;\r\n        } else {\r\n            a = d = 1;\r\n        }\r\n        return {\r\n            sx: b ? Math.sqrt(a * a + b * b) : a,\r\n            sy: c ? Math.sqrt(c * c + d * d) : d\r\n        };\r\n    },\r\n\r\n    // Return the `rotate` transformation from the following equation:\r\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\r\n    V.matrixToRotate = function(matrix) {\r\n\r\n        var p = { x: 0, y: 1 };\r\n        if (matrix) {\r\n            p =  V.deltaTransformPoint(matrix, p);\r\n        }\r\n\r\n        return {\r\n            angle: g.normalizeAngle(g.toDeg(Math.atan2(p.y, p.x)) - 90)\r\n        };\r\n    },\r\n\r\n    // Return the `translate` transformation from the following equation:\r\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\r\n    V.matrixToTranslate = function(matrix) {\r\n\r\n        return {\r\n            tx: (matrix && matrix.e) || 0,\r\n            ty: (matrix && matrix.f) || 0\r\n        };\r\n    },\r\n\r\n    V.isV = function(object) {\r\n\r\n        return object instanceof V;\r\n    };\r\n\r\n    // For backwards compatibility:\r\n    V.isVElement = V.isV;\r\n\r\n    var svgDocument = V('svg').node;\r\n\r\n    V.createSVGMatrix = function(matrix) {\r\n\r\n        var svgMatrix = svgDocument.createSVGMatrix();\r\n        for (var component in matrix) {\r\n            svgMatrix[component] = matrix[component];\r\n        }\r\n\r\n        return svgMatrix;\r\n    };\r\n\r\n    V.createSVGTransform = function(matrix) {\r\n\r\n        if (!V.isUndefined(matrix)) {\r\n\r\n            if (!(matrix instanceof SVGMatrix)) {\r\n                matrix = V.createSVGMatrix(matrix);\r\n            }\r\n\r\n            return svgDocument.createSVGTransformFromMatrix(matrix);\r\n        }\r\n\r\n        return svgDocument.createSVGTransform();\r\n    };\r\n\r\n    V.createSVGPoint = function(x, y) {\r\n\r\n        var p = svgDocument.createSVGPoint();\r\n        p.x = x;\r\n        p.y = y;\r\n        return p;\r\n    };\r\n\r\n    V.transformRect = function(r, matrix) {\r\n\r\n        var p = svgDocument.createSVGPoint();\r\n\r\n        p.x = r.x;\r\n        p.y = r.y;\r\n        var corner1 = p.matrixTransform(matrix);\r\n\r\n        p.x = r.x + r.width;\r\n        p.y = r.y;\r\n        var corner2 = p.matrixTransform(matrix);\r\n\r\n        p.x = r.x + r.width;\r\n        p.y = r.y + r.height;\r\n        var corner3 = p.matrixTransform(matrix);\r\n\r\n        p.x = r.x;\r\n        p.y = r.y + r.height;\r\n        var corner4 = p.matrixTransform(matrix);\r\n\r\n        var minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);\r\n        var maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);\r\n        var minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);\r\n        var maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);\r\n\r\n        return g.Rect(minX, minY, maxX - minX, maxY - minY);\r\n    };\r\n\r\n    V.transformPoint = function(p, matrix) {\r\n\r\n        return g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\r\n    };\r\n\r\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\r\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\r\n    V.styleToObject = function(styleString) {\r\n        var ret = {};\r\n        var styles = styleString.split(';');\r\n        for (var i = 0; i < styles.length; i++) {\r\n            var style = styles[i];\r\n            var pair = style.split('=');\r\n            ret[pair[0].trim()] = pair[1].trim();\r\n        }\r\n        return ret;\r\n    };\r\n\r\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\r\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\r\n\r\n        var svgArcMax = 2 * Math.PI - 1e-6;\r\n        var r0 = innerRadius;\r\n        var r1 = outerRadius;\r\n        var a0 = startAngle;\r\n        var a1 = endAngle;\r\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\r\n        var df = da < Math.PI ? '0' : '1';\r\n        var c0 = Math.cos(a0);\r\n        var s0 = Math.sin(a0);\r\n        var c1 = Math.cos(a1);\r\n        var s1 = Math.sin(a1);\r\n\r\n        return (da >= svgArcMax)\r\n            ? (r0\r\n               ? 'M0,' + r1\r\n               + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\r\n               + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\r\n               + 'M0,' + r0\r\n               + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\r\n               + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\r\n               + 'Z'\r\n               : 'M0,' + r1\r\n               + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\r\n               + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\r\n               + 'Z')\r\n            : (r0\r\n               ? 'M' + r1 * c0 + ',' + r1 * s0\r\n               + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\r\n               + 'L' + r0 * c1 + ',' + r0 * s1\r\n               + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\r\n               + 'Z'\r\n               : 'M' + r1 * c0 + ',' + r1 * s0\r\n               + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\r\n               + 'L0,0'\r\n               + 'Z');\r\n    };\r\n\r\n    // Merge attributes from object `b` with attributes in object `a`.\r\n    // Note that this modifies the object `a`.\r\n    // Also important to note that attributes are merged but CSS classes are concatenated.\r\n    V.mergeAttrs = function(a, b) {\r\n\r\n        for (var attr in b) {\r\n\r\n            if (attr === 'class') {\r\n                // Concatenate classes.\r\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\r\n            } else if (attr === 'style') {\r\n                // `style` attribute can be an object.\r\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\r\n                    // `style` stored in `a` is an object.\r\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\r\n                } else if (V.isObject(a[attr])) {\r\n                    // `style` in `a` is an object but it's a string in `b`.\r\n                    // Convert the style represented as a string to an object in `b`.\r\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\r\n                } else if (V.isObject(b[attr])) {\r\n                    // `style` in `a` is a string, in `b` it's an object.\r\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\r\n                } else {\r\n                    // Both styles are strings.\r\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\r\n                }\r\n            } else {\r\n                a[attr] = b[attr];\r\n            }\r\n        }\r\n\r\n        return a;\r\n    };\r\n\r\n    V.annotateString = function(t, annotations, opt) {\r\n\r\n        annotations = annotations || [];\r\n        opt = opt || {};\r\n\r\n        var offset = opt.offset || 0;\r\n        var compacted = [];\r\n        var batch;\r\n        var ret = [];\r\n        var item;\r\n        var prev;\r\n\r\n        for (var i = 0; i < t.length; i++) {\r\n\r\n            item = ret[i] = t[i];\r\n\r\n            for (var j = 0; j < annotations.length; j++) {\r\n\r\n                var annotation = annotations[j];\r\n                var start = annotation.start + offset;\r\n                var end = annotation.end + offset;\r\n\r\n                if (i >= start && i < end) {\r\n                    // Annotation applies.\r\n                    if (V.isObject(item)) {\r\n                        // There is more than one annotation to be applied => Merge attributes.\r\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\r\n                    } else {\r\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\r\n                    }\r\n                    if (opt.includeAnnotationIndices) {\r\n                        (item.annotations || (item.annotations = [])).push(j);\r\n                    }\r\n                }\r\n            }\r\n\r\n            prev = ret[i - 1];\r\n\r\n            if (!prev) {\r\n\r\n                batch = item;\r\n\r\n            } else if (V.isObject(item) && V.isObject(prev)) {\r\n                // Both previous item and the current one are annotations. If the attributes\r\n                // didn't change, merge the text.\r\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\r\n                    batch.t += item.t;\r\n                } else {\r\n                    compacted.push(batch);\r\n                    batch = item;\r\n                }\r\n\r\n            } else if (V.isObject(item)) {\r\n                // Previous item was a string, current item is an annotation.\r\n                compacted.push(batch);\r\n                batch = item;\r\n\r\n            } else if (V.isObject(prev)) {\r\n                // Previous item was an annotation, current item is a string.\r\n                compacted.push(batch);\r\n                batch = item;\r\n\r\n            } else {\r\n                // Both previous and current item are strings.\r\n                batch = (batch || '') + item;\r\n            }\r\n        }\r\n\r\n        if (batch) {\r\n            compacted.push(batch);\r\n        }\r\n\r\n        return compacted;\r\n    };\r\n\r\n    V.findAnnotationsAtIndex = function(annotations, index) {\r\n\r\n        var found = [];\r\n\r\n        if (annotations) {\r\n\r\n            annotations.forEach(function(annotation) {\r\n\r\n                if (annotation.start < index && index <= annotation.end) {\r\n                    found.push(annotation);\r\n                }\r\n            });\r\n        }\r\n\r\n        return found;\r\n    };\r\n\r\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\r\n\r\n        var found = [];\r\n\r\n        if (annotations) {\r\n\r\n            annotations.forEach(function(annotation) {\r\n\r\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\r\n                    found.push(annotation);\r\n                }\r\n            });\r\n        }\r\n\r\n        return found;\r\n    };\r\n\r\n    // Shift all the text annotations after character `index` by `offset` positions.\r\n    V.shiftAnnotations = function(annotations, index, offset) {\r\n\r\n        if (annotations) {\r\n\r\n            annotations.forEach(function(annotation) {\r\n\r\n                if (annotation.start < index && annotation.end >= index) {\r\n                    annotation.end += offset;\r\n                } else if (annotation.start >= index) {\r\n                    annotation.start += offset;\r\n                    annotation.end += offset;\r\n                }\r\n            });\r\n        }\r\n\r\n        return annotations;\r\n    };\r\n\r\n    V.convertLineToPathData = function(line) {\r\n\r\n        line = V(line);\r\n        var d = [\r\n            'M', line.attr('x1'), line.attr('y1'),\r\n            'L', line.attr('x2'), line.attr('y2')\r\n        ].join(' ');\r\n        return d;\r\n    };\r\n\r\n    V.convertPolygonToPathData = function(polygon) {\r\n\r\n        var points = V.getPointsFromSvgNode(V(polygon).node);\r\n\r\n        if (!(points.length > 0)) return null;\r\n\r\n        return V.svgPointsToPath(points) + ' Z';\r\n    };\r\n\r\n    V.convertPolylineToPathData = function(polyline) {\r\n\r\n        var points = V.getPointsFromSvgNode(V(polyline).node);\r\n\r\n        if (!(points.length > 0)) return null;\r\n\r\n        return V.svgPointsToPath(points);\r\n    };\r\n\r\n    V.svgPointsToPath = function(points) {\r\n\r\n        var i;\r\n\r\n        for (i = 0; i < points.length; i++) {\r\n            points[i] = points[i].x + ' ' + points[i].y;\r\n        }\r\n\r\n        return 'M ' + points.join(' L');\r\n    };\r\n\r\n    V.getPointsFromSvgNode = function(node) {\r\n\r\n        var points = [];\r\n        var i;\r\n\r\n        for (i = 0; i < node.points.numberOfItems; i++) {\r\n            points.push(node.points.getItem(i));\r\n        }\r\n\r\n        return points;\r\n    };\r\n\r\n    V.KAPPA = 0.5522847498307935;\r\n\r\n    V.convertCircleToPathData = function(circle) {\r\n\r\n        circle = V(circle);\r\n        var cx = parseFloat(circle.attr('cx')) || 0;\r\n        var cy = parseFloat(circle.attr('cy')) || 0;\r\n        var r = parseFloat(circle.attr('r'));\r\n        var cd = r * V.KAPPA; // Control distance.\r\n\r\n        var d = [\r\n            'M', cx, cy - r,    // Move to the first point.\r\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\r\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\r\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\r\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\r\n            'Z'\r\n        ].join(' ');\r\n        return d;\r\n    };\r\n\r\n    V.convertEllipseToPathData = function(ellipse) {\r\n\r\n        ellipse = V(ellipse);\r\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\r\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\r\n        var rx = parseFloat(ellipse.attr('rx'));\r\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\r\n        var cdx = rx * V.KAPPA; // Control distance x.\r\n        var cdy = ry * V.KAPPA; // Control distance y.\r\n\r\n        var d = [\r\n            'M', cx, cy - ry,    // Move to the first point.\r\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\r\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\r\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\r\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\r\n            'Z'\r\n        ].join(' ');\r\n        return d;\r\n    };\r\n\r\n    V.convertRectToPathData = function(rect) {\r\n\r\n        rect = V(rect);\r\n\r\n        return V.rectToPath({\r\n            x: parseFloat(rect.attr('x')) || 0,\r\n            y: parseFloat(rect.attr('y')) || 0,\r\n            width: parseFloat(rect.attr('width')) || 0,\r\n            height: parseFloat(rect.attr('height')) || 0,\r\n            rx: parseFloat(rect.attr('rx')) || 0,\r\n            ry: parseFloat(rect.attr('ry')) || 0\r\n        });\r\n    };\r\n\r\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\r\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\r\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\r\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\r\n    // that has only `rx` and `ry` attributes).\r\n    V.rectToPath = function(r) {\r\n\r\n        var d;\r\n        var x = r.x;\r\n        var y = r.y;\r\n        var width = r.width;\r\n        var height = r.height;\r\n        var topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);\r\n        var bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);\r\n        var topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);\r\n        var bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);\r\n\r\n        if (topRx || bottomRx || topRy || bottomRy) {\r\n            d = [\r\n                'M', x, y + topRy,\r\n                'v', height - topRy - bottomRy,\r\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\r\n                'h', width - 2 * bottomRx,\r\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\r\n                'v', -(height - bottomRy - topRy),\r\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\r\n                'h', -(width - 2 * topRx),\r\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\r\n                'Z'\r\n            ];\r\n        } else {\r\n            d = [\r\n                'M', x, y,\r\n                'H', x + width,\r\n                'V', y + height,\r\n                'H', x,\r\n                'V', y,\r\n                'Z'\r\n            ];\r\n        }\r\n\r\n        return d.join(' ');\r\n    };\r\n\r\n    V.toNode = function(el) {\r\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\r\n    };\r\n\r\n    return V;\r\n\r\n})();\r\n\r\n\r\n// Global namespace.\r\n\r\nvar joint = {\r\n\r\n    version: '1.1.0',\r\n\r\n    config: {\r\n        // The class name prefix config is for advanced use only.\r\n        // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\r\n        classNamePrefix: 'joint-',\r\n        defaultTheme: 'default'\r\n    },\r\n\r\n    // `joint.dia` namespace.\r\n    dia: {},\r\n\r\n    // `joint.ui` namespace.\r\n    ui: {},\r\n\r\n    // `joint.layout` namespace.\r\n    layout: {},\r\n\r\n    // `joint.shapes` namespace.\r\n    shapes: {},\r\n\r\n    // `joint.format` namespace.\r\n    format: {},\r\n\r\n    // `joint.connectors` namespace.\r\n    connectors: {},\r\n\r\n    // `joint.highlighters` namespace.\r\n    highlighters: {},\r\n\r\n    // `joint.routers` namespace.\r\n    routers: {},\r\n\r\n    // `joint.mvc` namespace.\r\n    mvc: {\r\n        views: {}\r\n    },\r\n\r\n    setTheme: function(theme, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        _.invoke(joint.mvc.views, 'setTheme', theme, opt);\r\n\r\n        // Update the default theme on the view prototype.\r\n        joint.mvc.View.prototype.defaultTheme = theme;\r\n    },\r\n\r\n    // `joint.env` namespace.\r\n    env: {\r\n\r\n        _results: {},\r\n\r\n        _tests: {\r\n\r\n            svgforeignobject: function() {\r\n                return !!document.createElementNS &&\r\n              /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\r\n            }\r\n        },\r\n\r\n        addTest: function(name, fn) {\r\n\r\n            return joint.env._tests[name] = fn;\r\n        },\r\n\r\n        test: function(name) {\r\n\r\n            var fn = joint.env._tests[name];\r\n\r\n            if (!fn) {\r\n                throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\r\n            }\r\n\r\n            var result = joint.env._results[name];\r\n\r\n            if (typeof result !== 'undefined') {\r\n                return result;\r\n            }\r\n\r\n            try {\r\n                result = fn();\r\n            } catch (error) {\r\n                result = false;\r\n            }\r\n\r\n            // Cache the test result.\r\n            joint.env._results[name] = result;\r\n\r\n            return result;\r\n        }\r\n    },\r\n\r\n    util: {\r\n\r\n        // Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\r\n        hashCode: function(str) {\r\n\r\n            var hash = 0;\r\n            if (str.length == 0) return hash;\r\n            for (var i = 0; i < str.length; i++) {\r\n                var c = str.charCodeAt(i);\r\n                hash = ((hash << 5) - hash) + c;\r\n                hash = hash & hash; // Convert to 32bit integer\r\n            }\r\n            return hash;\r\n        },\r\n\r\n        getByPath: function(obj, path, delim) {\r\n\r\n            var keys = _.isArray(path) ? path.slice() : path.split(delim || '/');\r\n            var key;\r\n\r\n            while (keys.length) {\r\n                key = keys.shift();\r\n                if (Object(obj) === obj && key in obj) {\r\n                    obj = obj[key];\r\n                } else {\r\n                    return undefined;\r\n                }\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        setByPath: function(obj, path, value, delim) {\r\n\r\n            var keys = _.isArray(path) ? path : path.split(delim || '/');\r\n\r\n            var diver = obj;\r\n            var i = 0;\r\n\r\n            for (var len = keys.length; i < len - 1; i++) {\r\n                // diver creates an empty object if there is no nested object under such a key.\r\n                // This means that one can populate an empty nested object with setByPath().\r\n                diver = diver[keys[i]] || (diver[keys[i]] = {});\r\n            }\r\n            diver[keys[len - 1]] = value;\r\n\r\n            return obj;\r\n        },\r\n\r\n        unsetByPath: function(obj, path, delim) {\r\n\r\n            delim = delim || '/';\r\n\r\n            var pathArray = _.isArray(path) ? path.slice() : path.split(delim);\r\n\r\n            var propertyToRemove = pathArray.pop();\r\n            if (pathArray.length > 0) {\r\n\r\n                // unsetting a nested attribute\r\n                var parent = joint.util.getByPath(obj, pathArray, delim);\r\n\r\n                if (parent) {\r\n                    delete parent[propertyToRemove];\r\n                }\r\n\r\n            } else {\r\n\r\n                // unsetting a primitive attribute\r\n                delete obj[propertyToRemove];\r\n            }\r\n\r\n            return obj;\r\n        },\r\n\r\n        flattenObject: function(obj, delim, stop) {\r\n\r\n            delim = delim || '/';\r\n            var ret = {};\r\n\r\n            for (var key in obj) {\r\n\r\n                if (!obj.hasOwnProperty(key)) continue;\r\n\r\n                var shouldGoDeeper = typeof obj[key] === 'object';\r\n                if (shouldGoDeeper && stop && stop(obj[key])) {\r\n                    shouldGoDeeper = false;\r\n                }\r\n\r\n                if (shouldGoDeeper) {\r\n\r\n                    var flatObject = this.flattenObject(obj[key], delim, stop);\r\n\r\n                    for (var flatKey in flatObject) {\r\n                        if (!flatObject.hasOwnProperty(flatKey)) continue;\r\n                        ret[key + delim + flatKey] = flatObject[flatKey];\r\n                    }\r\n\r\n                } else {\r\n\r\n                    ret[key] = obj[key];\r\n                }\r\n            }\r\n\r\n            return ret;\r\n        },\r\n\r\n        uuid: function() {\r\n\r\n            // credit: http://stackoverflow.com/posts/2117523/revisions\r\n\r\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n                var r = Math.random() * 16|0;\r\n                var v = c == 'x' ? r : (r&0x3|0x8);\r\n                return v.toString(16);\r\n            });\r\n        },\r\n\r\n        // Generate global unique id for obj and store it as a property of the object.\r\n        guid: function(obj) {\r\n\r\n            this.guid.id = this.guid.id || 1;\r\n            obj.id = (obj.id === undefined ? 'j_' + this.guid.id++ : obj.id);\r\n            return obj.id;\r\n        },\r\n\r\n        toKebabCase: function(string) {\r\n\r\n            return string.replace(/[A-Z]/g, '-$&').toLowerCase();\r\n        },\r\n\r\n        // Copy all the properties to the first argument from the following arguments.\r\n        // All the properties will be overwritten by the properties from the following\r\n        // arguments. Inherited properties are ignored.\r\n        mixin: _.assign,\r\n\r\n        // Copy all properties to the first argument from the following\r\n        // arguments only in case if they don't exists in the first argument.\r\n        // All the function propererties in the first argument will get\r\n        // additional property base pointing to the extenders same named\r\n        // property function's call method.\r\n        supplement: _.defaults,\r\n\r\n        // Same as `mixin()` but deep version.\r\n        deepMixin: _.mixin,\r\n\r\n        // Same as `supplement()` but deep version.\r\n        deepSupplement: _.defaultsDeep,\r\n\r\n        normalizeEvent: function(evt) {\r\n\r\n            var touchEvt = evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches[0];\r\n            if (touchEvt) {\r\n                for (var property in evt) {\r\n                    // copy all the properties from the input event that are not\r\n                    // defined on the touch event (functions included).\r\n                    if (touchEvt[property] === undefined) {\r\n                        touchEvt[property] = evt[property];\r\n                    }\r\n                }\r\n                return touchEvt;\r\n            }\r\n\r\n            return evt;\r\n        },\r\n\r\n        nextFrame: (function() {\r\n\r\n            var raf;\r\n\r\n            if (typeof window !== 'undefined') {\r\n\r\n                raf = window.requestAnimationFrame ||\r\n                        window.webkitRequestAnimationFrame ||\r\n                        window.mozRequestAnimationFrame ||\r\n                        window.oRequestAnimationFrame ||\r\n                        window.msRequestAnimationFrame;\r\n            }\r\n\r\n            if (!raf) {\r\n\r\n                var lastTime = 0;\r\n\r\n                raf = function(callback) {\r\n\r\n                    var currTime = new Date().getTime();\r\n                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n                    var id = setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\r\n\r\n                    lastTime = currTime + timeToCall;\r\n\r\n                    return id;\r\n                };\r\n            }\r\n\r\n            return function(callback, context) {\r\n                return context\r\n                    ? raf(_.bind(callback, context))\r\n                    : raf(callback);\r\n            };\r\n\r\n        })(),\r\n\r\n        cancelFrame: (function() {\r\n\r\n            var caf;\r\n            var client = typeof window != 'undefined';\r\n\r\n            if (client) {\r\n\r\n                caf = window.cancelAnimationFrame ||\r\n                        window.webkitCancelAnimationFrame ||\r\n                        window.webkitCancelRequestAnimationFrame ||\r\n                        window.msCancelAnimationFrame ||\r\n                        window.msCancelRequestAnimationFrame ||\r\n                        window.oCancelAnimationFrame ||\r\n                        window.oCancelRequestAnimationFrame ||\r\n                        window.mozCancelAnimationFrame ||\r\n                        window.mozCancelRequestAnimationFrame;\r\n            }\r\n\r\n            caf = caf || clearTimeout;\r\n\r\n            return client ? _.bind(caf, window) : caf;\r\n\r\n        })(),\r\n\r\n        shapePerimeterConnectionPoint: function(linkView, view, magnet, reference) {\r\n\r\n            var bbox;\r\n            var spot;\r\n\r\n            if (!magnet) {\r\n\r\n                // There is no magnet, try to make the best guess what is the\r\n                // wrapping SVG element. This is because we want this \"smart\"\r\n                // connection points to work out of the box without the\r\n                // programmer to put magnet marks to any of the subelements.\r\n                // For example, we want the functoin to work on basic.Path elements\r\n                // without any special treatment of such elements.\r\n                // The code below guesses the wrapping element based on\r\n                // one simple assumption. The wrapping elemnet is the\r\n                // first child of the scalable group if such a group exists\r\n                // or the first child of the rotatable group if not.\r\n                // This makese sense because usually the wrapping element\r\n                // is below any other sub element in the shapes.\r\n                var scalable = view.$('.scalable')[0];\r\n                var rotatable = view.$('.rotatable')[0];\r\n\r\n                if (scalable && scalable.firstChild) {\r\n\r\n                    magnet = scalable.firstChild;\r\n\r\n                } else if (rotatable && rotatable.firstChild) {\r\n\r\n                    magnet = rotatable.firstChild;\r\n                }\r\n            }\r\n\r\n            if (magnet) {\r\n\r\n                spot = V(magnet).findIntersection(reference, linkView.paper.viewport);\r\n                if (!spot) {\r\n                    bbox = g.rect(V(magnet).bbox(false, linkView.paper.viewport));\r\n                }\r\n\r\n            } else {\r\n\r\n                bbox = view.model.getBBox();\r\n                spot = bbox.intersectionWithLineFromCenterToPoint(reference);\r\n            }\r\n            return spot || bbox.center();\r\n        },\r\n\r\n        parseCssNumeric: function(strValue, restrictUnits) {\r\n\r\n            restrictUnits = restrictUnits || [];\r\n            var cssNumeric = { value: parseFloat(strValue) };\r\n\r\n            if (_.isNaN(cssNumeric.value)) {\r\n                return null;\r\n            }\r\n\r\n            var validUnitsExp = restrictUnits.join('|');\r\n\r\n            if (_.isString(strValue)) {\r\n                var matches = new RegExp('(\\\\d+)(' + validUnitsExp + ')$').exec(strValue);\r\n                if (!matches) {\r\n                    return null;\r\n                }\r\n                if (matches[2]) {\r\n                    cssNumeric.unit = matches[2];\r\n                }\r\n            }\r\n            return cssNumeric;\r\n        },\r\n\r\n        breakText: function(text, size, styles, opt) {\r\n\r\n            opt = opt || {};\r\n\r\n            var width = size.width;\r\n            var height = size.height;\r\n\r\n            var svgDocument = opt.svgDocument || V('svg').node;\r\n            var textElement = V('<text><tspan></tspan></text>').attr(styles || {}).node;\r\n            var textSpan = textElement.firstChild;\r\n            var textNode = document.createTextNode('');\r\n\r\n            // Prevent flickering\r\n            textElement.style.opacity = 0;\r\n            // Prevent FF from throwing an uncaught exception when `getBBox()`\r\n            // called on element that is not in the render tree (is not measurable).\r\n            // <tspan>.getComputedTextLength() returns always 0 in this case.\r\n            // Note that the `textElement` resp. `textSpan` can become hidden\r\n            // when it's appended to the DOM and a `display: none` CSS stylesheet\r\n            // rule gets applied.\r\n            textElement.style.display = 'block';\r\n            textSpan.style.display = 'block';\r\n\r\n            textSpan.appendChild(textNode);\r\n            svgDocument.appendChild(textElement);\r\n\r\n            if (!opt.svgDocument) {\r\n\r\n                document.body.appendChild(svgDocument);\r\n            }\r\n\r\n            var words = text.split(' ');\r\n            var full = [];\r\n            var lines = [];\r\n            var p;\r\n            var lineHeight;\r\n\r\n            for (var i = 0, l = 0, len = words.length; i < len; i++) {\r\n\r\n                var word = words[i];\r\n\r\n                textNode.data = lines[l] ? lines[l] + ' ' + word : word;\r\n\r\n                if (textSpan.getComputedTextLength() <= width) {\r\n\r\n                    // the current line fits\r\n                    lines[l] = textNode.data;\r\n\r\n                    if (p) {\r\n                        // We were partitioning. Put rest of the word onto next line\r\n                        full[l++] = true;\r\n\r\n                        // cancel partitioning\r\n                        p = 0;\r\n                    }\r\n\r\n                } else {\r\n\r\n                    if (!lines[l] || p) {\r\n\r\n                        var partition = !!p;\r\n\r\n                        p = word.length - 1;\r\n\r\n                        if (partition || !p) {\r\n\r\n                            // word has only one character.\r\n                            if (!p) {\r\n\r\n                                if (!lines[l]) {\r\n\r\n                                    // we won't fit this text within our rect\r\n                                    lines = [];\r\n\r\n                                    break;\r\n                                }\r\n\r\n                                // partitioning didn't help on the non-empty line\r\n                                // try again, but this time start with a new line\r\n\r\n                                // cancel partitions created\r\n                                words.splice(i, 2, word + words[i + 1]);\r\n\r\n                                // adjust word length\r\n                                len--;\r\n\r\n                                full[l++] = true;\r\n                                i--;\r\n\r\n                                continue;\r\n                            }\r\n\r\n                            // move last letter to the beginning of the next word\r\n                            words[i] = word.substring(0, p);\r\n                            words[i + 1] = word.substring(p) + words[i + 1];\r\n\r\n                        } else {\r\n\r\n                            // We initiate partitioning\r\n                            // split the long word into two words\r\n                            words.splice(i, 1, word.substring(0, p), word.substring(p));\r\n\r\n                            // adjust words length\r\n                            len++;\r\n\r\n                            if (l && !full[l - 1]) {\r\n                                // if the previous line is not full, try to fit max part of\r\n                                // the current word there\r\n                                l--;\r\n                            }\r\n                        }\r\n\r\n                        i--;\r\n\r\n                        continue;\r\n                    }\r\n\r\n                    l++;\r\n                    i--;\r\n                }\r\n\r\n                // if size.height is defined we have to check whether the height of the entire\r\n                // text exceeds the rect height\r\n                if (height !== undefined) {\r\n\r\n                    if (lineHeight === undefined) {\r\n\r\n                        var heightValue;\r\n\r\n                        // use the same defaults as in V.prototype.text\r\n                        if (styles.lineHeight === 'auto') {\r\n                            heightValue = { value: 1.5, unit: 'em' };\r\n                        } else {\r\n                            heightValue = joint.util.parseCssNumeric(styles.lineHeight, ['em']) || { value: 1, unit: 'em' };\r\n                        }\r\n\r\n                        lineHeight = heightValue.value;\r\n                        if (heightValue.unit === 'em' ) {\r\n                            lineHeight *= textElement.getBBox().height;\r\n                        }\r\n                    }\r\n\r\n                    if (lineHeight * lines.length > height) {\r\n\r\n                        // remove overflowing lines\r\n                        lines.splice(Math.floor(height / lineHeight));\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (opt.svgDocument) {\r\n\r\n                // svg document was provided, remove the text element only\r\n                svgDocument.removeChild(textElement);\r\n\r\n            } else {\r\n\r\n                // clean svg document\r\n                document.body.removeChild(svgDocument);\r\n            }\r\n\r\n            return lines.join('\\n');\r\n        },\r\n\r\n        imageToDataUri: function(url, callback) {\r\n\r\n            if (!url || url.substr(0, 'data:'.length) === 'data:') {\r\n                // No need to convert to data uri if it is already in data uri.\r\n\r\n                // This not only convenient but desired. For example,\r\n                // IE throws a security error if data:image/svg+xml is used to render\r\n                // an image to the canvas and an attempt is made to read out data uri.\r\n                // Now if our image is already in data uri, there is no need to render it to the canvas\r\n                // and so we can bypass this error.\r\n\r\n                // Keep the async nature of the function.\r\n                return setTimeout(function() {\r\n                    callback(null, url);\r\n                }, 0);\r\n            }\r\n\r\n            // chrome IE10 IE11\r\n            var modernHandler = function(xhr, callback) {\r\n\r\n                if (xhr.status === 200) {\r\n\r\n                    var reader = new FileReader();\r\n\r\n                    reader.onload = function(evt) {\r\n                        var dataUri = evt.target.result;\r\n                        callback(null, dataUri);\r\n                    };\r\n\r\n                    reader.onerror = function() {\r\n                        callback(new Error('Failed to load image ' + url));\r\n                    };\r\n\r\n                    reader.readAsDataURL(xhr.response);\r\n                } else {\r\n                    callback(new Error('Failed to load image ' + url));\r\n                }\r\n\r\n            };\r\n\r\n            var legacyHandler = function(xhr, callback) {\r\n\r\n                var Uint8ToString = function(u8a) {\r\n                    var CHUNK_SZ = 0x8000;\r\n                    var c = [];\r\n                    for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\r\n                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\r\n                    }\r\n                    return c.join('');\r\n                };\r\n\r\n\r\n                if (xhr.status === 200) {\r\n\r\n                    var bytes = new Uint8Array(xhr.response);\r\n\r\n                    var suffix = (url.split('.').pop()) || 'png';\r\n                    var map = {\r\n                        'svg': 'svg+xml'\r\n                    };\r\n                    var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\r\n                    var b64encoded = meta + btoa(Uint8ToString(bytes));\r\n                    callback(null, b64encoded);\r\n                } else {\r\n                    callback(new Error('Failed to load image ' + url));\r\n                }\r\n            };\r\n\r\n            var xhr = new XMLHttpRequest();\r\n\r\n            xhr.open('GET', url, true);\r\n            xhr.addEventListener('error', function() {\r\n                callback(new Error('Failed to load image ' + url));\r\n            });\r\n\r\n            xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\r\n\r\n            xhr.addEventListener('load', function() {\r\n                if (window.FileReader) {\r\n                    modernHandler(xhr, callback);\r\n                } else {\r\n                    legacyHandler(xhr, callback);\r\n                }\r\n            });\r\n\r\n            xhr.send();\r\n        },\r\n\r\n        getElementBBox: function(el) {\r\n\r\n            var $el = $(el);\r\n            if ($el.length === 0) {\r\n                throw new Error('Element not found')\r\n            }\r\n\r\n            var element = $el[0];\r\n            var doc = element.ownerDocument;\r\n            var clientBBox = element.getBoundingClientRect();\r\n\r\n            var strokeWidthX = 0;\r\n            var strokeWidthY = 0;\r\n\r\n            // Firefox correction\r\n            if (element.ownerSVGElement) {\r\n\r\n                var bbox = V(element).bbox();\r\n\r\n                // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\r\n                // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\r\n                strokeWidthX = (clientBBox.width - bbox.width);\r\n                strokeWidthY = (clientBBox.height - bbox.height);\r\n            }\r\n\r\n            return  {\r\n                x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\r\n                y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\r\n                width: clientBBox.width - strokeWidthX,\r\n                height: clientBBox.height - strokeWidthY\r\n            };\r\n        },\r\n\r\n\r\n        // Highly inspired by the jquery.sortElements plugin by Padolsey.\r\n        // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\r\n        sortElements: function(elements, comparator) {\r\n\r\n            var $elements = $(elements);\r\n            var placements = $elements.map(function() {\r\n\r\n                var sortElement = this;\r\n                var parentNode = sortElement.parentNode;\r\n                // Since the element itself will change position, we have\r\n                // to have some way of storing it's original position in\r\n                // the DOM. The easiest way is to have a 'flag' node:\r\n                var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\r\n\r\n                return function() {\r\n\r\n                    if (parentNode === this) {\r\n                        throw new Error('You can\\'t sort elements if any one is a descendant of another.');\r\n                    }\r\n\r\n                    // Insert before flag:\r\n                    parentNode.insertBefore(this, nextSibling);\r\n                    // Remove flag:\r\n                    parentNode.removeChild(nextSibling);\r\n                };\r\n            });\r\n\r\n            return Array.prototype.sort.call($elements, comparator).each(function(i) {\r\n                placements[i].call(this);\r\n            });\r\n        },\r\n\r\n        // Sets attributes on the given element and its descendants based on the selector.\r\n        // `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\r\n        setAttributesBySelector: function(element, attrs) {\r\n\r\n            var $element = $(element);\r\n\r\n            _.each(attrs, function(attrs, selector) {\r\n                var $elements = $element.find(selector).addBack().filter(selector);\r\n                // Make a special case for setting classes.\r\n                // We do not want to overwrite any existing class.\r\n                if (_.has(attrs, 'class')) {\r\n                    $elements.addClass(attrs['class']);\r\n                    attrs = _.omit(attrs, 'class');\r\n                }\r\n                $elements.attr(attrs);\r\n            });\r\n        },\r\n\r\n        // Return a new object with all for sides (top, bottom, left and right) in it.\r\n        // Value of each side is taken from the given argument (either number or object).\r\n        // Default value for a side is 0.\r\n        // Examples:\r\n        // joint.util.normalizeSides(5) --> { top: 5, left: 5, right: 5, bottom: 5 }\r\n        // joint.util.normalizeSides({ left: 5 }) --> { top: 0, left: 5, right: 0, bottom: 0 }\r\n        normalizeSides: function(box) {\r\n\r\n            if (Object(box) !== box) {\r\n                box = box || 0;\r\n                return { top: box, bottom: box, left: box, right: box };\r\n            }\r\n\r\n            return {\r\n                top: box.top || 0,\r\n                bottom: box.bottom || 0,\r\n                left: box.left || 0,\r\n                right: box.right || 0\r\n            };\r\n        },\r\n\r\n        timing: {\r\n\r\n            linear: function(t) {\r\n                return t;\r\n            },\r\n\r\n            quad: function(t) {\r\n                return t * t;\r\n            },\r\n\r\n            cubic: function(t) {\r\n                return t * t * t;\r\n            },\r\n\r\n            inout: function(t) {\r\n                if (t <= 0) return 0;\r\n                if (t >= 1) return 1;\r\n                var t2 = t * t;\r\n                var t3 = t2 * t;\r\n                return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\r\n            },\r\n\r\n            exponential: function(t) {\r\n                return Math.pow(2, 10 * (t - 1));\r\n            },\r\n\r\n            bounce: function(t) {\r\n                for (var a = 0, b = 1; 1; a += b, b /= 2) {\r\n                    if (t >= (7 - 4 * a) / 11) {\r\n                        var q = (11 - 6 * a - 11 * t) / 4;\r\n                        return -q * q + b * b;\r\n                    }\r\n                }\r\n            },\r\n\r\n            reverse: function(f) {\r\n                return function(t) {\r\n                    return 1 - f(1 - t);\r\n                };\r\n            },\r\n\r\n            reflect: function(f) {\r\n                return function(t) {\r\n                    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\r\n                };\r\n            },\r\n\r\n            clamp: function(f, n, x) {\r\n                n = n || 0;\r\n                x = x || 1;\r\n                return function(t) {\r\n                    var r = f(t);\r\n                    return r < n ? n : r > x ? x : r;\r\n                };\r\n            },\r\n\r\n            back: function(s) {\r\n                if (!s) s = 1.70158;\r\n                return function(t) {\r\n                    return t * t * ((s + 1) * t - s);\r\n                };\r\n            },\r\n\r\n            elastic: function(x) {\r\n                if (!x) x = 1.5;\r\n                return function(t) {\r\n                    return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\r\n                };\r\n            }\r\n        },\r\n\r\n        interpolate: {\r\n\r\n            number: function(a, b) {\r\n                var d = b - a;\r\n                return function(t) { return a + d * t; };\r\n            },\r\n\r\n            object: function(a, b) {\r\n                var s = _.keys(a);\r\n                return function(t) {\r\n                    var i, p;\r\n                    var r = {};\r\n                    for (i = s.length - 1; i != -1; i--) {\r\n                        p = s[i];\r\n                        r[p] = a[p] + (b[p] - a[p]) * t;\r\n                    }\r\n                    return r;\r\n                };\r\n            },\r\n\r\n            hexColor: function(a, b) {\r\n\r\n                var ca = parseInt(a.slice(1), 16);\r\n                var cb = parseInt(b.slice(1), 16);\r\n                var ra = ca & 0x0000ff;\r\n                var rd = (cb & 0x0000ff) - ra;\r\n                var ga = ca & 0x00ff00;\r\n                var gd = (cb & 0x00ff00) - ga;\r\n                var ba = ca & 0xff0000;\r\n                var bd = (cb & 0xff0000) - ba;\r\n\r\n                return function(t) {\r\n\r\n                    var r = (ra + rd * t) & 0x000000ff;\r\n                    var g = (ga + gd * t) & 0x0000ff00;\r\n                    var b = (ba + bd * t) & 0x00ff0000;\r\n\r\n                    return '#' + (1 << 24 | r | g | b ).toString(16).slice(1);\r\n                };\r\n            },\r\n\r\n            unit: function(a, b) {\r\n\r\n                var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\r\n                var ma = r.exec(a);\r\n                var mb = r.exec(b);\r\n                var p = mb[1].indexOf('.');\r\n                var f = p > 0 ? mb[1].length - p - 1 : 0;\r\n                a = +ma[1];\r\n                var d = +mb[1] - a;\r\n                var u = ma[2];\r\n\r\n                return function(t) {\r\n                    return (a + d * t).toFixed(f) + u;\r\n                };\r\n            }\r\n        },\r\n\r\n        // SVG filters.\r\n        filter: {\r\n\r\n            // `color` ... outline color\r\n            // `width`... outline width\r\n            // `opacity` ... outline opacity\r\n            // `margin` ... gap between outline and the element\r\n            outline: function(args) {\r\n\r\n                var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\r\n\r\n                var margin = _.isFinite(args.margin) ? args.margin : 2;\r\n                var width = _.isFinite(args.width) ? args.width : 1;\r\n\r\n                return joint.util.template(tpl)({\r\n                    color: args.color || 'blue',\r\n                    opacity: _.isFinite(args.opacity) ? args.opacity : 1,\r\n                    outerRadius: margin + width,\r\n                    innerRadius: margin\r\n                });\r\n            },\r\n\r\n            // `color` ... color\r\n            // `width`... width\r\n            // `blur` ... blur\r\n            // `opacity` ... opacity\r\n            highlight: function(args) {\r\n\r\n                var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\r\n\r\n                return joint.util.template(tpl)({\r\n                    color: args.color || 'red',\r\n                    width: _.isFinite(args.width) ? args.width : 1,\r\n                    blur: _.isFinite(args.blur) ? args.blur : 0,\r\n                    opacity: _.isFinite(args.opacity) ? args.opacity : 1\r\n                });\r\n            },\r\n\r\n            // `x` ... horizontal blur\r\n            // `y` ... vertical blur (optional)\r\n            blur: function(args) {\r\n\r\n                var x = _.isFinite(args.x) ? args.x : 2;\r\n\r\n                return joint.util.template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\r\n                    stdDeviation: _.isFinite(args.y) ? [x, args.y] : x\r\n                });\r\n            },\r\n\r\n            // `dx` ... horizontal shift\r\n            // `dy` ... vertical shift\r\n            // `blur` ... blur\r\n            // `color` ... color\r\n            // `opacity` ... opacity\r\n            dropShadow: function(args) {\r\n\r\n                var tpl = 'SVGFEDropShadowElement' in window\r\n                    ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\r\n                    : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\r\n\r\n                return joint.util.template(tpl)({\r\n                    dx: args.dx || 0,\r\n                    dy: args.dy || 0,\r\n                    opacity: _.isFinite(args.opacity) ? args.opacity : 1,\r\n                    color: args.color || 'black',\r\n                    blur: _.isFinite(args.blur) ? args.blur : 4\r\n                });\r\n            },\r\n\r\n            // `amount` ... the proportion of the conversion. A value of 1 is completely grayscale. A value of 0 leaves the input unchanged.\r\n            grayscale: function(args) {\r\n\r\n                var amount = _.isFinite(args.amount) ? args.amount : 1;\r\n\r\n                return joint.util.template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\r\n                    a: 0.2126 + 0.7874 * (1 - amount),\r\n                    b: 0.7152 - 0.7152 * (1 - amount),\r\n                    c: 0.0722 - 0.0722 * (1 - amount),\r\n                    d: 0.2126 - 0.2126 * (1 - amount),\r\n                    e: 0.7152 + 0.2848 * (1 - amount),\r\n                    f: 0.0722 - 0.0722 * (1 - amount),\r\n                    g: 0.2126 - 0.2126 * (1 - amount),\r\n                    h: 0.0722 + 0.9278 * (1 - amount)\r\n                });\r\n            },\r\n\r\n            // `amount` ... the proportion of the conversion. A value of 1 is completely sepia. A value of 0 leaves the input unchanged.\r\n            sepia: function(args) {\r\n\r\n                var amount = _.isFinite(args.amount) ? args.amount : 1;\r\n\r\n                return joint.util.template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\r\n                    a: 0.393 + 0.607 * (1 - amount),\r\n                    b: 0.769 - 0.769 * (1 - amount),\r\n                    c: 0.189 - 0.189 * (1 - amount),\r\n                    d: 0.349 - 0.349 * (1 - amount),\r\n                    e: 0.686 + 0.314 * (1 - amount),\r\n                    f: 0.168 - 0.168 * (1 - amount),\r\n                    g: 0.272 - 0.272 * (1 - amount),\r\n                    h: 0.534 - 0.534 * (1 - amount),\r\n                    i: 0.131 + 0.869 * (1 - amount)\r\n                });\r\n            },\r\n\r\n            // `amount` ... the proportion of the conversion. A value of 0 is completely un-saturated. A value of 1 leaves the input unchanged.\r\n            saturate: function(args) {\r\n\r\n                var amount = _.isFinite(args.amount) ? args.amount : 1;\r\n\r\n                return joint.util.template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\r\n                    amount: 1 - amount\r\n                });\r\n            },\r\n\r\n            // `angle` ...  the number of degrees around the color circle the input samples will be adjusted.\r\n            hueRotate: function(args) {\r\n\r\n                return joint.util.template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\r\n                    angle: args.angle || 0\r\n                });\r\n            },\r\n\r\n            // `amount` ... the proportion of the conversion. A value of 1 is completely inverted. A value of 0 leaves the input unchanged.\r\n            invert: function(args) {\r\n\r\n                var amount = _.isFinite(args.amount) ? args.amount : 1;\r\n\r\n                return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\r\n                    amount: amount,\r\n                    amount2: 1 - amount\r\n                });\r\n            },\r\n\r\n            // `amount` ... proportion of the conversion. A value of 0 will create an image that is completely black. A value of 1 leaves the input unchanged.\r\n            brightness: function(args) {\r\n\r\n                return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\r\n                    amount: _.isFinite(args.amount) ? args.amount : 1\r\n                });\r\n            },\r\n\r\n            // `amount` ... proportion of the conversion. A value of 0 will create an image that is completely black. A value of 1 leaves the input unchanged.\r\n            contrast: function(args) {\r\n\r\n                var amount = _.isFinite(args.amount) ? args.amount : 1;\r\n\r\n                return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\r\n                    amount: amount,\r\n                    amount2: .5 - amount / 2\r\n                });\r\n            }\r\n        },\r\n\r\n        format: {\r\n\r\n            // Formatting numbers via the Python Format Specification Mini-language.\r\n            // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\r\n            // Heavilly inspired by the D3.js library implementation.\r\n            number: function(specifier, value, locale) {\r\n\r\n                locale = locale || {\r\n\r\n                    currency: ['$', ''],\r\n                    decimal: '.',\r\n                    thousands: ',',\r\n                    grouping: [3]\r\n                };\r\n\r\n                // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\r\n                // [[fill]align][sign][symbol][0][width][,][.precision][type]\r\n                var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\r\n\r\n                var match = re.exec(specifier);\r\n                var fill = match[1] || ' ';\r\n                var align = match[2] || '>';\r\n                var sign = match[3] || '';\r\n                var symbol = match[4] || '';\r\n                var zfill = match[5];\r\n                var width = +match[6];\r\n                var comma = match[7];\r\n                var precision = match[8];\r\n                var type = match[9];\r\n                var scale = 1;\r\n                var prefix = '';\r\n                var suffix = '';\r\n                var integer = false;\r\n\r\n                if (precision) precision = +precision.substring(1);\r\n\r\n                if (zfill || fill === '0' && align === '=') {\r\n                    zfill = fill = '0';\r\n                    align = '=';\r\n                    if (comma) width -= Math.floor((width - 1) / 4);\r\n                }\r\n\r\n                switch (type) {\r\n                    case 'n':\r\n                        comma = true; type = 'g';\r\n                        break;\r\n                    case '%':\r\n                        scale = 100; suffix = '%'; type = 'f';\r\n                        break;\r\n                    case 'p':\r\n                        scale = 100; suffix = '%'; type = 'r';\r\n                        break;\r\n                    case 'b':\r\n                    case 'o':\r\n                    case 'x':\r\n                    case 'X':\r\n                        if (symbol === '#') prefix = '0' + type.toLowerCase();\r\n                        break;\r\n                    case 'c':\r\n                    case 'd':\r\n                        integer = true; precision = 0;\r\n                        break;\r\n                    case 's':\r\n                        scale = -1; type = 'r';\r\n                        break;\r\n                }\r\n\r\n                if (symbol === '$') {\r\n                    prefix = locale.currency[0];\r\n                    suffix = locale.currency[1];\r\n                }\r\n\r\n                // If no precision is specified for `'r'`, fallback to general notation.\r\n                if (type == 'r' && !precision) type = 'g';\r\n\r\n                // Ensure that the requested precision is in the supported range.\r\n                if (precision != null) {\r\n                    if (type == 'g') precision = Math.max(1, Math.min(21, precision));\r\n                    else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\r\n                }\r\n\r\n                var zcomma = zfill && comma;\r\n\r\n                // Return the empty string for floats formatted as ints.\r\n                if (integer && (value % 1)) return '';\r\n\r\n                // Convert negative to positive, and record the sign prefix.\r\n                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\r\n\r\n                var fullSuffix = suffix;\r\n\r\n                // Apply the scale, computing it from the value's exponent for si format.\r\n                // Preserve the existing suffix, if any, such as the currency symbol.\r\n                if (scale < 0) {\r\n                    var unit = this.prefix(value, precision);\r\n                    value = unit.scale(value);\r\n                    fullSuffix = unit.symbol + suffix;\r\n                } else {\r\n                    value *= scale;\r\n                }\r\n\r\n                // Convert to the desired precision.\r\n                value = this.convert(type, value, precision);\r\n\r\n                // Break the value into the integer part (before) and decimal part (after).\r\n                var i = value.lastIndexOf('.');\r\n                var before = i < 0 ? value : value.substring(0, i);\r\n                var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\r\n\r\n                function formatGroup(value) {\r\n\r\n                    var i = value.length;\r\n                    var t = [];\r\n                    var j = 0;\r\n                    var g = locale.grouping[0];\r\n                    while (i > 0 && g > 0) {\r\n                        t.push(value.substring(i -= g, i + g));\r\n                        g = locale.grouping[j = (j + 1) % locale.grouping.length];\r\n                    }\r\n                    return t.reverse().join(locale.thousands);\r\n                }\r\n\r\n                // If the fill character is not `'0'`, grouping is applied before padding.\r\n                if (!zfill && comma && locale.grouping) {\r\n\r\n                    before = formatGroup(before);\r\n                }\r\n\r\n                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\r\n                var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\r\n\r\n                // If the fill character is `'0'`, grouping is applied after padding.\r\n                if (zcomma) before = formatGroup(padding + before);\r\n\r\n                // Apply prefix.\r\n                negative += prefix;\r\n\r\n                // Rejoin integer and decimal parts.\r\n                value = before + after;\r\n\r\n                return (align === '<' ? negative + value + padding\r\n                        : align === '>' ? padding + negative + value\r\n                        : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\r\n                        : negative + (zcomma ? value : padding + value)) + fullSuffix;\r\n            },\r\n\r\n            // Formatting string via the Python Format string.\r\n            // See https://docs.python.org/2/library/string.html#format-string-syntax)\r\n            string: function(formatString, value) {\r\n\r\n                var fieldDelimiterIndex;\r\n                var fieldDelimiter = '{';\r\n                var endPlaceholder = false;\r\n                var formattedStringArray = [];\r\n\r\n                while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\r\n\r\n                    var pieceFormatedString, formatSpec, fieldName;\r\n\r\n                    pieceFormatedString = formatString.slice(0, fieldDelimiterIndex);\r\n\r\n                    if (endPlaceholder) {\r\n                        formatSpec = pieceFormatedString.split(':');\r\n                        fieldName = formatSpec.shift().split('.');\r\n                        pieceFormatedString = value;\r\n\r\n                        for (var i = 0; i < fieldName.length; i++)\r\n                            pieceFormatedString = pieceFormatedString[fieldName[i]];\r\n\r\n                        if (formatSpec.length)\r\n                            pieceFormatedString = this.number(formatSpec, pieceFormatedString);\r\n                    }\r\n\r\n                    formattedStringArray.push(pieceFormatedString);\r\n\r\n                    formatString = formatString.slice(fieldDelimiterIndex + 1);\r\n                    fieldDelimiter = (endPlaceholder = !endPlaceholder) ? '}' : '{';\r\n                }\r\n                formattedStringArray.push(formatString);\r\n\r\n                return formattedStringArray.join('');\r\n            },\r\n\r\n            convert: function(type, value, precision) {\r\n\r\n                switch (type) {\r\n                    case 'b': return value.toString(2);\r\n                    case 'c': return String.fromCharCode(value);\r\n                    case 'o': return value.toString(8);\r\n                    case 'x': return value.toString(16);\r\n                    case 'X': return value.toString(16).toUpperCase();\r\n                    case 'g': return value.toPrecision(precision);\r\n                    case 'e': return value.toExponential(precision);\r\n                    case 'f': return value.toFixed(precision);\r\n                    case 'r': return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\r\n                    default: return value + '';\r\n                }\r\n            },\r\n\r\n            round: function(value, precision) {\r\n\r\n                return precision\r\n                    ? Math.round(value * (precision = Math.pow(10, precision))) / precision\r\n                    : Math.round(value);\r\n            },\r\n\r\n            precision: function(value, precision) {\r\n\r\n                return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\r\n            },\r\n\r\n            prefix: function(value, precision) {\r\n\r\n                var prefixes = _.map(['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'], function(d, i) {\r\n                    var k = Math.pow(10, Math.abs(8 - i) * 3);\r\n                    return {\r\n                        scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; },\r\n                        symbol: d\r\n                    };\r\n                });\r\n\r\n                var i = 0;\r\n                if (value) {\r\n                    if (value < 0) value *= -1;\r\n                    if (precision) value = this.round(value, this.precision(value, precision));\r\n                    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\r\n                    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\r\n                }\r\n                return prefixes[8 + i / 3];\r\n            }\r\n        },\r\n\r\n        /*\r\n            Pre-compile the HTML to be used as a template.\r\n        */\r\n        template: function(html) {\r\n\r\n            /*\r\n                Must support the variation in templating syntax found here:\r\n                https://lodash.com/docs#template\r\n            */\r\n            var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^\\{\\} ]+) ?\\}|\\{\\{([^\\{\\} ]+)\\}\\}/g;\r\n\r\n            return function(data) {\r\n\r\n                data = data || {};\r\n\r\n                return html.replace(regex, function(match) {\r\n\r\n                    var args = Array.prototype.slice.call(arguments);\r\n                    var attr = _.find(args.slice(1, 4), function(_attr) {\r\n                        return !!_attr;\r\n                    });\r\n\r\n                    var attrArray = attr.split('.');\r\n                    var value = data[attrArray.shift()];\r\n\r\n                    while (!_.isUndefined(value) && attrArray.length) {\r\n                        value = value[attrArray.shift()];\r\n                    }\r\n\r\n                    return !_.isUndefined(value) ? value : '';\r\n                });\r\n            };\r\n        },\r\n\r\n        /**\r\n         * @param {Element=} el Element, which content is intent to display in full-screen mode, 'document.body' is default.\r\n         */\r\n        toggleFullScreen: function(el) {\r\n\r\n            el = el || document.body;\r\n\r\n            function prefixedResult(el, prop) {\r\n\r\n                var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\r\n                for (var i = 0; i < prefixes.length; i++) {\r\n                    var prefix = prefixes[i];\r\n                    var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\r\n                    if (!_.isUndefined(el[propName])) {\r\n                        return _.isFunction(el[propName]) ? el[propName]() : el[propName];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (prefixedResult(document, 'FullscreenElement') || prefixedResult(document, 'FullScreenElement')) {\r\n                prefixedResult(document, 'ExitFullscreen') || // Spec.\r\n                prefixedResult(document, 'CancelFullScreen'); // Firefox\r\n            } else {\r\n                prefixedResult(el, 'RequestFullscreen') || // Spec.\r\n                prefixedResult(el, 'RequestFullScreen'); // Firefox\r\n            }\r\n        },\r\n\r\n        addClassNamePrefix: function(className) {\r\n\r\n            if (!className) return className;\r\n\r\n            return _.map(className.toString().split(' '), function(_className) {\r\n\r\n                if (_className.substr(0, joint.config.classNamePrefix.length) !== joint.config.classNamePrefix) {\r\n                    _className = joint.config.classNamePrefix + _className;\r\n                }\r\n\r\n                return _className;\r\n\r\n            }).join(' ');\r\n        },\r\n\r\n        removeClassNamePrefix: function(className) {\r\n\r\n            if (!className) return className;\r\n\r\n            return _.map(className.toString().split(' '), function(_className) {\r\n\r\n                if (_className.substr(0, joint.config.classNamePrefix.length) === joint.config.classNamePrefix) {\r\n                    _className = _className.substr(joint.config.classNamePrefix.length);\r\n                }\r\n\r\n                return _className;\r\n\r\n            }).join(' ');\r\n        },\r\n\r\n        wrapWith: function(object, methods, wrapper) {\r\n\r\n            if (_.isString(wrapper)) {\r\n\r\n                if (!joint.util.wrappers[wrapper]) {\r\n                    throw new Error('Unknown wrapper: \"' + wrapper + '\"');\r\n                }\r\n\r\n                wrapper = joint.util.wrappers[wrapper];\r\n            }\r\n\r\n            if (!_.isFunction(wrapper)) {\r\n                throw new Error('Wrapper must be a function.');\r\n            }\r\n\r\n            _.each(methods, function(method) {\r\n                object[method] = wrapper(object[method]);\r\n            });\r\n        },\r\n\r\n        wrappers: {\r\n\r\n            /*\r\n                Prepares a function with the following usage:\r\n\r\n                    fn([cell, cell, cell], opt);\r\n                    fn([cell, cell, cell]);\r\n                    fn(cell, cell, cell, opt);\r\n                    fn(cell, cell, cell);\r\n                    fn(cell);\r\n            */\r\n            cells: function(fn) {\r\n\r\n                return function() {\r\n\r\n                    var args = Array.prototype.slice.call(arguments);\r\n                    var cells = args.length > 0 && _.first(args) || [];\r\n                    var opt = args.length > 1 && _.last(args) || {};\r\n\r\n                    if (!_.isArray(cells)) {\r\n\r\n                        if (opt instanceof joint.dia.Cell) {\r\n                            cells = args;\r\n                        } else if (cells instanceof joint.dia.Cell) {\r\n                            cells = args.length > 1 ? _.initial(args) : args;\r\n                        }\r\n                    }\r\n\r\n                    if (opt instanceof joint.dia.Cell) {\r\n                        opt = {};\r\n                    }\r\n\r\n                    return fn.call(this, cells, opt);\r\n                };\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n\r\njoint.mvc.View = Backbone.View.extend({\r\n\r\n    options: {},\r\n    theme: null,\r\n    themeClassNamePrefix: joint.util.addClassNamePrefix('theme-'),\r\n    requireSetThemeOverride: false,\r\n    defaultTheme: joint.config.defaultTheme,\r\n\r\n    constructor: function(options) {\r\n\r\n        Backbone.View.call(this, options);\r\n    },\r\n\r\n    initialize: function(options) {\r\n\r\n        this.requireSetThemeOverride = options && !!options.theme;\r\n\r\n        this.options = _.extend({}, this.options, options);\r\n\r\n        _.bindAll(this, 'setTheme', 'onSetTheme', 'remove', 'onRemove');\r\n\r\n        joint.mvc.views[this.cid] = this;\r\n\r\n        this.setTheme(this.options.theme || this.defaultTheme);\r\n        this._ensureElClassName();\r\n        this.init();\r\n    },\r\n\r\n    // Override the Backbone `_ensureElement()` method in order to create an\r\n    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\r\n    _ensureElement: function() {\r\n        var el;\r\n\r\n        if (this.svgElement) {\r\n\r\n            if (!this.el) {\r\n\r\n                var attrs = _.extend({ id: this.id }, _.result(this, 'attributes'));\r\n                if (this.className) attrs['class'] = _.result(this, 'className');\r\n                el = V(_.result(this, 'tagName'), attrs).node;\r\n\r\n            } else {\r\n\r\n                el = _.result(this, 'el');\r\n            }\r\n\r\n            this.setElement(el, false);\r\n\r\n        } else {\r\n\r\n            Backbone.View.prototype._ensureElement.call(this);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    // Utilize an alternative DOM manipulation API by\r\n    // adding an element reference wrapped in Vectorizer.\r\n    _setElement: function(el) {\r\n\r\n        if (this.svgElement) {\r\n\r\n            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\r\n            this.el = this.$el[0];\r\n            this.vel = V(this.el);\r\n\r\n        } else {\r\n\r\n            Backbone.View.prototype._setElement.call(this, el);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    _ensureElClassName: function() {\r\n\r\n        var className = _.result(this, 'className');\r\n        var prefixedClassName = joint.util.addClassNamePrefix(className);\r\n\r\n        this.$el.removeClass(className);\r\n        this.$el.addClass(prefixedClassName);\r\n    },\r\n\r\n    init: function() {\r\n        // Intentionally empty.\r\n        // This method is meant to be overriden.\r\n    },\r\n\r\n    onRender: function() {\r\n        // Intentionally empty.\r\n        // This method is meant to be overriden.\r\n    },\r\n\r\n    setTheme: function(theme, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        // Theme is already set, override is required, and override has not been set.\r\n        // Don't set the theme.\r\n        if (this.theme && this.requireSetThemeOverride && !opt.override) {\r\n            return this;\r\n        }\r\n\r\n        this.removeThemeClassName();\r\n        this.addThemeClassName(theme);\r\n        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\r\n        this.theme = theme;\r\n\r\n        return this;\r\n    },\r\n\r\n    addThemeClassName: function(theme) {\r\n\r\n        theme = theme || this.theme;\r\n\r\n        var className = this.themeClassNamePrefix + theme;\r\n\r\n        this.$el.addClass(className);\r\n\r\n        return this;\r\n    },\r\n\r\n    removeThemeClassName: function(theme) {\r\n\r\n        theme = theme || this.theme;\r\n\r\n        var className = this.themeClassNamePrefix + theme;\r\n\r\n        this.$el.removeClass(className);\r\n\r\n        return this;\r\n    },\r\n\r\n    onSetTheme: function(oldTheme, newTheme) {\r\n        // Intentionally empty.\r\n        // This method is meant to be overriden.\r\n    },\r\n\r\n    remove: function() {\r\n\r\n        this.onRemove();\r\n\r\n        joint.mvc.views[this.cid] = null;\r\n\r\n        Backbone.View.prototype.remove.apply(this, arguments);\r\n\r\n        return this;\r\n    },\r\n\r\n    onRemove: function() {\r\n        // Intentionally empty.\r\n        // This method is meant to be overriden.\r\n    },\r\n\r\n    getEventNamespace: function() {\r\n        // Returns a per-session unique namespace\r\n        return '.joint-event-ns-' + this.cid;\r\n    }\r\n\r\n}, {\r\n\r\n    extend: function() {\r\n\r\n        var args = Array.prototype.slice.call(arguments);\r\n\r\n        // Deep clone the prototype and static properties objects.\r\n        // This prevents unexpected behavior where some properties are overwritten outside of this function.\r\n        var protoProps = args[0] && _.clone(args[0]) || {};\r\n        var staticProps = args[1] && _.clone(args[1]) || {};\r\n\r\n        // Need the real render method so that we can wrap it and call it later.\r\n        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\r\n\r\n        /*\r\n            Wrap the real render method so that:\r\n                .. `onRender` is always called.\r\n                .. `this` is always returned.\r\n        */\r\n        protoProps.render = function() {\r\n\r\n            if (renderFn) {\r\n                // Call the original render method.\r\n                renderFn.apply(this, arguments);\r\n            }\r\n\r\n            // Should always call onRender() method.\r\n            this.onRender();\r\n\r\n            // Should always return itself.\r\n            return this;\r\n        };\r\n\r\n        return Backbone.View.extend.call(this, protoProps, staticProps);\r\n    }\r\n});\r\n\r\n\r\n\r\njoint.dia.GraphCells = Backbone.Collection.extend({\r\n\r\n    cellNamespace: joint.shapes,\r\n\r\n    initialize: function(models, opt) {\r\n\r\n        // Set the optional namespace where all model classes are defined.\r\n        if (opt.cellNamespace) {\r\n            this.cellNamespace = opt.cellNamespace;\r\n        }\r\n\r\n        this.graph = opt.graph;\r\n    },\r\n\r\n    model: function(attrs, options) {\r\n\r\n        var collection = options.collection;\r\n        var namespace = collection.cellNamespace;\r\n\r\n        // Find the model class in the namespace or use the default one.\r\n        var ModelClass = (attrs.type === 'link')\r\n            ? joint.dia.Link\r\n            : joint.util.getByPath(namespace, attrs.type, '.') || joint.dia.Element;\r\n\r\n        var cell = new ModelClass(attrs, options);\r\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\r\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\r\n        cell.graph = collection.graph;\r\n\r\n        return cell;\r\n    },\r\n\r\n    // `comparator` makes it easy to sort cells based on their `z` index.\r\n    comparator: function(model) {\r\n\r\n        return model.get('z') || 0;\r\n    }\r\n});\r\n\r\n\r\njoint.dia.Graph = Backbone.Model.extend({\r\n\r\n    _batches: {},\r\n\r\n    initialize: function(attrs, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        // Passing `cellModel` function in the options object to graph allows for\r\n        // setting models based on attribute objects. This is especially handy\r\n        // when processing JSON graphs that are in a different than JointJS format.\r\n        var cells = new joint.dia.GraphCells([], {\r\n            model: opt.cellModel,\r\n            cellNamespace: opt.cellNamespace,\r\n            graph: this\r\n        });\r\n        Backbone.Model.prototype.set.call(this, 'cells', cells);\r\n\r\n        // Make all the events fired in the `cells` collection available.\r\n        // to the outside world.\r\n        cells.on('all', this.trigger, this);\r\n\r\n        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\r\n        // they're already in the collection. Therefore, we're triggering sort manually here.\r\n        this.on('change:z', this._sortOnChangeZ, this);\r\n        this.on('batch:stop', this._onBatchStop, this);\r\n\r\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\r\n        // for fast graph queries. All changes that affect the structure of the graph\r\n        // must be reflected in the `al` object. This object provides fast answers to\r\n        // questions such as \"what are the neighbours of this node\" or \"what\r\n        // are the sibling links of this link\".\r\n\r\n        // Outgoing edges per node. Note that we use a hash-table for the list\r\n        // of outgoing edges for a faster lookup.\r\n        // [node ID] -> Object [edge] -> true\r\n        this._out = {};\r\n        // Ingoing edges per node.\r\n        // [node ID] -> Object [edge] -> true\r\n        this._in = {};\r\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\r\n        // having to go through the whole cells array.\r\n        // [node ID] -> true\r\n        this._nodes = {};\r\n        // `_edges` is useful for quick lookup of all the links in the graph, without\r\n        // having to go through the whole cells array.\r\n        // [edge ID] -> true\r\n        this._edges = {};\r\n\r\n        cells.on('add', this._restructureOnAdd, this);\r\n        cells.on('remove', this._restructureOnRemove, this);\r\n        cells.on('reset', this._restructureOnReset, this);\r\n        cells.on('change:source', this._restructureOnChangeSource, this);\r\n        cells.on('change:target', this._restructureOnChangeTarget, this);\r\n        cells.on('remove', this._removeCell, this);\r\n    },\r\n\r\n    _sortOnChangeZ: function() {\r\n\r\n        if (!this.hasActiveBatch('to-front') && !this.hasActiveBatch('to-back')) {\r\n            this.get('cells').sort();\r\n        }\r\n    },\r\n\r\n    _onBatchStop: function(data) {\r\n\r\n        var batchName = data && data.batchName;\r\n        if ((batchName === 'to-front' || batchName === 'to-back') && !this.hasActiveBatch(batchName)) {\r\n            this.get('cells').sort();\r\n        }\r\n    },\r\n\r\n    _restructureOnAdd: function(cell) {\r\n\r\n        if (cell.isLink()) {\r\n            this._edges[cell.id] = true;\r\n            var source = cell.get('source');\r\n            var target = cell.get('target');\r\n            if (source.id) {\r\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\r\n            }\r\n            if (target.id) {\r\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\r\n            }\r\n        } else {\r\n            this._nodes[cell.id] = true;\r\n        }\r\n    },\r\n\r\n    _restructureOnRemove: function(cell) {\r\n\r\n        if (cell.isLink()) {\r\n            delete this._edges[cell.id];\r\n            var source = cell.get('source');\r\n            var target = cell.get('target');\r\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\r\n                delete this._out[source.id][cell.id];\r\n            }\r\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\r\n                delete this._in[target.id][cell.id];\r\n            }\r\n        } else {\r\n            delete this._nodes[cell.id];\r\n        }\r\n    },\r\n\r\n    _restructureOnReset: function(cells) {\r\n\r\n        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\r\n        cells = cells.models;\r\n\r\n        this._out = {};\r\n        this._in = {};\r\n        this._nodes = {};\r\n        this._edges = {};\r\n\r\n        _.each(cells, this._restructureOnAdd, this);\r\n    },\r\n\r\n    _restructureOnChangeSource: function(link) {\r\n\r\n        var prevSource = link.previous('source');\r\n        if (prevSource.id && this._out[prevSource.id]) {\r\n            delete this._out[prevSource.id][link.id];\r\n        }\r\n        var source = link.get('source');\r\n        if (source.id) {\r\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\r\n        }\r\n    },\r\n\r\n    _restructureOnChangeTarget: function(link) {\r\n\r\n        var prevTarget = link.previous('target');\r\n        if (prevTarget.id && this._in[prevTarget.id]) {\r\n            delete this._in[prevTarget.id][link.id];\r\n        }\r\n        var target = link.get('target');\r\n        if (target.id) {\r\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\r\n        }\r\n    },\r\n\r\n    // Return all outbound edges for the node. Return value is an object\r\n    // of the form: [edge] -> true\r\n    getOutboundEdges: function(node) {\r\n\r\n        return (this._out && this._out[node]) || {};\r\n    },\r\n\r\n    // Return all inbound edges for the node. Return value is an object\r\n    // of the form: [edge] -> true\r\n    getInboundEdges: function(node) {\r\n\r\n        return (this._in && this._in[node]) || {};\r\n    },\r\n\r\n    toJSON: function() {\r\n\r\n        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\r\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitely.\r\n        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\r\n        json.cells = this.get('cells').toJSON();\r\n        return json;\r\n    },\r\n\r\n    fromJSON: function(json, opt) {\r\n\r\n        if (!json.cells) {\r\n\r\n            throw new Error('Graph JSON must contain cells array.');\r\n        }\r\n\r\n        return this.set(json, opt);\r\n    },\r\n\r\n    set: function(key, val, opt) {\r\n\r\n        var attrs;\r\n\r\n        // Handle both `key`, value and {key: value} style arguments.\r\n        if (typeof key === 'object') {\r\n            attrs = key;\r\n            opt = val;\r\n        } else {\r\n            (attrs = {})[key] = val;\r\n        }\r\n\r\n        // Make sure that `cells` attribute is handled separately via resetCells().\r\n        if (attrs.hasOwnProperty('cells')) {\r\n            this.resetCells(attrs.cells, opt);\r\n            attrs = _.omit(attrs, 'cells');\r\n        }\r\n\r\n        // The rest of the attributes are applied via original set method.\r\n        return Backbone.Model.prototype.set.call(this, attrs, opt);\r\n    },\r\n\r\n    clear: function(opt) {\r\n\r\n        opt = _.extend({}, opt, { clear: true });\r\n\r\n        var collection = this.get('cells');\r\n\r\n        if (collection.length === 0) return this;\r\n\r\n        this.startBatch('clear', opt);\r\n\r\n        // The elements come after the links.\r\n        var cells = collection.sortBy(function(cell) {\r\n            return cell.isLink() ? 1 : 2;\r\n        });\r\n\r\n        do {\r\n\r\n            // Remove all the cells one by one.\r\n            // Note that all the links are removed first, so it's\r\n            // safe to remove the elements without removing the connected\r\n            // links first.\r\n            cells.shift().remove(opt);\r\n\r\n        } while (cells.length > 0);\r\n\r\n        this.stopBatch('clear');\r\n\r\n        return this;\r\n    },\r\n\r\n    _prepareCell: function(cell, opt) {\r\n\r\n        var attrs;\r\n        if (cell instanceof Backbone.Model) {\r\n            attrs = cell.attributes;\r\n            if (!cell.graph && (!opt || !opt.dry)) {\r\n                // An element can not be member of more than one graph.\r\n                // A cell stops being the member of the graph after it's explicitely removed.\r\n                cell.graph = this;\r\n            }\r\n        } else {\r\n            // In case we're dealing with a plain JS object, we have to set the reference\r\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\r\n            // of `joint.dia.GraphCells`.\r\n            attrs = cell;\r\n        }\r\n\r\n        if (!_.isString(attrs.type)) {\r\n            throw new TypeError('dia.Graph: cell type must be a string.');\r\n        }\r\n\r\n        return cell;\r\n    },\r\n\r\n    maxZIndex: function() {\r\n\r\n        var lastCell = this.get('cells').last();\r\n        return lastCell ? (lastCell.get('z') || 0) : 0;\r\n    },\r\n\r\n    addCell: function(cell, opt) {\r\n\r\n        if (_.isArray(cell)) {\r\n\r\n            return this.addCells(cell, opt);\r\n        }\r\n\r\n        if (cell instanceof Backbone.Model) {\r\n\r\n            if (!cell.has('z')) {\r\n                cell.set('z', this.maxZIndex() + 1);\r\n            }\r\n\r\n        } else if (_.isUndefined(cell.z)) {\r\n\r\n            cell.z = this.maxZIndex() + 1;\r\n        }\r\n\r\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\r\n\r\n        return this;\r\n    },\r\n\r\n    addCells: function(cells, opt) {\r\n\r\n        if (cells.length) {\r\n\r\n            cells = _.flattenDeep(cells);\r\n            opt.position = cells.length;\r\n\r\n            this.startBatch('add');\r\n            _.each(cells, function(cell) {\r\n                opt.position--;\r\n                this.addCell(cell, opt);\r\n            }, this);\r\n            this.stopBatch('add');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // When adding a lot of cells, it is much more efficient to\r\n    // reset the entire cells collection in one go.\r\n    // Useful for bulk operations and optimizations.\r\n    resetCells: function(cells, opt) {\r\n\r\n        var preparedCells = _.map(cells, _.bind(this._prepareCell, this, _, opt));\r\n        this.get('cells').reset(preparedCells, opt);\r\n\r\n        return this;\r\n    },\r\n\r\n    removeCells: function(cells, opt) {\r\n\r\n        if (cells.length) {\r\n\r\n            this.startBatch('remove');\r\n            _.invoke(cells, 'remove', opt);\r\n            this.stopBatch('remove');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    _removeCell: function(cell, collection, options) {\r\n\r\n        options = options || {};\r\n\r\n        if (!options.clear) {\r\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\r\n            // disconnect links when a cell is removed rather then removing them. The default\r\n            // is to remove all the associated links.\r\n            if (options.disconnectLinks) {\r\n\r\n                this.disconnectLinks(cell, options);\r\n\r\n            } else {\r\n\r\n                this.removeLinks(cell, options);\r\n            }\r\n        }\r\n        // Silently remove the cell from the cells collection. Silently, because\r\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\r\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\r\n        // would be triggered on the graph model.\r\n        this.get('cells').remove(cell, { silent: true });\r\n\r\n        if (cell.graph === this) {\r\n            // Remove the element graph reference only if the cell is the member of this graph.\r\n            cell.graph = null;\r\n        }\r\n    },\r\n\r\n    // Get a cell by `id`.\r\n    getCell: function(id) {\r\n\r\n        return this.get('cells').get(id);\r\n    },\r\n\r\n    getCells: function() {\r\n\r\n        return this.get('cells').toArray();\r\n    },\r\n\r\n    getElements: function() {\r\n\r\n        return _.map(this._nodes, function(exists, node) { return this.getCell(node); }, this);\r\n    },\r\n\r\n    getLinks: function() {\r\n\r\n        return _.map(this._edges, function(exists, edge) { return this.getCell(edge); }, this);\r\n    },\r\n\r\n    getFirstCell: function() {\r\n\r\n        return this.get('cells').first();\r\n    },\r\n\r\n    getLastCell: function() {\r\n\r\n        return this.get('cells').last();\r\n    },\r\n\r\n    // Get all inbound and outbound links connected to the cell `model`.\r\n    getConnectedLinks: function(model, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var inbound = opt.inbound;\r\n        var outbound = opt.outbound;\r\n        if (_.isUndefined(inbound) && _.isUndefined(outbound)) {\r\n            inbound = outbound = true;\r\n        }\r\n\r\n        // The final array of connected link models.\r\n        var links = [];\r\n        // Connected edges. This hash table ([edge] -> true) serves only\r\n        // for a quick lookup to check if we already added a link.\r\n        var edges = {};\r\n\r\n        if (outbound) {\r\n            _.each(this.getOutboundEdges(model.id), function(exists, edge) {\r\n                if (!edges[edge]) {\r\n                    links.push(this.getCell(edge));\r\n                    edges[edge] = true;\r\n                }\r\n            }, this);\r\n        }\r\n        if (inbound) {\r\n            _.each(this.getInboundEdges(model.id), function(exists, edge) {\r\n                // Skip links that were already added. Those must be self-loop links\r\n                // because they are both inbound and outbond edges of the same element.\r\n                if (!edges[edge]) {\r\n                    links.push(this.getCell(edge));\r\n                    edges[edge] = true;\r\n                }\r\n            }, this);\r\n        }\r\n\r\n        // If 'deep' option is 'true', return all the links that are connected to any of the descendent cells\r\n        // and are not descendents themselves.\r\n        if (opt.deep) {\r\n\r\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\r\n            // In the first round, we collect all the embedded edges so that we can exclude\r\n            // them from the final result.\r\n            var embeddedEdges = {};\r\n            _.each(embeddedCells, function(cell) {\r\n                if (cell.isLink()) {\r\n                    embeddedEdges[cell.id] = true;\r\n                }\r\n            });\r\n            _.each(embeddedCells, function(cell) {\r\n                if (cell.isLink()) return;\r\n                if (outbound) {\r\n                    _.each(this.getOutboundEdges(cell.id), function(exists, edge) {\r\n                        if (!edges[edge] && !embeddedEdges[edge]) {\r\n                            links.push(this.getCell(edge));\r\n                            edges[edge] = true;\r\n                        }\r\n                    }, this);\r\n                }\r\n                if (inbound) {\r\n                    _.each(this.getInboundEdges(cell.id), function(exists, edge) {\r\n                        if (!edges[edge] && !embeddedEdges[edge]) {\r\n                            links.push(this.getCell(edge));\r\n                            edges[edge] = true;\r\n                        }\r\n                    }, this);\r\n                }\r\n            }, this);\r\n        }\r\n\r\n        return links;\r\n    },\r\n\r\n    getNeighbors: function(model, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var inbound = opt.inbound;\r\n        var outbound = opt.outbound;\r\n        if (_.isUndefined(inbound) && _.isUndefined(outbound)) {\r\n            inbound = outbound = true;\r\n        }\r\n\r\n        var neighbors = _.transform(this.getConnectedLinks(model, opt), function(res, link) {\r\n\r\n            var source = link.get('source');\r\n            var target = link.get('target');\r\n            var loop = link.hasLoop(opt);\r\n\r\n            // Discard if it is a point, or if the neighbor was already added.\r\n            if (inbound && _.has(source, 'id') && !res[source.id]) {\r\n\r\n                var sourceElement = this.getCell(source.id);\r\n\r\n                if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\r\n                    res[source.id] = sourceElement;\r\n                }\r\n            }\r\n\r\n            // Discard if it is a point, or if the neighbor was already added.\r\n            if (outbound && _.has(target, 'id') && !res[target.id]) {\r\n\r\n                var targetElement = this.getCell(target.id);\r\n\r\n                if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\r\n                    res[target.id] = targetElement;\r\n                }\r\n            }\r\n\r\n        }, {}, this);\r\n\r\n        return _.values(neighbors);\r\n    },\r\n\r\n    getCommonAncestor: function(/* cells */) {\r\n\r\n        var cellsAncestors = _.map(arguments, function(cell) {\r\n\r\n            var ancestors = [];\r\n            var parentId = cell.get('parent');\r\n\r\n            while (parentId) {\r\n\r\n                ancestors.push(parentId);\r\n                parentId = this.getCell(parentId).get('parent');\r\n            }\r\n\r\n            return ancestors;\r\n\r\n        }, this);\r\n\r\n        cellsAncestors = _.sortBy(cellsAncestors, 'length');\r\n\r\n        var commonAncestor = _.find(cellsAncestors.shift(), function(ancestor) {\r\n\r\n            return _.every(cellsAncestors, function(cellAncestors) {\r\n                return _.contains(cellAncestors, ancestor);\r\n            });\r\n        });\r\n\r\n        return this.getCell(commonAncestor);\r\n    },\r\n\r\n    // Find the whole branch starting at `element`.\r\n    // If `opt.deep` is `true`, take into account embedded elements too.\r\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\r\n    getSuccessors: function(element, opt) {\r\n\r\n        opt = opt || {};\r\n        var res = [];\r\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\r\n        this.search(element, function(el) {\r\n            if (el !== element) {\r\n                res.push(el);\r\n            }\r\n        }, _.extend({}, opt, { outbound: true }));\r\n        return res;\r\n    },\r\n\r\n    // Clone `cells` returning an object that maps the original cell ID to the clone. The number\r\n    // of clones is exactly the same as the `cells.length`.\r\n    // This function simply clones all the `cells`. However, it also reconstructs\r\n    // all the `source/target` and `parent/embed` references within the `cells`.\r\n    // This is the main difference from the `cell.clone()` method. The\r\n    // `cell.clone()` method works on one single cell only.\r\n    // For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\r\n    // returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\r\n    // the source and target of the link `L2` is changed to point to `A2` and `B2`.\r\n    cloneCells: function(cells) {\r\n\r\n        cells = _.unique(cells);\r\n\r\n        // A map of the form [original cell ID] -> [clone] helping\r\n        // us to reconstruct references for source/target and parent/embeds.\r\n        // This is also the returned value.\r\n        var cloneMap = _.transform(cells, function(map, cell) {\r\n            map[cell.id] = cell.clone();\r\n        }, {});\r\n\r\n        _.each(cells, function(cell) {\r\n\r\n            var clone = cloneMap[cell.id];\r\n            // assert(clone exists)\r\n\r\n            if (clone.isLink()) {\r\n                var source = clone.get('source');\r\n                var target = clone.get('target');\r\n                if (source.id && cloneMap[source.id]) {\r\n                    // Source points to an element and the element is among the clones.\r\n                    // => Update the source of the cloned link.\r\n                    clone.prop('source/id', cloneMap[source.id].id);\r\n                }\r\n                if (target.id && cloneMap[target.id]) {\r\n                    // Target points to an element and the element is among the clones.\r\n                    // => Update the target of the cloned link.\r\n                    clone.prop('target/id', cloneMap[target.id].id);\r\n                }\r\n            }\r\n\r\n            // Find the parent of the original cell\r\n            var parent = cell.get('parent');\r\n            if (parent && cloneMap[parent]) {\r\n                clone.set('parent', cloneMap[parent].id);\r\n            }\r\n\r\n            // Find the embeds of the original cell\r\n            var embeds = _.reduce(cell.get('embeds'), function(newEmbeds, embed) {\r\n                // Embedded cells that are not being cloned can not be carried\r\n                // over with other embedded cells.\r\n                if (cloneMap[embed]) {\r\n                    newEmbeds.push(cloneMap[embed].id);\r\n                }\r\n                return newEmbeds;\r\n            }, []);\r\n\r\n            if (!_.isEmpty(embeds)) {\r\n                clone.set('embeds', embeds);\r\n            }\r\n        });\r\n\r\n        return cloneMap;\r\n    },\r\n\r\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\r\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\r\n    // Return a map of the form: [original cell ID] -> [clone].\r\n    cloneSubgraph: function(cells, opt) {\r\n\r\n        var subgraph = this.getSubgraph(cells, opt);\r\n        return this.cloneCells(subgraph);\r\n    },\r\n\r\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\r\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\r\n    // and all the links that connect any of the returned cells.\r\n    // For example, for a single shallow element, the result is that very same element.\r\n    // For two elements connected with a link: `A --- L ---> B`, the result for\r\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\r\n    getSubgraph: function(cells, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var subgraph = [];\r\n        // `cellMap` is used for a quick lookup of existance of a cell in the `cells` array.\r\n        var cellMap = {};\r\n        var elements = [];\r\n        var links = [];\r\n\r\n        _.each(cells, function(cell) {\r\n            if (!cellMap[cell.id]) {\r\n                subgraph.push(cell);\r\n                cellMap[cell.id] = cell;\r\n                if (cell.isLink()) {\r\n                    links.push(cell);\r\n                } else {\r\n                    elements.push(cell);\r\n                }\r\n            }\r\n\r\n            if (opt.deep) {\r\n                var embeds = cell.getEmbeddedCells({ deep: true });\r\n                _.each(embeds, function(embed) {\r\n                    if (!cellMap[embed.id]) {\r\n                        subgraph.push(embed);\r\n                        cellMap[embed.id] = embed;\r\n                        if (embed.isLink()) {\r\n                            links.push(embed);\r\n                        } else {\r\n                            elements.push(embed);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        _.each(links, function(link) {\r\n            // For links, return their source & target (if they are elements - not points).\r\n            var source = link.get('source');\r\n            var target = link.get('target');\r\n            if (source.id && !cellMap[source.id]) {\r\n                var sourceElement = this.getCell(source.id);\r\n                subgraph.push(sourceElement);\r\n                cellMap[sourceElement.id] = sourceElement;\r\n                elements.push(sourceElement);\r\n            }\r\n            if (target.id && !cellMap[target.id]) {\r\n                var targetElement = this.getCell(target.id);\r\n                subgraph.push(this.getCell(target.id));\r\n                cellMap[targetElement.id] = targetElement;\r\n                elements.push(targetElement);\r\n            }\r\n        }, this);\r\n\r\n        _.each(elements, function(element) {\r\n            // For elements, include their connected links if their source/target is in the subgraph;\r\n            var links = this.getConnectedLinks(element, opt);\r\n            _.each(links, function(link) {\r\n                var source = link.get('source');\r\n                var target = link.get('target');\r\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\r\n                    subgraph.push(link);\r\n                    cellMap[link.id] = link;\r\n                }\r\n            });\r\n        }, this);\r\n\r\n        return subgraph;\r\n    },\r\n\r\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\r\n    // If `opt.deep` is `true`, take into account embedded elements too.\r\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\r\n    getPredecessors: function(element, opt) {\r\n\r\n        opt = opt || {};\r\n        var res = [];\r\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\r\n        this.search(element, function(el) {\r\n            if (el !== element) {\r\n                res.push(el);\r\n            }\r\n        }, _.extend({}, opt, { inbound: true }));\r\n        return res;\r\n    },\r\n\r\n    // Perform search on the graph.\r\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\r\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\r\n    // If `opt.deep` is `true`, take into account embedded elements too.\r\n    // `iteratee` is a function of the form `function(element) {}`.\r\n    // If `iteratee` explicitely returns `false`, the searching stops.\r\n    search: function(element, iteratee, opt) {\r\n\r\n        opt = opt || {};\r\n        if (opt.breadthFirst) {\r\n            this.bfs(element, iteratee, opt);\r\n        } else {\r\n            this.dfs(element, iteratee, opt);\r\n        }\r\n    },\r\n\r\n    // Breadth-first search.\r\n    // If `opt.deep` is `true`, take into account embedded elements too.\r\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\r\n    // `iteratee` is a function of the form `function(element, distance) {}`.\r\n    // where `element` is the currently visited element and `distance` is the distance of that element\r\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\r\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\r\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\r\n    // If `iteratee` explicitely returns `false`, the searching stops.\r\n    bfs: function(element, iteratee, opt) {\r\n\r\n        opt = opt || {};\r\n        var visited = {};\r\n        var distance = {};\r\n        var queue = [];\r\n\r\n        queue.push(element);\r\n        distance[element.id] = 0;\r\n\r\n        while (queue.length > 0) {\r\n            var next = queue.shift();\r\n            if (!visited[next.id]) {\r\n                visited[next.id] = true;\r\n                if (iteratee(next, distance[next.id]) === false) return;\r\n                _.each(this.getNeighbors(next, opt), function(neighbor) {\r\n                    distance[neighbor.id] = distance[next.id] + 1;\r\n                    queue.push(neighbor);\r\n                });\r\n            }\r\n        }\r\n    },\r\n\r\n    // Depth-first search.\r\n    // If `opt.deep` is `true`, take into account embedded elements too.\r\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\r\n    // `iteratee` is a function of the form `function(element, distance) {}`.\r\n    // If `iteratee` explicitely returns `false`, the search stops.\r\n    dfs: function(element, iteratee, opt, _visited, _distance) {\r\n\r\n        opt = opt || {};\r\n        var visited = _visited || {};\r\n        var distance = _distance || 0;\r\n        if (iteratee(element, distance) === false) return;\r\n        visited[element.id] = true;\r\n\r\n        _.each(this.getNeighbors(element, opt), function(neighbor) {\r\n            if (!visited[neighbor.id]) {\r\n                this.dfs(neighbor, iteratee, opt, visited, distance + 1);\r\n            }\r\n        }, this);\r\n    },\r\n\r\n    // Get all the roots of the graph. Time complexity: O(|V|).\r\n    getSources: function() {\r\n\r\n        var sources = [];\r\n        _.each(this._nodes, function(exists, node) {\r\n            if (!this._in[node] || _.isEmpty(this._in[node])) {\r\n                sources.push(this.getCell(node));\r\n            }\r\n        }, this);\r\n        return sources;\r\n    },\r\n\r\n    // Get all the leafs of the graph. Time complexity: O(|V|).\r\n    getSinks: function() {\r\n\r\n        var sinks = [];\r\n        _.each(this._nodes, function(exists, node) {\r\n            if (!this._out[node] || _.isEmpty(this._out[node])) {\r\n                sinks.push(this.getCell(node));\r\n            }\r\n        }, this);\r\n        return sinks;\r\n    },\r\n\r\n    // Return `true` if `element` is a root. Time complexity: O(1).\r\n    isSource: function(element) {\r\n\r\n        return !this._in[element.id] || _.isEmpty(this._in[element.id]);\r\n    },\r\n\r\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\r\n    isSink: function(element) {\r\n\r\n        return !this._out[element.id] || _.isEmpty(this._out[element.id]);\r\n    },\r\n\r\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\r\n    isSuccessor: function(elementA, elementB) {\r\n\r\n        var isSuccessor = false;\r\n        this.search(elementA, function(element) {\r\n            if (element === elementB && element !== elementA) {\r\n                isSuccessor = true;\r\n                return false;\r\n            }\r\n        }, { outbound: true });\r\n        return isSuccessor;\r\n    },\r\n\r\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\r\n    isPredecessor: function(elementA, elementB) {\r\n\r\n        var isPredecessor = false;\r\n        this.search(elementA, function(element) {\r\n            if (element === elementB && element !== elementA) {\r\n                isPredecessor = true;\r\n                return false;\r\n            }\r\n        }, { inbound: true });\r\n        return isPredecessor;\r\n    },\r\n\r\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\r\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\r\n    // for more details.\r\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\r\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\r\n    isNeighbor: function(elementA, elementB, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var inbound = opt.inbound;\r\n        var outbound = opt.outbound;\r\n        if (_.isUndefined(inbound) && _.isUndefined(outbound)) {\r\n            inbound = outbound = true;\r\n        }\r\n\r\n        var isNeighbor = false;\r\n\r\n        _.each(this.getConnectedLinks(elementA, opt), function(link) {\r\n\r\n            var source = link.get('source');\r\n            var target = link.get('target');\r\n\r\n            // Discard if it is a point.\r\n            if (inbound && _.has(source, 'id') && source.id === elementB.id) {\r\n                isNeighbor = true;\r\n                return false;\r\n            }\r\n\r\n            // Discard if it is a point, or if the neighbor was already added.\r\n            if (outbound && _.has(target, 'id') && target.id === elementB.id) {\r\n                isNeighbor = true;\r\n                return false;\r\n            }\r\n        });\r\n\r\n        return isNeighbor;\r\n    },\r\n\r\n    // Disconnect links connected to the cell `model`.\r\n    disconnectLinks: function(model, options) {\r\n\r\n        _.each(this.getConnectedLinks(model), function(link) {\r\n\r\n            link.set(link.get('source').id === model.id ? 'source' : 'target', g.point(0, 0), options);\r\n        });\r\n    },\r\n\r\n    // Remove links connected to the cell `model` completely.\r\n    removeLinks: function(model, options) {\r\n\r\n        _.invoke(this.getConnectedLinks(model), 'remove', options);\r\n    },\r\n\r\n    // Find all elements at given point\r\n    findModelsFromPoint: function(p) {\r\n\r\n        return _.filter(this.getElements(), function(el) {\r\n            return el.getBBox().containsPoint(p);\r\n        });\r\n    },\r\n\r\n    // Find all elements in given area\r\n    findModelsInArea: function(rect, opt) {\r\n\r\n        rect = g.rect(rect);\r\n        opt = _.defaults(opt || {}, { strict: false });\r\n\r\n        var method = opt.strict ? 'containsRect' : 'intersect';\r\n\r\n        return _.filter(this.getElements(), function(el) {\r\n            return rect[method](el.getBBox());\r\n        });\r\n    },\r\n\r\n    // Find all elements under the given element.\r\n    findModelsUnderElement: function(element, opt) {\r\n\r\n        opt = _.defaults(opt || {}, { searchBy: 'bbox' });\r\n\r\n        var bbox = element.getBBox();\r\n        var elements = (opt.searchBy == 'bbox')\r\n            ? this.findModelsInArea(bbox)\r\n            : this.findModelsFromPoint(bbox[opt.searchBy]());\r\n\r\n        // don't account element itself or any of its descendents\r\n        return _.reject(elements, function(el) {\r\n            return element.id == el.id || el.isEmbeddedIn(element);\r\n        });\r\n    },\r\n\r\n\r\n    // Return bounding box of all elements.\r\n    getBBox: function(cells, opt) {\r\n\r\n        return this.getCellsBBox(cells || this.getElements(), opt);\r\n    },\r\n\r\n    // Return the bounding box of all cells in array provided.\r\n    // Links are being ignored.\r\n    getCellsBBox: function(cells, opt) {\r\n\r\n        return _.reduce(cells, function(memo, cell) {\r\n            if (cell.isLink()) return memo;\r\n            if (memo) {\r\n                return memo.union(cell.getBBox(opt));\r\n            } else {\r\n                return cell.getBBox(opt);\r\n            }\r\n        }, null);\r\n    },\r\n\r\n    translate: function(dx, dy, opt) {\r\n\r\n        // Don't translate cells that are embedded in any other cell.\r\n        var cells = _.reject(this.getCells(), function(cell) {\r\n            return cell.isEmbedded();\r\n        });\r\n\r\n        _.invoke(cells, 'translate', dx, dy, opt);\r\n    },\r\n\r\n    resize: function(width, height, opt) {\r\n\r\n        return this.resizeCells(width, height, this.getCells(), opt);\r\n    },\r\n\r\n    resizeCells: function(width, height, cells, opt) {\r\n\r\n        // `getBBox` method returns `null` if no elements provided.\r\n        // i.e. cells can be an array of links\r\n        var bbox = this.getCellsBBox(cells);\r\n        if (bbox) {\r\n            var sx = Math.max(width / bbox.width, 0);\r\n            var sy = Math.max(height / bbox.height, 0);\r\n            _.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    startBatch: function(name, data) {\r\n\r\n        data = data || {};\r\n        this._batches[name] = (this._batches[name] || 0) + 1;\r\n\r\n        return this.trigger('batch:start', _.extend({}, data, { batchName: name }));\r\n    },\r\n\r\n    stopBatch: function(name, data) {\r\n\r\n        data = data || {};\r\n        this._batches[name] = (this._batches[name] || 0) - 1;\r\n\r\n        return this.trigger('batch:stop', _.extend({}, data, { batchName: name }));\r\n    },\r\n\r\n    hasActiveBatch: function(name) {\r\n        if (name) {\r\n            return this._batches[name];\r\n        } else {\r\n            return _.any(this._batches, function(batches) { return batches > 0; });\r\n        }\r\n    }\r\n});\r\n\r\njoint.util.wrapWith(joint.dia.Graph.prototype, ['resetCells', 'addCells', 'removeCells'], 'cells');\r\n\r\n(function(joint, _, g, $) {\r\n\r\n    function isPercentage(val) {\r\n        return _.isString(val) && val.slice(-1) === '%';\r\n    }\r\n\r\n    function setWrapper(attrName, dimension) {\r\n        return function(value, refBBox) {\r\n            var isValuePercentage = isPercentage(value);\r\n            value = parseFloat(value);\r\n            if (isValuePercentage) {\r\n                value /= 100;\r\n            }\r\n\r\n            var attrs = {};\r\n            if (isFinite(value)) {\r\n                var attrValue = (isValuePercentage || value >= 0 && value <= 1)\r\n                    ? value * refBBox[dimension]\r\n                    : Math.max(value + refBBox[dimension], 0);\r\n                attrs[attrName] = attrValue;\r\n            }\r\n\r\n            return attrs;\r\n        };\r\n    }\r\n\r\n    function positionWrapper(axis, dimension, origin) {\r\n        return function(value, refBBox) {\r\n            var valuePercentage = isPercentage(value);\r\n            value = parseFloat(value);\r\n            if (valuePercentage) {\r\n                value /= 100;\r\n            }\r\n\r\n            var delta;\r\n            if (isFinite(value)) {\r\n                var refOrigin = refBBox[origin]();\r\n                if (valuePercentage || value > 0 && value < 1) {\r\n                    delta = refOrigin[axis] + refBBox[dimension] * value;\r\n                } else {\r\n                    delta = refOrigin[axis] + value;\r\n                }\r\n            }\r\n\r\n            var point = g.Point();\r\n            point[axis] = delta || 0;\r\n            return point;\r\n        };\r\n    }\r\n\r\n    function offsetWrapper(axis, dimension, corner) {\r\n        return function(value, nodeBBox) {\r\n            var delta;\r\n            if (value === 'middle') {\r\n                delta = nodeBBox[dimension] / 2;\r\n            } else if (value === corner) {\r\n                delta = nodeBBox[dimension];\r\n            } else if (isFinite(value)) {\r\n                // TODO: or not to do a breaking change?\r\n                delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\r\n            } else if (isPercentage(value)) {\r\n                delta = nodeBBox[dimension] * parseFloat(value) / 100;\r\n            } else {\r\n                delta = 0;\r\n            }\r\n\r\n            var point = g.Point();\r\n            point[axis] = -(nodeBBox[axis] + delta);\r\n            return point;\r\n        };\r\n    }\r\n\r\n    var attributesNS = joint.dia.attributes = {\r\n\r\n        xlinkHref: {\r\n            set: 'xlink:href'\r\n        },\r\n\r\n        xmlSpace: {\r\n            set: 'xml:space'\r\n        },\r\n\r\n        filter: {\r\n            qualify: _.isPlainObject,\r\n            set: function(filter) {\r\n                return 'url(#' + this.paper.defineFilter(filter) + ')';\r\n            }\r\n        },\r\n\r\n        fill: {\r\n            qualify: _.isPlainObject,\r\n            set: function(fill) {\r\n                return 'url(#' + this.paper.defineGradient(fill) + ')';\r\n            }\r\n        },\r\n\r\n        stroke: {\r\n            qualify: _.isPlainObject,\r\n            set: function(stroke) {\r\n                return 'url(#' + this.paper.defineGradient(stroke) + ')';\r\n            }\r\n        },\r\n\r\n        sourceMarker: {\r\n            qualify: _.isPlainObject,\r\n            set: function(marker) {\r\n                return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\r\n            }\r\n        },\r\n\r\n        targetMarker: {\r\n            qualify: _.isPlainObject,\r\n            set: function(marker) {\r\n                marker = _.assign({ transform: 'rotate(180)' }, marker);\r\n                return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\r\n            }\r\n        },\r\n\r\n        vertexMarker: {\r\n            qualify: _.isPlainObject,\r\n            set: function(marker) {\r\n                return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\r\n            }\r\n        },\r\n\r\n        text: {\r\n            set: function(text, refBBox, node, attrs) {\r\n                var $node = $(node);\r\n                var cacheName = 'joint-text';\r\n                var cache = $node.data(cacheName);\r\n                var textAttrs = _.pick(attrs, 'lineHeight', 'annotations', 'textPath');\r\n                var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\r\n                var textHash = JSON.stringify([text, textAttrs]);\r\n                // Update the text only if there was a change in the string\r\n                // or any of its attributes.\r\n                if (cache === undefined || cache !== textHash) {\r\n                    // Chrome bug:\r\n                    // Tspans positions defined as `em` are not updated\r\n                    // when container `font-size` change.\r\n                    if (fontSize) {\r\n                        node.setAttribute('font-size', fontSize);\r\n                    }\r\n                    V(node).text('' + text, textAttrs);\r\n                    $node.data(cacheName, textHash);\r\n                }\r\n            }\r\n        },\r\n\r\n        textWrap: {\r\n            qualify: _.isPlainObject,\r\n            set: function(value, refBBox, node, attrs) {\r\n                // option `width`\r\n                var width = value.width || 0;\r\n                if (isPercentage(width)) {\r\n                    refBBox.width *= parseFloat(width) / 100;\r\n                } else if (width <= 0) {\r\n                    refBBox.width += width;\r\n                } else {\r\n                    refBBox.width = width;\r\n                }\r\n                // option `height`\r\n                var height = value.height || 0;\r\n                if (isPercentage(height)) {\r\n                    refBBox.height *= parseFloat(height) / 100;\r\n                } else if (height <= 0) {\r\n                    refBBox.height += height;\r\n                } else {\r\n                    refBBox.height = height;\r\n                }\r\n                // option `text`\r\n                var wrappedText = joint.util.breakText('' + value.text, refBBox, {\r\n                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\r\n                    'font-size': attrs['font-size'] || attrs.fontSize,\r\n                    'font-family': attrs['font-family'] || attrs.fontFamily\r\n                }, {\r\n                    // Provide an existing SVG Document here\r\n                    // instead of creating a temporary one over again.\r\n                    svgDocument: this.paper.svg\r\n                });\r\n\r\n                V(node).text(wrappedText);\r\n            }\r\n        },\r\n\r\n        lineHeight: {\r\n            qualify: function(lineHeight, node, attrs) {\r\n                return (attrs.text !== undefined);\r\n            }\r\n        },\r\n\r\n        textPath: {\r\n            qualify: function(textPath, node, attrs) {\r\n                return (attrs.text !== undefined);\r\n            }\r\n        },\r\n\r\n        annotations: {\r\n            qualify: function(annotations, node, attrs) {\r\n                return (attrs.text !== undefined);\r\n            }\r\n        },\r\n\r\n        // `port` attribute contains the `id` of the port that the underlying magnet represents.\r\n        port: {\r\n            set: function(port) {\r\n                return (port === null || port.id === undefined) ? port : port.id;\r\n            }\r\n        },\r\n\r\n        // `style` attribute is special in the sense that it sets the CSS style of the subelement.\r\n        style: {\r\n            qualify: _.isPlainObject,\r\n            set: function(styles, refBBox, node) {\r\n                $(node).css(styles);\r\n            }\r\n        },\r\n\r\n        html: {\r\n            set: function(html, refBBox, node) {\r\n                $(node).html(html + '');\r\n            }\r\n        },\r\n\r\n        ref: {\r\n            // We do not set `ref` attribute directly on an element.\r\n            // The attribute itself does not qualify for relative positioning.\r\n        },\r\n\r\n        // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\r\n        // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\r\n        // otherwise, `refX` is the left coordinate of the bounding box\r\n\r\n        refX: {\r\n            position: positionWrapper('x', 'width', 'origin')\r\n        },\r\n\r\n        refY: {\r\n            position: positionWrapper('y', 'height', 'origin')\r\n        },\r\n\r\n        // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\r\n        // coordinate of the reference element.\r\n\r\n        refDx: {\r\n            position: positionWrapper('x', 'width', 'corner')\r\n        },\r\n\r\n        refDy: {\r\n            position: positionWrapper('y', 'height', 'corner')\r\n        },\r\n\r\n        // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\r\n        // the reference element size\r\n        // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\r\n        // val < 0 || val > 1  ref-height = -20 sets the height to the the ref. el. height shorter by 20\r\n\r\n        refWidth: {\r\n            set: setWrapper('width', 'width')\r\n        },\r\n\r\n        refHeight: {\r\n            set: setWrapper('height', 'height')\r\n        },\r\n\r\n        refRx: {\r\n            set: setWrapper('rx', 'width')\r\n        },\r\n\r\n        refRy: {\r\n            set: setWrapper('ry', 'height')\r\n        },\r\n\r\n        refCx: {\r\n            set: setWrapper('cx', 'width')\r\n        },\r\n\r\n        refCy: {\r\n            set: setWrapper('cy', 'height')\r\n        },\r\n\r\n        // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\r\n        // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\r\n\r\n        xAlignment: {\r\n            offset: offsetWrapper('x', 'width', 'right')\r\n        },\r\n\r\n        // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\r\n        // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\r\n\r\n        yAlignment: {\r\n            offset: offsetWrapper('y', 'height', 'bottom')\r\n        }\r\n    };\r\n\r\n    // This allows to combine both absolute and relative positioning\r\n    // refX: 50%, refX2: 20\r\n    attributesNS.refX2 = attributesNS.refX;\r\n    attributesNS.refY2 = attributesNS.refY;\r\n\r\n    // Aliases for backwards compatibility\r\n    attributesNS['ref-x'] = attributesNS.refX;\r\n    attributesNS['ref-y'] = attributesNS.refY;\r\n    attributesNS['ref-dy'] = attributesNS.refDy;\r\n    attributesNS['ref-dx'] = attributesNS.refDx;\r\n    attributesNS['ref-width'] = attributesNS.refWidth;\r\n    attributesNS['ref-height'] = attributesNS.refHeight;\r\n    attributesNS['x-alignment'] = attributesNS.xAlignment;\r\n    attributesNS['y-alignment'] = attributesNS.yAlignment;\r\n\r\n})(joint, _, g, $);\r\n\r\n\r\n// joint.dia.Cell base model.\r\n// --------------------------\r\n\r\njoint.dia.Cell = Backbone.Model.extend({\r\n\r\n    // This is the same as Backbone.Model with the only difference that is uses _.merge\r\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\r\n    constructor: function(attributes, options) {\r\n\r\n        var defaults;\r\n        var attrs = attributes || {};\r\n        this.cid = _.uniqueId('c');\r\n        this.attributes = {};\r\n        if (options && options.collection) this.collection = options.collection;\r\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\r\n        if ((defaults = _.result(this, 'defaults'))) {\r\n            //<custom code>\r\n            // Replaced the call to _.defaults with _.merge.\r\n            attrs = _.merge({}, defaults, attrs);\r\n            //</custom code>\r\n        }\r\n        this.set(attrs, options);\r\n        this.changed = {};\r\n        this.initialize.apply(this, arguments);\r\n    },\r\n\r\n    translate: function(dx, dy, opt) {\r\n\r\n        throw new Error('Must define a translate() method.');\r\n    },\r\n\r\n    toJSON: function() {\r\n\r\n        var defaultAttrs = this.constructor.prototype.defaults.attrs || {};\r\n        var attrs = this.attributes.attrs;\r\n        var finalAttrs = {};\r\n\r\n        // Loop through all the attributes and\r\n        // omit the default attributes as they are implicitly reconstructable by the cell 'type'.\r\n        _.each(attrs, function(attr, selector) {\r\n\r\n            var defaultAttr = defaultAttrs[selector];\r\n\r\n            _.each(attr, function(value, name) {\r\n\r\n                // attr is mainly flat though it might have one more level (consider the `style` attribute).\r\n                // Check if the `value` is object and if yes, go one level deep.\r\n                if (_.isObject(value) && !_.isArray(value)) {\r\n\r\n                    _.each(value, function(value2, name2) {\r\n\r\n                        if (!defaultAttr || !defaultAttr[name] || !_.isEqual(defaultAttr[name][name2], value2)) {\r\n\r\n                            finalAttrs[selector] = finalAttrs[selector] || {};\r\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\r\n                        }\r\n                    });\r\n\r\n                } else if (!defaultAttr || !_.isEqual(defaultAttr[name], value)) {\r\n                    // `value` is not an object, default attribute for such a selector does not exist\r\n                    // or it is different than the attribute value set on the model.\r\n\r\n                    finalAttrs[selector] = finalAttrs[selector] || {};\r\n                    finalAttrs[selector][name] = value;\r\n                }\r\n            });\r\n        });\r\n\r\n        var attributes = _.cloneDeep(_.omit(this.attributes, 'attrs'));\r\n        //var attributes = JSON.parse(JSON.stringify(_.omit(this.attributes, 'attrs')));\r\n        attributes.attrs = finalAttrs;\r\n\r\n        return attributes;\r\n    },\r\n\r\n    initialize: function(options) {\r\n\r\n        if (!options || !options.id) {\r\n\r\n            this.set('id', joint.util.uuid(), { silent: true });\r\n        }\r\n\r\n        this._transitionIds = {};\r\n\r\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\r\n        this.processPorts();\r\n        this.on('change:attrs', this.processPorts, this);\r\n    },\r\n\r\n    /**\r\n     * @deprecated\r\n     */\r\n    processPorts: function() {\r\n\r\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\r\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\r\n        // set to that port, we remove those links as well (to follow the same behaviour as\r\n        // with a removed element).\r\n\r\n        var previousPorts = this.ports;\r\n\r\n        // Collect ports from the `attrs` object.\r\n        var ports = {};\r\n        _.each(this.get('attrs'), function(attrs, selector) {\r\n\r\n            if (attrs && attrs.port) {\r\n\r\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\r\n                if (!_.isUndefined(attrs.port.id)) {\r\n                    ports[attrs.port.id] = attrs.port;\r\n                } else {\r\n                    ports[attrs.port] = { id: attrs.port };\r\n                }\r\n            }\r\n        });\r\n\r\n        // Collect ports that have been removed (compared to the previous ports) - if any.\r\n        // Use hash table for quick lookup.\r\n        var removedPorts = {};\r\n        _.each(previousPorts, function(port, id) {\r\n\r\n            if (!ports[id]) removedPorts[id] = true;\r\n        });\r\n\r\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\r\n        if (this.graph && !_.isEmpty(removedPorts)) {\r\n\r\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\r\n            _.each(inboundLinks, function(link) {\r\n\r\n                if (removedPorts[link.get('target').port]) link.remove();\r\n            });\r\n\r\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\r\n            _.each(outboundLinks, function(link) {\r\n\r\n                if (removedPorts[link.get('source').port]) link.remove();\r\n            });\r\n        }\r\n\r\n        // Update the `ports` object.\r\n        this.ports = ports;\r\n    },\r\n\r\n    remove: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        // Store the graph in a variable because `this.graph` won't' be accessbile after `this.trigger('remove', ...)` down below.\r\n        var graph = this.graph;\r\n        if (graph) {\r\n            graph.startBatch('remove');\r\n        }\r\n\r\n        // First, unembed this cell from its parent cell if there is one.\r\n        var parentCellId = this.get('parent');\r\n        if (parentCellId) {\r\n\r\n            var parentCell = graph && graph.getCell(parentCellId);\r\n            parentCell.unembed(this);\r\n        }\r\n\r\n        _.invoke(this.getEmbeddedCells(), 'remove', opt);\r\n\r\n        this.trigger('remove', this, this.collection, opt);\r\n\r\n        if (graph) {\r\n            graph.stopBatch('remove');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toFront: function(opt) {\r\n\r\n        if (this.graph) {\r\n\r\n            opt = opt || {};\r\n\r\n            var z = (this.graph.getLastCell().get('z') || 0) + 1;\r\n\r\n            this.startBatch('to-front').set('z', z, opt);\r\n\r\n            if (opt.deep) {\r\n\r\n                var cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\r\n                _.each(cells, function(cell) { cell.set('z', ++z, opt); });\r\n\r\n            }\r\n\r\n            this.stopBatch('to-front');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toBack: function(opt) {\r\n\r\n        if (this.graph) {\r\n\r\n            opt = opt || {};\r\n\r\n            var z = (this.graph.getFirstCell().get('z') || 0) - 1;\r\n\r\n            this.startBatch('to-back');\r\n\r\n            if (opt.deep) {\r\n\r\n                var cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\r\n                _.eachRight(cells, function(cell) { cell.set('z', z--, opt); });\r\n            }\r\n\r\n            this.set('z', z, opt).stopBatch('to-back');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    embed: function(cell, opt) {\r\n\r\n        if (this === cell || this.isEmbeddedIn(cell)) {\r\n\r\n            throw new Error('Recursive embedding not allowed.');\r\n\r\n        } else {\r\n\r\n            this.startBatch('embed');\r\n\r\n            var embeds = _.clone(this.get('embeds') || []);\r\n\r\n            // We keep all element ids after link ids.\r\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\r\n\r\n            cell.set('parent', this.id, opt);\r\n            this.set('embeds', _.uniq(embeds), opt);\r\n\r\n            this.stopBatch('embed');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    unembed: function(cell, opt) {\r\n\r\n        this.startBatch('unembed');\r\n\r\n        cell.unset('parent', opt);\r\n        this.set('embeds', _.without(this.get('embeds'), cell.id), opt);\r\n\r\n        this.stopBatch('unembed');\r\n\r\n        return this;\r\n    },\r\n\r\n    // Return an array of ancestor cells.\r\n    // The array is ordered from the parent of the cell\r\n    // to the most distant ancestor.\r\n    getAncestors: function() {\r\n\r\n        var ancestors = [];\r\n        var parentId = this.get('parent');\r\n\r\n        if (!this.graph) {\r\n            return ancestors;\r\n        }\r\n\r\n        while (parentId !== undefined) {\r\n            var parent = this.graph.getCell(parentId);\r\n            if (parent !== undefined) {\r\n                ancestors.push(parent);\r\n                parentId = parent.get('parent');\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return ancestors;\r\n    },\r\n\r\n    getEmbeddedCells: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        // Cell models can only be retrieved when this element is part of a collection.\r\n        // There is no way this element knows about other cells otherwise.\r\n        // This also means that calling e.g. `translate()` on an element with embeds before\r\n        // adding it to a graph does not translate its embeds.\r\n        if (this.graph) {\r\n\r\n            var cells;\r\n\r\n            if (opt.deep) {\r\n\r\n                if (opt.breadthFirst) {\r\n\r\n                    // breadthFirst algorithm\r\n                    cells = [];\r\n                    var queue = this.getEmbeddedCells();\r\n\r\n                    while (queue.length > 0) {\r\n\r\n                        var parent = queue.shift();\r\n                        cells.push(parent);\r\n                        queue.push.apply(queue, parent.getEmbeddedCells());\r\n                    }\r\n\r\n                } else {\r\n\r\n                    // depthFirst algorithm\r\n                    cells = this.getEmbeddedCells();\r\n                    _.each(cells, function(cell) {\r\n                        cells.push.apply(cells, cell.getEmbeddedCells(opt));\r\n                    });\r\n                }\r\n\r\n            } else {\r\n\r\n                cells = _.map(this.get('embeds'), this.graph.getCell, this.graph);\r\n            }\r\n\r\n            return cells;\r\n        }\r\n        return [];\r\n    },\r\n\r\n    isEmbeddedIn: function(cell, opt) {\r\n\r\n        var cellId = _.isString(cell) ? cell : cell.id;\r\n        var parentId = this.get('parent');\r\n\r\n        opt = _.defaults({ deep: true }, opt);\r\n\r\n        // See getEmbeddedCells().\r\n        if (this.graph && opt.deep) {\r\n\r\n            while (parentId) {\r\n                if (parentId === cellId) {\r\n                    return true;\r\n                }\r\n                parentId = this.graph.getCell(parentId).get('parent');\r\n            }\r\n\r\n            return false;\r\n\r\n        } else {\r\n\r\n            // When this cell is not part of a collection check\r\n            // at least whether it's a direct child of given cell.\r\n            return parentId === cellId;\r\n        }\r\n    },\r\n\r\n    // Whether or not the cell is embedded in any other cell.\r\n    isEmbedded: function() {\r\n\r\n        return !!this.get('parent');\r\n    },\r\n\r\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\r\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\r\n    // Deep cloning clones the cell and all its embedded cells recursively.\r\n    clone: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        if (!opt.deep) {\r\n            // Shallow cloning.\r\n\r\n            var clone = Backbone.Model.prototype.clone.apply(this, arguments);\r\n            // We don't want the clone to have the same ID as the original.\r\n            clone.set('id', joint.util.uuid());\r\n            // A shallow cloned element does not carry over the original embeds.\r\n            clone.unset('embeds');\r\n            // And can not be embedded in any cell\r\n            // as the clone is not part of the graph.\r\n            clone.unset('parent');\r\n\r\n            return clone;\r\n\r\n        } else {\r\n            // Deep cloning.\r\n\r\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\r\n            return _.values(joint.dia.Graph.prototype.cloneCells.call(null, [this].concat(this.getEmbeddedCells({ deep: true }))));\r\n        }\r\n    },\r\n\r\n    // A convenient way to set nested properties.\r\n    // This method merges the properties you'd like to set with the ones\r\n    // stored in the cell and makes sure change events are properly triggered.\r\n    // You can either set a nested property with one object\r\n    // or use a property path.\r\n    // The most simple use case is:\r\n    // `cell.prop('name/first', 'John')` or\r\n    // `cell.prop({ name: { first: 'John' } })`.\r\n    // Nested arrays are supported too:\r\n    // `cell.prop('series/0/data/0/degree', 50)` or\r\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\r\n    prop: function(props, value, opt) {\r\n\r\n        var delim = '/';\r\n        var isString = _.isString(props);\r\n\r\n        if (isString || _.isArray(props)) {\r\n            // Get/set an attribute by a special path syntax that delimits\r\n            // nested objects by the colon character.\r\n\r\n            if (arguments.length > 1) {\r\n\r\n                var path;\r\n                var pathArray;\r\n\r\n                if (isString) {\r\n                    path = props;\r\n                    pathArray = path.split('/')\r\n                } else {\r\n                    path = props.join(delim);\r\n                    pathArray = props.slice();\r\n                }\r\n\r\n                var property = pathArray[0];\r\n                var pathArrayLength = pathArray.length;\r\n\r\n                opt = opt || {};\r\n                opt.propertyPath = path;\r\n                opt.propertyValue = value;\r\n                opt.propertyPathArray = pathArray;\r\n\r\n                if (pathArrayLength === 1) {\r\n                    // Property is not nested. We can simply use `set()`.\r\n                    return this.set(property, value, opt);\r\n                }\r\n\r\n                var update = {};\r\n                // Initialize the nested object. Subobjects are either arrays or objects.\r\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\r\n                // Note that this imposes a limitation on object keys one can use with Inspector.\r\n                // Pure integer keys will cause issues and are therefore not allowed.\r\n                var initializer = update;\r\n                var prevProperty = property;\r\n\r\n                for (var i = 1; i < pathArrayLength; i++) {\r\n                    var pathItem = pathArray[i];\r\n                    var isArrayIndex = _.isFinite(isString ? Number(pathItem) : pathItem);\r\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\r\n                    prevProperty = pathItem;\r\n                }\r\n\r\n                // Fill update with the `value` on `path`.\r\n                update = joint.util.setByPath(update, pathArray, value, '/');\r\n\r\n                var baseAttributes = _.merge({}, this.attributes);\r\n                // if rewrite mode enabled, we replace value referenced by path with\r\n                // the new one (we don't merge).\r\n                opt.rewrite && joint.util.unsetByPath(baseAttributes, path, '/');\r\n\r\n                // Merge update with the model attributes.\r\n                var attributes = _.merge(baseAttributes, update);\r\n                // Finally, set the property to the updated attributes.\r\n                return this.set(property, attributes[property], opt);\r\n\r\n            } else {\r\n\r\n                return joint.util.getByPath(this.attributes, props, delim);\r\n            }\r\n        }\r\n\r\n        return this.set(_.merge({}, this.attributes, props), value);\r\n    },\r\n\r\n    // A convient way to unset nested properties\r\n    removeProp: function(path, opt) {\r\n\r\n        // Once a property is removed from the `attrs` attribute\r\n        // the cellView will recognize a `dirty` flag and rerender itself\r\n        // in order to remove the attribute from SVG element.\r\n        opt = opt || {};\r\n        opt.dirty = true;\r\n\r\n        var pathArray = _.isArray(path) ? path : path.split('/');\r\n\r\n        if (pathArray.length === 1) {\r\n            // A top level property\r\n            return this.unset(path, opt);\r\n        }\r\n\r\n        // A nested property\r\n        var property = pathArray[0];\r\n        var nestedPath = pathArray.slice(1);\r\n        var propertyValue = _.merge({}, this.get(property));\r\n\r\n        joint.util.unsetByPath(propertyValue, nestedPath, '/');\r\n\r\n        return this.set(property, propertyValue, opt);\r\n    },\r\n\r\n    // A convenient way to set nested attributes.\r\n    attr: function(attrs, value, opt) {\r\n\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (args.length === 0) {\r\n            return this.get('attrs');\r\n        }\r\n\r\n        if (_.isArray(attrs)) {\r\n            args[0] = ['attrs'].concat(attrs);\r\n        } else if (_.isString(attrs)) {\r\n            // Get/set an attribute by a special path syntax that delimits\r\n            // nested objects by the colon character.\r\n            args[0] = 'attrs/' + attrs;\r\n\r\n        } else {\r\n\r\n            args[0] = { 'attrs' : attrs };\r\n        }\r\n\r\n        return this.prop.apply(this, args);\r\n    },\r\n\r\n    // A convenient way to unset nested attributes\r\n    removeAttr: function(path, opt) {\r\n\r\n        if (_.isArray(path)) {\r\n\r\n            return this.removeProp(['attrs'].concat(path));\r\n        }\r\n\r\n        return this.removeProp('attrs/' + path, opt);\r\n    },\r\n\r\n    transition: function(path, value, opt, delim) {\r\n\r\n        delim = delim || '/';\r\n\r\n        var defaults = {\r\n            duration: 100,\r\n            delay: 10,\r\n            timingFunction: joint.util.timing.linear,\r\n            valueFunction: joint.util.interpolate.number\r\n        };\r\n\r\n        opt = _.extend(defaults, opt);\r\n\r\n        var firstFrameTime = 0;\r\n        var interpolatingFunction;\r\n\r\n        var setter = _.bind(function(runtime) {\r\n\r\n            var id, progress, propertyValue;\r\n\r\n            firstFrameTime = firstFrameTime || runtime;\r\n            runtime -= firstFrameTime;\r\n            progress = runtime / opt.duration;\r\n\r\n            if (progress < 1) {\r\n                this._transitionIds[path] = id = joint.util.nextFrame(setter);\r\n            } else {\r\n                progress = 1;\r\n                delete this._transitionIds[path];\r\n            }\r\n\r\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\r\n\r\n            opt.transitionId = id;\r\n\r\n            this.prop(path, propertyValue, opt);\r\n\r\n            if (!id) this.trigger('transition:end', this, path);\r\n\r\n        }, this);\r\n\r\n        var initiator = _.bind(function(callback) {\r\n\r\n            this.stopTransitions(path);\r\n\r\n            interpolatingFunction = opt.valueFunction(joint.util.getByPath(this.attributes, path, delim), value);\r\n\r\n            this._transitionIds[path] = joint.util.nextFrame(callback);\r\n\r\n            this.trigger('transition:start', this, path);\r\n\r\n        }, this);\r\n\r\n        return _.delay(initiator, opt.delay, setter);\r\n    },\r\n\r\n    getTransitions: function() {\r\n        return _.keys(this._transitionIds);\r\n    },\r\n\r\n    stopTransitions: function(path, delim) {\r\n\r\n        delim = delim || '/';\r\n\r\n        var pathArray = path && path.split(delim);\r\n\r\n        _(this._transitionIds).keys().filter(pathArray && function(key) {\r\n\r\n            return _.isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\r\n\r\n        }).each(function(key) {\r\n\r\n            joint.util.cancelFrame(this._transitionIds[key]);\r\n\r\n            delete this._transitionIds[key];\r\n\r\n            this.trigger('transition:end', this, key);\r\n\r\n        }, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    // A shorcut making it easy to create constructs like the following:\r\n    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\r\n    addTo: function(graph, opt) {\r\n\r\n        graph.addCell(this, opt);\r\n        return this;\r\n    },\r\n\r\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\r\n    // making it easy to create constructs like the following:\r\n    // `cell.findView(paper).highlight()`\r\n    findView: function(paper) {\r\n\r\n        return paper.findViewByModel(this);\r\n    },\r\n\r\n    isElement: function() {\r\n\r\n        return false;\r\n    },\r\n\r\n    isLink: function() {\r\n\r\n        return false;\r\n    },\r\n\r\n    startBatch: function(name, opt) {\r\n        if (this.graph) { this.graph.startBatch(name, _.extend({}, opt, { cell: this })); }\r\n        return this;\r\n    },\r\n\r\n    stopBatch: function(name, opt) {\r\n        if (this.graph) { this.graph.stopBatch(name, _.extend({}, opt, { cell: this })); }\r\n        return this;\r\n    }\r\n\r\n}, {\r\n\r\n    getAttributeDefinition: function(attrName) {\r\n\r\n        var defNS = this.attributes;\r\n        var globalDefNS = joint.dia.attributes;\r\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\r\n    },\r\n\r\n    define: function(type, defaults, protoProps, staticProps) {\r\n\r\n        protoProps = _.assign({\r\n            defaults: _.defaultsDeep({ type: type }, defaults, this.prototype.defaults)\r\n        }, protoProps);\r\n\r\n        var Cell = this.extend(protoProps, staticProps);\r\n        joint.util.setByPath(joint.shapes, type, Cell, '.');\r\n        return Cell;\r\n    }\r\n});\r\n\r\n// joint.dia.CellView base view and controller.\r\n// --------------------------------------------\r\n\r\n// This is the base view and controller for `joint.dia.ElementView` and `joint.dia.LinkView`.\r\n\r\njoint.dia.CellView = joint.mvc.View.extend({\r\n\r\n    tagName: 'g',\r\n\r\n    svgElement: true,\r\n\r\n    className: function() {\r\n\r\n        var classNames = ['cell'];\r\n        var type = this.model.get('type');\r\n\r\n        if (type) {\r\n\r\n            _.each(type.toLowerCase().split('.'), function(value, index, list) {\r\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\r\n            });\r\n        }\r\n\r\n        return classNames.join(' ');\r\n    },\r\n\r\n    attributes: function() {\r\n\r\n        return { 'model-id': this.model.id };\r\n    },\r\n\r\n    constructor: function(options) {\r\n\r\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\r\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\r\n        // still be associated to the same object among all those clients. This is necessary for real-time\r\n        // collaboration mechanism.\r\n        options.id = options.id || joint.util.guid(this);\r\n\r\n        joint.mvc.View.call(this, options);\r\n    },\r\n\r\n    init: function() {\r\n\r\n        _.bindAll(this, 'remove', 'update');\r\n\r\n        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\r\n        this.$el.data('view', this);\r\n\r\n        // Add the cell's type to the view's element as a data attribute.\r\n        this.$el.attr('data-type', this.model.get('type'));\r\n\r\n        this.listenTo(this.model, 'change:attrs', this.onChangeAttrs);\r\n    },\r\n\r\n    onChangeAttrs: function(cell, attrs, opt) {\r\n\r\n        if (opt.dirty) {\r\n\r\n            // dirty flag could be set when a model attribute was removed and it needs to be cleared\r\n            // also from the DOM element. See cell.removeAttr().\r\n            return this.render();\r\n        }\r\n\r\n        return this.update(cell, attrs, opt);\r\n    },\r\n\r\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\r\n    // Example: `can('vertexMove')`, `can('labelMove')`.\r\n    can: function(feature) {\r\n\r\n        var interactive = _.isFunction(this.options.interactive)\r\n                            ? this.options.interactive(this)\r\n                            : this.options.interactive;\r\n\r\n        return (_.isObject(interactive) && interactive[feature] !== false) ||\r\n                (_.isBoolean(interactive) && interactive !== false);\r\n    },\r\n\r\n    findBySelector: function(selector, root) {\r\n\r\n        var $root = $(root || this.el);\r\n        // These are either descendants of `this.$el` of `this.$el` itself.\r\n        // `.` is a special selector used to select the wrapping `<g>` element.\r\n        return (selector === '.') ? $root : $root.find(selector);\r\n    },\r\n\r\n    notify: function(eventName) {\r\n\r\n        if (this.paper) {\r\n\r\n            var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n            // Trigger the event on both the element itself and also on the paper.\r\n            this.trigger.apply(this, [eventName].concat(args));\r\n\r\n            // Paper event handlers receive the view object as the first argument.\r\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\r\n        }\r\n    },\r\n\r\n    getStrokeBBox: function(el) {\r\n        // Return a bounding box rectangle that takes into account stroke.\r\n        // Note that this is a naive and ad-hoc implementation that does not\r\n        // works only in certain cases and should be replaced as soon as browsers will\r\n        // start supporting the getStrokeBBox() SVG method.\r\n        // @TODO any better solution is very welcome!\r\n\r\n        var isMagnet = !!el;\r\n\r\n        el = el || this.el;\r\n        var bbox = V(el).bbox(false, this.paper.viewport);\r\n\r\n        var strokeWidth;\r\n        if (isMagnet) {\r\n\r\n            strokeWidth = V(el).attr('stroke-width');\r\n\r\n        } else {\r\n\r\n            strokeWidth = this.model.attr('rect/stroke-width') || this.model.attr('circle/stroke-width') || this.model.attr('ellipse/stroke-width') || this.model.attr('path/stroke-width');\r\n        }\r\n\r\n        strokeWidth = parseFloat(strokeWidth) || 0;\r\n\r\n        return g.rect(bbox).moveAndExpand({ x: -strokeWidth / 2, y: -strokeWidth / 2, width: strokeWidth, height: strokeWidth });\r\n    },\r\n\r\n    getBBox: function() {\r\n\r\n        return g.rect(this.vel.bbox());\r\n    },\r\n\r\n    highlight: function(el, opt) {\r\n\r\n        el = !el ? this.el : this.$(el)[0] || this.el;\r\n\r\n        // set partial flag if the highlighted element is not the entire view.\r\n        opt = opt || {};\r\n        opt.partial = (el !== this.el);\r\n\r\n        this.notify('cell:highlight', el, opt);\r\n        return this;\r\n    },\r\n\r\n    unhighlight: function(el, opt) {\r\n\r\n        el = !el ? this.el : this.$(el)[0] || this.el;\r\n\r\n        opt = opt || {};\r\n        opt.partial = el != this.el;\r\n\r\n        this.notify('cell:unhighlight', el, opt);\r\n        return this;\r\n    },\r\n\r\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\r\n    // an element found, return the root element of the cell view.\r\n    findMagnet: function(el) {\r\n\r\n        var $el = this.$(el);\r\n        var $rootEl = this.$el;\r\n\r\n        if ($el.length === 0) {\r\n            $el = $rootEl;\r\n        }\r\n\r\n        do {\r\n\r\n            var magnet = $el.attr('magnet');\r\n            if ((magnet || $el.is($rootEl)) && magnet !== 'false') {\r\n                return $el[0];\r\n            }\r\n\r\n            $el = $el.parent();\r\n\r\n        } while ($el.length > 0);\r\n\r\n        // If the overall cell has set `magnet === false`, then return `undefined` to\r\n        // announce there is no magnet found for this cell.\r\n        // This is especially useful to set on cells that have 'ports'. In this case,\r\n        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\r\n        return undefined;\r\n    },\r\n\r\n    // Construct a unique selector for the `el` element within this view.\r\n    // `prevSelector` is being collected through the recursive call.\r\n    // No value for `prevSelector` is expected when using this method.\r\n    getSelector: function(el, prevSelector) {\r\n\r\n        if (el === this.el) {\r\n            return prevSelector;\r\n        }\r\n\r\n        var selector;\r\n\r\n        if (el) {\r\n\r\n            var nthChild = V(el).index() + 1;\r\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\r\n\r\n            if (prevSelector) {\r\n                selector += ' > ' + prevSelector;\r\n            }\r\n\r\n            selector = this.getSelector(el.parentNode, selector);\r\n        }\r\n\r\n        return selector;\r\n    },\r\n\r\n    getAttributeDefinition: function(attrName) {\r\n\r\n        return this.model.constructor.getAttributeDefinition(attrName);\r\n    },\r\n\r\n    setNodeAttributes: function(node, attrs) {\r\n\r\n        if (!_.isEmpty(attrs)) {\r\n            if (node instanceof SVGElement) {\r\n                V(node).attr(attrs);\r\n            } else {\r\n                $(node).attr(attrs);\r\n            }\r\n        }\r\n    },\r\n\r\n    processNodeAttributes: function(node, attrs) {\r\n\r\n        var attrName, attrVal, def, i, n;\r\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\r\n        var relatives = [];\r\n        // divide the attributes between normal and special\r\n        for (attrName in attrs) {\r\n            if (!attrs.hasOwnProperty(attrName)) continue;\r\n            attrVal = attrs[attrName];\r\n            def = this.getAttributeDefinition(attrName);\r\n            if (def && (!_.isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\r\n                if (_.isString(def.set)) {\r\n                    normalAttrs || (normalAttrs = {});\r\n                    normalAttrs[def.set] = attrVal;\r\n                }\r\n                if (attrVal !== null) {\r\n                    relatives.push(attrName, def);\r\n                }\r\n            } else {\r\n                normalAttrs || (normalAttrs = {});\r\n                normalAttrs[joint.util.toKebabCase(attrName)] = attrVal;\r\n            }\r\n        }\r\n\r\n        // handle the rest of attributes via related method\r\n        // from the special attributes namespace.\r\n        for (i = 0, n = relatives.length; i < n; i+=2) {\r\n            attrName = relatives[i];\r\n            def = relatives[i+1];\r\n            attrVal = attrs[attrName];\r\n            if (_.isFunction(def.set)) {\r\n                setAttrs || (setAttrs = {});\r\n                setAttrs[attrName] = attrVal;\r\n            }\r\n            if (_.isFunction(def.position)) {\r\n                positionAttrs || (positionAttrs = {});\r\n                positionAttrs[attrName] = attrVal;\r\n            }\r\n            if (_.isFunction(def.offset)) {\r\n                offsetAttrs || (offsetAttrs = {});\r\n                offsetAttrs[attrName] = attrVal;\r\n            }\r\n        }\r\n\r\n        return {\r\n            raw: attrs,\r\n            normal: normalAttrs,\r\n            set: setAttrs,\r\n            position: positionAttrs,\r\n            offset: offsetAttrs\r\n        };\r\n    },\r\n\r\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\r\n\r\n        opt || (opt = {});\r\n\r\n        var attrName, attrVal, def;\r\n        var rawAttrs = attrs.raw || {};\r\n        var nodeAttrs = attrs.normal || {};\r\n        var setAttrs = attrs.set;\r\n        var positionAttrs = attrs.position;\r\n        var offsetAttrs = attrs.offset;\r\n\r\n        for (attrName in setAttrs) {\r\n            attrVal = setAttrs[attrName];\r\n            def = this.getAttributeDefinition(attrName);\r\n            // SET - set function should return attributes to be set on the node,\r\n            // which will affect the node dimensions based on the reference bounding\r\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\r\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\r\n            if (_.isObject(setResult)) {\r\n                _.extend(nodeAttrs, setResult);\r\n            } else if (setResult !== undefined) {\r\n                nodeAttrs[attrName] = setResult;\r\n            }\r\n        }\r\n\r\n        if (node instanceof HTMLElement) {\r\n            // TODO: setting the `transform` attribute on HTMLElements\r\n            // via `node.style.transform = 'matrix(...)';` would introduce\r\n            // a breaking change (e.g. basic.TextBlock).\r\n            this.setNodeAttributes(node, nodeAttrs);\r\n            return;\r\n        }\r\n\r\n        // The final translation of the subelement.\r\n        var nodeTransform = nodeAttrs.transform || '';\r\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\r\n        var nodePosition = g.Point(nodeMatrix.e, nodeMatrix.f);\r\n        if (nodeTransform) {\r\n            nodeAttrs = _.omit(nodeAttrs, 'transform');\r\n            nodeMatrix.e = nodeMatrix.f = 0;\r\n        }\r\n\r\n        // Calculate node scale determined by the scalable group\r\n        // only if later needed.\r\n        var sx, sy, translation;\r\n        if (positionAttrs || offsetAttrs) {\r\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\r\n            sx = nodeScale.sx;\r\n            sy = nodeScale.sy;\r\n        }\r\n\r\n        for (attrName in positionAttrs) {\r\n            attrVal = positionAttrs[attrName];\r\n            def = this.getAttributeDefinition(attrName);\r\n            // POSITION - position function should return a point from the\r\n            // reference bounding box. The default position of the node is x:0, y:0 of\r\n            // the reference bounding box or could be further specify by some\r\n            // SVG attributes e.g. `x`, `y`\r\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\r\n            if (translation) {\r\n                nodePosition.offset(g.Point(translation).scale(sx, sy));\r\n            }\r\n        }\r\n\r\n        // The node bounding box could depend on the `size` set from the previous loop.\r\n        // Here we know, that all the size attributes have been already set.\r\n        this.setNodeAttributes(node, nodeAttrs);\r\n\r\n        if (offsetAttrs) {\r\n            // Check if the node is visible\r\n            var nodeClientRect = node.getBoundingClientRect();\r\n            if (nodeClientRect.width > 0 && nodeClientRect.height > 0) {\r\n                var nodeBBox = V.transformRect(node.getBBox(), nodeMatrix).scale(1 / sx, 1 / sy);\r\n                for (attrName in offsetAttrs) {\r\n                    attrVal = offsetAttrs[attrName];\r\n                    def = this.getAttributeDefinition(attrName);\r\n                    // OFFSET - offset function should return a point from the element\r\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\r\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\r\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\r\n                    if (translation) {\r\n                        nodePosition.offset(g.Point(translation).scale(sx, sy));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Round the coordinates to 1 decimal point.\r\n        nodePosition.round(1);\r\n        nodeMatrix.e = nodePosition.x;\r\n        nodeMatrix.f = nodePosition.y;\r\n        node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\r\n    },\r\n\r\n    getNodeScale: function(node, scalableNode) {\r\n\r\n        // Check if the node is a descendant of the scalable group.\r\n        var sx, sy;\r\n        if (scalableNode && scalableNode.contains(node)) {\r\n            var scale = scalableNode.scale();\r\n            sx = 1 / scale.sx;\r\n            sy = 1 / scale.sy;\r\n        } else {\r\n            sx = 1;\r\n            sy = 1;\r\n        }\r\n\r\n        return { sx: sx, sy: sy };\r\n    },\r\n\r\n    findNodesAttributes: function(attrs, root, selectorCache) {\r\n\r\n        // TODO: merge attributes in order defined by `index` property\r\n\r\n        var nodesAttrs = {};\r\n\r\n        for (var selector in attrs) {\r\n            if (!attrs.hasOwnProperty(selector)) continue;\r\n            var $selected = selectorCache[selector] = this.findBySelector(selector, root);\r\n\r\n            for (var i = 0, n = $selected.length; i < n; i++) {\r\n                var node = $selected[i];\r\n                var nodeId = V.ensureId(node);\r\n                var nodeAttrs = attrs[selector];\r\n                var prevNodeAttrs = nodesAttrs[nodeId];\r\n                if (prevNodeAttrs) {\r\n                    if (!prevNodeAttrs.merged) {\r\n                        prevNodeAttrs.merged = true;\r\n                        prevNodeAttrs.attributes = _.cloneDeep(prevNodeAttrs.attributes);\r\n                    }\r\n                    _.merge(prevNodeAttrs.attributes, nodeAttrs);\r\n                } else {\r\n                    nodesAttrs[nodeId] = {\r\n                        attributes: nodeAttrs,\r\n                        node: node,\r\n                        merged: false\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodesAttrs;\r\n    },\r\n\r\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\r\n    // unless `attrs` parameter was passed.\r\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\r\n\r\n        opt || (opt = {});\r\n        opt.rootBBox || (opt.rootBBox = g.Rect());\r\n\r\n        // Cache table for query results and bounding box calculation.\r\n        // Note that `selectorCache` needs to be invalidated for all\r\n        // `updateAttributes` calls, as the selectors might pointing\r\n        // to nodes designated by an attribute or elements dynamically\r\n        // created.\r\n        var selectorCache = {};\r\n        var bboxCache = {};\r\n        var relativeItems = [];\r\n        var item, node, nodeAttrs, nodeData, processedAttrs;\r\n\r\n        var roAttrs = opt.roAttributes;\r\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache);\r\n        // `nodesAttrs` are different from all attributes, when\r\n        // rendering only  attributes sent to this method.\r\n        var nodesAllAttrs = (roAttrs)\r\n            ? nodesAllAttrs = this.findNodesAttributes(attrs, rootNode, selectorCache)\r\n            : nodesAttrs;\r\n\r\n        for (var nodeId in nodesAttrs) {\r\n            nodeData = nodesAttrs[nodeId];\r\n            nodeAttrs = nodeData.attributes;\r\n            node = nodeData.node;\r\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\r\n\r\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\r\n                // Set all the normal attributes right on the SVG/HTML element.\r\n                this.setNodeAttributes(node, processedAttrs.normal);\r\n\r\n            } else {\r\n\r\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\r\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\r\n                    ? nodeAllAttrs.ref\r\n                    : nodeAttrs.ref;\r\n\r\n                var refNode;\r\n                if (refSelector) {\r\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode))[0];\r\n                    if (!refNode) {\r\n                        throw new Error('dia.ElementView: \"' + refSelector + '\" reference does not exists.');\r\n                    }\r\n                } else {\r\n                    refNode = null;\r\n                }\r\n\r\n                item = {\r\n                    node: node,\r\n                    refNode: refNode,\r\n                    processedAttributes: processedAttrs,\r\n                    allAttributes: nodeAllAttrs\r\n                };\r\n\r\n                // If an element in the list is positioned relative to this one, then\r\n                // we want to insert this one before it in the list.\r\n                var itemIndex = _.findIndex(relativeItems, { refNode: node });\r\n                if (itemIndex > -1) {\r\n                    relativeItems.splice(itemIndex, 0, item);\r\n                } else {\r\n                    relativeItems.push(item);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var i = 0, n = relativeItems.length; i < n; i++) {\r\n            item = relativeItems[i];\r\n            node = item.node;\r\n            refNode = item.refNode;\r\n\r\n            // Find the reference element bounding box. If no reference was provided, we\r\n            // use the optional bounding box.\r\n            var refNodeId = refNode ? V.ensureId(refNode) : '';\r\n            var refBBox = bboxCache[refNodeId];\r\n            if (!refBBox) {\r\n                // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\r\n                // or to the root `<g>` element if no rotatable group present if reference node present.\r\n                // Uses the bounding box provided.\r\n                refBBox = bboxCache[refNodeId] = (refNode)\r\n                    ? V(refNode).bbox(false, (opt.rotatableNode || rootNode))\r\n                    : opt.rootBBox;\r\n            }\r\n\r\n            if (roAttrs) {\r\n                // if there was a special attribute affecting the position amongst passed-in attributes\r\n                // we have to merge it with the rest of the element's attributes as they are necessary\r\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\r\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\r\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\r\n\r\n            } else {\r\n                processedAttrs = item.processedAttributes;\r\n            }\r\n\r\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\r\n        }\r\n    },\r\n\r\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\r\n\r\n        processedAttrs.set || (processedAttrs.set = {});\r\n        processedAttrs.position || (processedAttrs.position = {});\r\n        processedAttrs.offset || (processedAttrs.offset = {});\r\n\r\n        _.extend(processedAttrs.set, roProcessedAttrs.set);\r\n        _.extend(processedAttrs.position, roProcessedAttrs.position);\r\n        _.extend(processedAttrs.offset, roProcessedAttrs.offset);\r\n\r\n        // Handle also the special transform property.\r\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\r\n        if (transform !== undefined && roProcessedAttrs.normal) {\r\n            roProcessedAttrs.normal.transform = transform;\r\n        }\r\n        processedAttrs.normal = roProcessedAttrs.normal;\r\n    },\r\n\r\n    // Interaction. The controller part.\r\n    // ---------------------------------\r\n\r\n    // Interaction is handled by the paper and delegated to the view in interest.\r\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\r\n    // If necessary, real coordinates can be obtained from the `evt` event object.\r\n\r\n    // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\r\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\r\n\r\n    pointerdblclick: function(evt, x, y) {\r\n\r\n        this.notify('cell:pointerdblclick', evt, x, y);\r\n    },\r\n\r\n    pointerclick: function(evt, x, y) {\r\n\r\n        this.notify('cell:pointerclick', evt, x, y);\r\n    },\r\n\r\n    pointerdown: function(evt, x, y) {\r\n\r\n        if (this.model.graph) {\r\n            this.model.startBatch('pointer');\r\n            this._graph = this.model.graph;\r\n        }\r\n\r\n        this.notify('cell:pointerdown', evt, x, y);\r\n    },\r\n\r\n    pointermove: function(evt, x, y) {\r\n\r\n        this.notify('cell:pointermove', evt, x, y);\r\n    },\r\n\r\n    pointerup: function(evt, x, y) {\r\n\r\n        this.notify('cell:pointerup', evt, x, y);\r\n\r\n        if (this._graph) {\r\n            // we don't want to trigger event on model as model doesn't\r\n            // need to be member of collection anymore (remove)\r\n            this._graph.stopBatch('pointer', { cell: this.model });\r\n            delete this._graph;\r\n        }\r\n    },\r\n\r\n    mouseover: function(evt) {\r\n\r\n        this.notify('cell:mouseover', evt);\r\n    },\r\n\r\n    mouseout: function(evt) {\r\n\r\n        this.notify('cell:mouseout', evt);\r\n    },\r\n\r\n    mouseenter: function(evt) {\r\n\r\n        this.notify('cell:mouseenter', evt);\r\n    },\r\n\r\n    mouseleave: function(evt) {\r\n\r\n        this.notify('cell:mouseleave', evt);\r\n    },\r\n\r\n    mousewheel: function(evt, x, y, delta) {\r\n\r\n        this.notify('cell:mousewheel', evt, x, y, delta);\r\n    },\r\n\r\n    contextmenu: function(evt, x, y) {\r\n\r\n        this.notify('cell:contextmenu', evt, x, y);\r\n    },\r\n\r\n    setInteractivity: function(value) {\r\n\r\n        this.options.interactive = value;\r\n    }\r\n});\r\n\r\n// joint.dia.Element base model.\r\n// -----------------------------\r\n\r\njoint.dia.Element = joint.dia.Cell.extend({\r\n\r\n    defaults: {\r\n        position: { x: 0, y: 0 },\r\n        size: { width: 1, height: 1 },\r\n        angle: 0\r\n    },\r\n\r\n    initialize: function() {\r\n\r\n        this._initializePorts();\r\n        joint.dia.Cell.prototype.initialize.apply(this, arguments);\r\n    },\r\n\r\n    /**\r\n     * @abstract\r\n     */\r\n    _initializePorts: function() {\r\n        // implemented in ports.js\r\n    },\r\n\r\n    isElement: function() {\r\n\r\n        return true;\r\n    },\r\n\r\n    position: function(x, y, opt) {\r\n\r\n        var isSetter = _.isNumber(y);\r\n\r\n        opt = (isSetter ? opt : x) || {};\r\n\r\n        // option `parentRelative` for setting the position relative to the element's parent.\r\n        if (opt.parentRelative) {\r\n\r\n            // Getting the parent's position requires the collection.\r\n            // Cell.get('parent') helds cell id only.\r\n            if (!this.graph) throw new Error('Element must be part of a graph.');\r\n\r\n            var parent = this.graph.getCell(this.get('parent'));\r\n            var parentPosition = parent && !parent.isLink()\r\n                ? parent.get('position')\r\n                : { x: 0, y: 0 };\r\n        }\r\n\r\n        if (isSetter) {\r\n\r\n            if (opt.parentRelative) {\r\n                x += parentPosition.x;\r\n                y += parentPosition.y;\r\n            }\r\n\r\n            return this.set('position', { x: x, y: y }, opt);\r\n\r\n        } else { // Getter returns a geometry point.\r\n\r\n            var elementPosition = g.point(this.get('position'));\r\n\r\n            return opt.parentRelative\r\n                ? elementPosition.difference(parentPosition)\r\n                : elementPosition;\r\n        }\r\n    },\r\n\r\n    translate: function(tx, ty, opt) {\r\n\r\n        tx = tx || 0;\r\n        ty = ty || 0;\r\n\r\n        if (tx === 0 && ty === 0) {\r\n            // Like nothing has happened.\r\n            return this;\r\n        }\r\n\r\n        opt = opt || {};\r\n        // Pass the initiator of the translation.\r\n        opt.translateBy = opt.translateBy || this.id;\r\n\r\n        var position = this.get('position') || { x: 0, y: 0 };\r\n\r\n        if (opt.restrictedArea && opt.translateBy === this.id) {\r\n\r\n            // We are restricting the translation for the element itself only. We get\r\n            // the bounding box of the element including all its embeds.\r\n            // All embeds have to be translated the exact same way as the element.\r\n            var bbox = this.getBBox({ deep: true });\r\n            var ra = opt.restrictedArea;\r\n            //- - - - - - - - - - - - -> ra.x + ra.width\r\n            // - - - -> position.x      |\r\n            // -> bbox.x\r\n            //                   |\r\n            //         \r\n            //                 |\r\n            //   \r\n            //                  |\r\n            //   <-dx->                     | restricted area right border\r\n            //         <-width->        |    translated element\r\n            //   <- - bbox.width - ->        embedded element\r\n            var dx = position.x - bbox.x;\r\n            var dy = position.y - bbox.y;\r\n            // Find the maximal/minimal coordinates that the element can be translated\r\n            // while complies the restrictions.\r\n            var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\r\n            var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\r\n            // recalculate the translation taking the resctrictions into account.\r\n            tx = x - position.x;\r\n            ty = y - position.y;\r\n        }\r\n\r\n        var translatedPosition = {\r\n            x: position.x + tx,\r\n            y: position.y + ty\r\n        };\r\n\r\n        // To find out by how much an element was translated in event 'change:position' handlers.\r\n        opt.tx = tx;\r\n        opt.ty = ty;\r\n\r\n        if (opt.transition) {\r\n\r\n            if (!_.isObject(opt.transition)) opt.transition = {};\r\n\r\n            this.transition('position', translatedPosition, _.extend({}, opt.transition, {\r\n                valueFunction: joint.util.interpolate.object\r\n            }));\r\n\r\n        } else {\r\n\r\n            this.set('position', translatedPosition, opt);\r\n        }\r\n\r\n        // Recursively call `translate()` on all the embeds cells.\r\n        _.invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\r\n\r\n        return this;\r\n    },\r\n\r\n    size: function(width, height, opt) {\r\n\r\n        var currentSize = this.get('size');\r\n        // Getter\r\n        // () signature\r\n        if (width === undefined) {\r\n            return {\r\n                width: currentSize.width,\r\n                height: currentSize.height\r\n            };\r\n        }\r\n        // Setter\r\n        // (size, opt) signature\r\n        if (_.isObject(width)) {\r\n            opt = height;\r\n            height = _.isNumber(width.height) ? width.height : currentSize.height;\r\n            width = _.isNumber(width.width) ? width.width : currentSize.width;\r\n        }\r\n\r\n        return this.resize(width, height, opt);\r\n    },\r\n\r\n    resize: function(width, height, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        this.startBatch('resize', opt);\r\n\r\n        if (opt.direction) {\r\n\r\n            var currentSize = this.get('size');\r\n\r\n            switch (opt.direction) {\r\n\r\n                case 'left':\r\n                case 'right':\r\n                    // Don't change height when resizing horizontally.\r\n                    height = currentSize.height;\r\n                    break;\r\n\r\n                case 'top':\r\n                case 'bottom':\r\n                    // Don't change width when resizing vertically.\r\n                    width = currentSize.width;\r\n                    break;\r\n            }\r\n\r\n            // Get the angle and clamp its value between 0 and 360 degrees.\r\n            var angle = g.normalizeAngle(this.get('angle') || 0);\r\n\r\n            var quadrant = {\r\n                'top-right': 0,\r\n                'right': 0,\r\n                'top-left': 1,\r\n                'top': 1,\r\n                'bottom-left': 2,\r\n                'left': 2,\r\n                'bottom-right': 3,\r\n                'bottom': 3\r\n            }[opt.direction];\r\n\r\n            if (opt.absolute) {\r\n\r\n                // We are taking the element's rotation into account\r\n                quadrant += Math.floor((angle + 45) / 90);\r\n                quadrant %= 4;\r\n            }\r\n\r\n            // This is a rectangle in size of the unrotated element.\r\n            var bbox = this.getBBox();\r\n\r\n            // Pick the corner point on the element, which meant to stay on its place before and\r\n            // after the rotation.\r\n            var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\r\n\r\n            // Find  an image of the previous indent point. This is the position, where is the\r\n            // point actually located on the screen.\r\n            var imageFixedPoint = g.point(fixedPoint).rotate(bbox.center(), -angle);\r\n\r\n            // Every point on the element rotates around a circle with the centre of rotation\r\n            // in the middle of the element while the whole element is being rotated. That means\r\n            // that the distance from a point in the corner of the element (supposed its always rect) to\r\n            // the center of the element doesn't change during the rotation and therefore it equals\r\n            // to a distance on unrotated element.\r\n            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\r\n            var radius = Math.sqrt((width * width) + (height * height)) / 2;\r\n\r\n            // Now we are looking for an angle between x-axis and the line starting at image of fixed point\r\n            // and ending at the center of the element. We call this angle `alpha`.\r\n\r\n            // The image of a fixed point is located in n-th quadrant. For each quadrant passed\r\n            // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\r\n            //\r\n            // 3 | 2\r\n            // --c-- Quadrant positions around the element's center `c`\r\n            // 0 | 1\r\n            //\r\n            var alpha = quadrant * Math.PI / 2;\r\n\r\n            // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\r\n            // going through the center of the element) and line crossing the indent of the fixed point and the center\r\n            // of the element. This is the angle we need but on the unrotated element.\r\n            alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\r\n\r\n            // Lastly we have to deduct the original angle the element was rotated by and that's it.\r\n            alpha -= g.toRad(angle);\r\n\r\n            // With this angle and distance we can easily calculate the centre of the unrotated element.\r\n            // Note that fromPolar constructor accepts an angle in radians.\r\n            var center = g.point.fromPolar(radius, alpha, imageFixedPoint);\r\n\r\n            // The top left corner on the unrotated element has to be half a width on the left\r\n            // and half a height to the top from the center. This will be the origin of rectangle\r\n            // we were looking for.\r\n            var origin = g.point(center).offset(width / -2, height / -2);\r\n\r\n            // Resize the element (before re-positioning it).\r\n            this.set('size', { width: width, height: height }, opt);\r\n\r\n            // Finally, re-position the element.\r\n            this.position(origin.x, origin.y, opt);\r\n\r\n        } else {\r\n\r\n            // Resize the element.\r\n            this.set('size', { width: width, height: height }, opt);\r\n        }\r\n\r\n        this.stopBatch('resize', opt);\r\n\r\n        return this;\r\n    },\r\n\r\n    scale: function(sx, sy, origin, opt) {\r\n\r\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\r\n        this.startBatch('scale', opt);\r\n        this.position(scaledBBox.x, scaledBBox.y, opt);\r\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\r\n        this.stopBatch('scale');\r\n        return this;\r\n    },\r\n\r\n    fitEmbeds: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        // Getting the children's size and position requires the collection.\r\n        // Cell.get('embdes') helds an array of cell ids only.\r\n        if (!this.graph) throw new Error('Element must be part of a graph.');\r\n\r\n        var embeddedCells = this.getEmbeddedCells();\r\n\r\n        if (embeddedCells.length > 0) {\r\n\r\n            this.startBatch('fit-embeds', opt);\r\n\r\n            if (opt.deep) {\r\n                // Recursively apply fitEmbeds on all embeds first.\r\n                _.invoke(embeddedCells, 'fitEmbeds', opt);\r\n            }\r\n\r\n            // Compute cell's size and position  based on the children bbox\r\n            // and given padding.\r\n            var bbox = this.graph.getCellsBBox(embeddedCells);\r\n            var padding = joint.util.normalizeSides(opt.padding);\r\n\r\n            // Apply padding computed above to the bbox.\r\n            bbox.moveAndExpand({\r\n                x: -padding.left,\r\n                y: -padding.top,\r\n                width: padding.right + padding.left,\r\n                height: padding.bottom + padding.top\r\n            });\r\n\r\n            // Set new element dimensions finally.\r\n            this.set({\r\n                position: { x: bbox.x, y: bbox.y },\r\n                size: { width: bbox.width, height: bbox.height }\r\n            }, opt);\r\n\r\n            this.stopBatch('fit-embeds');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // Rotate element by `angle` degrees, optionally around `origin` point.\r\n    // If `origin` is not provided, it is considered to be the center of the element.\r\n    // If `absolute` is `true`, the `angle` is considered is abslute, i.e. it is not\r\n    // the difference from the previous angle.\r\n    rotate: function(angle, absolute, origin, opt) {\r\n\r\n        if (origin) {\r\n\r\n            var center = this.getBBox().center();\r\n            var size = this.get('size');\r\n            var position = this.get('position');\r\n            center.rotate(origin, this.get('angle') - angle);\r\n            var dx = center.x - size.width / 2 - position.x;\r\n            var dy = center.y - size.height / 2 - position.y;\r\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\r\n            this.position(position.x + dx, position.y + dy, opt);\r\n            this.rotate(angle, absolute, null, opt);\r\n            this.stopBatch('rotate');\r\n\r\n        } else {\r\n\r\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getBBox: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        if (opt.deep && this.graph) {\r\n\r\n            // Get all the embedded elements using breadth first algorithm,\r\n            // that doesn't use recursion.\r\n            var elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\r\n            // Add the model itself.\r\n            elements.push(this);\r\n\r\n            return this.graph.getCellsBBox(elements);\r\n        }\r\n\r\n        var position = this.get('position');\r\n        var size = this.get('size');\r\n\r\n        return g.rect(position.x, position.y, size.width, size.height);\r\n    }\r\n});\r\n\r\n// joint.dia.Element base view and controller.\r\n// -------------------------------------------\r\n\r\n\r\njoint.dia.ElementView = joint.dia.CellView.extend({\r\n\r\n    /**\r\n     * @abstract\r\n     */\r\n    _removePorts: function() {\r\n        // implemented in ports.js\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @abstract\r\n     */\r\n    _renderPorts: function() {\r\n        // implemented in ports.js\r\n    },\r\n\r\n    className: function() {\r\n\r\n        var classNames = joint.dia.CellView.prototype.className.apply(this).split(' ');\r\n\r\n        classNames.push('element');\r\n\r\n        return classNames.join(' ');\r\n    },\r\n\r\n    initialize: function() {\r\n\r\n        joint.dia.CellView.prototype.initialize.apply(this, arguments);\r\n\r\n        var model = this.model;\r\n\r\n        this.listenTo(model, 'change:position', this.translate);\r\n        this.listenTo(model, 'change:size', this.resize);\r\n        this.listenTo(model, 'change:angle', this.rotate);\r\n        this.listenTo(model, 'change:markup', this.render);\r\n\r\n        this._initializePorts();\r\n    },\r\n\r\n    /**\r\n     * @abstract\r\n     */\r\n    _initializePorts: function() {\r\n\r\n    },\r\n\r\n    update: function(cell, renderingOnlyAttrs) {\r\n\r\n        this._removePorts();\r\n\r\n        var model = this.model;\r\n        var modelAttrs = model.attr();\r\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\r\n            rootBBox: g.Rect(model.size()),\r\n            scalableNode: this.scalableNode,\r\n            rotatableNode: this.rotatableNode,\r\n            // Use rendering only attributes if they differs from the model attributes\r\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\r\n        });\r\n\r\n        this._renderPorts();\r\n    },\r\n\r\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\r\n    // default markup is not desirable.\r\n    renderMarkup: function() {\r\n\r\n        var markup = this.model.get('markup') || this.model.markup;\r\n\r\n        if (markup) {\r\n\r\n            var svg = joint.util.template(markup)();\r\n            var nodes = V(svg);\r\n\r\n            this.vel.append(nodes);\r\n\r\n        } else {\r\n\r\n            throw new Error('properties.markup is missing while the default render() implementation is used.');\r\n        }\r\n    },\r\n\r\n    render: function() {\r\n\r\n        this.$el.empty();\r\n\r\n        this.renderMarkup();\r\n        this.rotatableNode = this.vel.findOne('.rotatable');\r\n        var scalable = this.scalableNode = this.vel.findOne('.scalable');\r\n        if (scalable) {\r\n            // Double update is necessary for elements with the scalable group only\r\n            // Note the resize() triggers the other `update`.\r\n            this.update();\r\n        }\r\n        this.resize();\r\n        this.rotate();\r\n        this.translate();\r\n\r\n        return this;\r\n    },\r\n\r\n    resize: function(cell, changed, opt) {\r\n\r\n        var model = this.model;\r\n        var size = model.get('size') || { width: 1, height: 1 };\r\n        var angle = model.get('angle') || 0;\r\n\r\n        var scalable = this.scalableNode;\r\n        if (!scalable) {\r\n\r\n            if (angle !== 0) {\r\n                // update the origin of the rotation\r\n                this.rotate();\r\n            }\r\n            // update the ref attributes\r\n            this.update();\r\n\r\n            // If there is no scalable elements, than there is nothing to scale.\r\n            return;\r\n        }\r\n\r\n        var scalableBbox = scalable.bbox(true);\r\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\r\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\r\n        scalable.attr('transform', 'scale(' + (size.width / (scalableBbox.width || 1)) + ',' + (size.height / (scalableBbox.height || 1)) + ')');\r\n\r\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\r\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\r\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\r\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\r\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\r\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\r\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\r\n\r\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\r\n        var rotatable = this.rotatableNode;\r\n        var rotation = rotatable && rotatable.attr('transform');\r\n        if (rotation && rotation !== 'null') {\r\n\r\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\r\n            var rotatableBbox = scalable.bbox(false, this.paper.viewport);\r\n\r\n            // Store new x, y and perform rotate() again against the new rotation origin.\r\n            model.set('position', { x: rotatableBbox.x, y: rotatableBbox.y }, opt);\r\n            this.rotate();\r\n        }\r\n\r\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\r\n        // would work with wrong (rotated) bounding boxes.\r\n        this.update();\r\n    },\r\n\r\n    translate: function(model, changes, opt) {\r\n\r\n        var position = this.model.get('position') || { x: 0, y: 0 };\r\n\r\n        this.vel.attr('transform', 'translate(' + position.x + ',' + position.y + ')');\r\n    },\r\n\r\n    rotate: function() {\r\n\r\n        var rotatable = this.rotatableNode;\r\n        if (!rotatable) {\r\n            // If there is no rotatable elements, then there is nothing to rotate.\r\n            return;\r\n        }\r\n\r\n        var angle = this.model.get('angle') || 0;\r\n        var size = this.model.get('size') || { width: 1, height: 1 };\r\n\r\n        var ox = size.width / 2;\r\n        var oy = size.height / 2;\r\n\r\n        if (angle !== 0) {\r\n            rotatable.attr('transform', 'rotate(' + angle + ',' + ox + ',' + oy + ')');\r\n        } else {\r\n            rotatable.removeAttr('transform');\r\n        }\r\n    },\r\n\r\n    getBBox: function(opt) {\r\n\r\n        if (opt && opt.useModelGeometry) {\r\n            var bbox = this.model.getBBox().bbox(this.model.get('angle'));\r\n            return this.paper.localToPaperRect(bbox);\r\n        }\r\n\r\n        return joint.dia.CellView.prototype.getBBox.apply(this, arguments);\r\n    },\r\n\r\n    // Embedding mode methods\r\n    // ----------------------\r\n\r\n    prepareEmbedding: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var model = opt.model || this.model;\r\n        var paper = opt.paper || this.paper;\r\n        var graph = paper.model;\r\n\r\n        model.startBatch('to-front', opt);\r\n\r\n        // Bring the model to the front with all his embeds.\r\n        model.toFront({ deep: true, ui: true });\r\n\r\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\r\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\r\n        var maxZ = graph.get('cells').max('z').get('z');\r\n        var connectedLinks = graph.getConnectedLinks(model, { deep: true });\r\n\r\n        // Move to front also all the inbound and outbound links that are connected\r\n        // to any of the element descendant. If we bring to front only embedded elements,\r\n        // links connected to them would stay in the background.\r\n        _.invoke(connectedLinks, 'set', 'z', maxZ + 1, { ui: true });\r\n\r\n        model.stopBatch('to-front');\r\n\r\n        // Before we start looking for suitable parent we remove the current one.\r\n        var parentId = model.get('parent');\r\n        parentId && graph.getCell(parentId).unembed(model, { ui: true });\r\n    },\r\n\r\n    processEmbedding: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var model = opt.model || this.model;\r\n        var paper = opt.paper || this.paper;\r\n\r\n        var paperOptions = paper.options;\r\n        var candidates = paper.model.findModelsUnderElement(model, { searchBy: paperOptions.findParentBy });\r\n\r\n        if (paperOptions.frontParentOnly) {\r\n            // pick the element with the highest `z` index\r\n            candidates = candidates.slice(-1);\r\n        }\r\n\r\n        var newCandidateView = null;\r\n        var prevCandidateView = this._candidateEmbedView;\r\n\r\n        // iterate over all candidates starting from the last one (has the highest z-index).\r\n        for (var i = candidates.length - 1; i >= 0; i--) {\r\n\r\n            var candidate = candidates[i];\r\n\r\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\r\n\r\n                // candidate remains the same\r\n                newCandidateView = prevCandidateView;\r\n                break;\r\n\r\n            } else {\r\n\r\n                var view = candidate.findView(paper);\r\n                if (paperOptions.validateEmbedding.call(paper, this, view)) {\r\n\r\n                    // flip to the new candidate\r\n                    newCandidateView = view;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (newCandidateView && newCandidateView != prevCandidateView) {\r\n            // A new candidate view found. Highlight the new one.\r\n            this.clearEmbedding();\r\n            this._candidateEmbedView = newCandidateView.highlight(null, { embedding: true });\r\n        }\r\n\r\n        if (!newCandidateView && prevCandidateView) {\r\n            // No candidate view found. Unhighlight the previous candidate.\r\n            this.clearEmbedding();\r\n        }\r\n    },\r\n\r\n    clearEmbedding: function() {\r\n\r\n        var candidateView = this._candidateEmbedView;\r\n        if (candidateView) {\r\n            // No candidate view found. Unhighlight the previous candidate.\r\n            candidateView.unhighlight(null, { embedding: true });\r\n            this._candidateEmbedView = null;\r\n        }\r\n    },\r\n\r\n    finalizeEmbedding: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var candidateView = this._candidateEmbedView;\r\n        var model = opt.model || this.model;\r\n        var paper = opt.paper || this.paper;\r\n\r\n        if (candidateView) {\r\n\r\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\r\n            candidateView.model.embed(model, { ui: true });\r\n            candidateView.unhighlight(null, { embedding: true });\r\n\r\n            delete this._candidateEmbedView;\r\n        }\r\n\r\n        _.invoke(paper.model.getConnectedLinks(model, { deep: true }), 'reparent', { ui: true });\r\n    },\r\n\r\n    // Interaction. The controller part.\r\n    // ---------------------------------\r\n\r\n    pointerdown: function(evt, x, y) {\r\n\r\n        var paper = this.paper;\r\n\r\n        if (\r\n            evt.target.getAttribute('magnet') &&\r\n            this.can('addLinkFromMagnet') &&\r\n            paper.options.validateMagnet.call(paper, this, evt.target)\r\n        ) {\r\n\r\n            this.model.startBatch('add-link');\r\n\r\n            var link = paper.getDefaultLink(this, evt.target);\r\n\r\n            link.set({\r\n                source: {\r\n                    id: this.model.id,\r\n                    selector: this.getSelector(evt.target),\r\n                    port: evt.target.getAttribute('port')\r\n                },\r\n                target: { x: x, y: y }\r\n            });\r\n\r\n            paper.model.addCell(link);\r\n\r\n            var linkView = this._linkView = paper.findViewByModel(link);\r\n\r\n            linkView.pointerdown(evt, x, y);\r\n            linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' });\r\n\r\n        } else {\r\n\r\n            this._dx = x;\r\n            this._dy = y;\r\n\r\n            this.restrictedArea = paper.getRestrictedArea(this);\r\n\r\n            joint.dia.CellView.prototype.pointerdown.apply(this, arguments);\r\n            this.notify('element:pointerdown', evt, x, y);\r\n        }\r\n    },\r\n\r\n    pointermove: function(evt, x, y) {\r\n\r\n        if (this._linkView) {\r\n\r\n            // let the linkview deal with this event\r\n            this._linkView.pointermove(evt, x, y);\r\n\r\n        } else {\r\n\r\n            var grid = this.paper.options.gridSize;\r\n\r\n            if (this.can('elementMove')) {\r\n\r\n                var position = this.model.get('position');\r\n\r\n                // Make sure the new element's position always snaps to the current grid after\r\n                // translate as the previous one could be calculated with a different grid size.\r\n                var tx = g.snapToGrid(position.x, grid) - position.x + g.snapToGrid(x - this._dx, grid);\r\n                var ty = g.snapToGrid(position.y, grid) - position.y + g.snapToGrid(y - this._dy, grid);\r\n\r\n                this.model.translate(tx, ty, { restrictedArea: this.restrictedArea, ui: true });\r\n\r\n                if (this.paper.options.embeddingMode) {\r\n\r\n                    if (!this._inProcessOfEmbedding) {\r\n                        // Prepare the element for embedding only if the pointer moves.\r\n                        // We don't want to do unnecessary action with the element\r\n                        // if an user only clicks/dblclicks on it.\r\n                        this.prepareEmbedding();\r\n                        this._inProcessOfEmbedding = true;\r\n                    }\r\n\r\n                    this.processEmbedding();\r\n                }\r\n            }\r\n\r\n            this._dx = g.snapToGrid(x, grid);\r\n            this._dy = g.snapToGrid(y, grid);\r\n\r\n            joint.dia.CellView.prototype.pointermove.apply(this, arguments);\r\n            this.notify('element:pointermove', evt, x, y);\r\n        }\r\n    },\r\n\r\n    pointerup: function(evt, x, y) {\r\n\r\n        if (this._linkView) {\r\n\r\n            // Let the linkview deal with this event.\r\n            this._linkView.pointerup(evt, x, y);\r\n            this._linkView = null;\r\n            this.model.stopBatch('add-link');\r\n\r\n        } else {\r\n\r\n            if (this._inProcessOfEmbedding) {\r\n                this.finalizeEmbedding();\r\n                this._inProcessOfEmbedding = false;\r\n            }\r\n\r\n            this.notify('element:pointerup', evt, x, y);\r\n            joint.dia.CellView.prototype.pointerup.apply(this, arguments);\r\n        }\r\n    },\r\n\r\n    mouseenter: function(evt) {\r\n\r\n        joint.dia.CellView.prototype.mouseenter.apply(this, arguments);\r\n        this.notify('element:mouseenter', evt);\r\n    },\r\n\r\n    mouseleave: function(evt) {\r\n\r\n        joint.dia.CellView.prototype.mouseleave.apply(this, arguments);\r\n        this.notify('element:mouseleave', evt);\r\n    }\r\n});\r\n\r\n\r\n// joint.dia.Link base model.\r\n// --------------------------\r\n\r\njoint.dia.Link = joint.dia.Cell.extend({\r\n\r\n    // The default markup for links.\r\n    markup: [\r\n        '<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\r\n        '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\r\n        '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\r\n        '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>',\r\n        '<g class=\"labels\"/>',\r\n        '<g class=\"marker-vertices\"/>',\r\n        '<g class=\"marker-arrowheads\"/>',\r\n        '<g class=\"link-tools\"/>'\r\n    ].join(''),\r\n\r\n    labelMarkup: [\r\n        '<g class=\"label\">',\r\n        '<rect />',\r\n        '<text />',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    toolMarkup: [\r\n        '<g class=\"link-tool\">',\r\n        '<g class=\"tool-remove\" event=\"remove\">',\r\n        '<circle r=\"11\" />',\r\n        '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />',\r\n        '<title>Remove link.</title>',\r\n        '</g>',\r\n        '<g class=\"tool-options\" event=\"link:options\">',\r\n        '<circle r=\"11\" transform=\"translate(25)\"/>',\r\n        '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>',\r\n        '<title>Link options.</title>',\r\n        '</g>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).\r\n    // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for\r\n    // dragging vertices (changin their position). The latter is used for removing vertices.\r\n    vertexMarkup: [\r\n        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\r\n        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\r\n        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\r\n        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\r\n        '<title>Remove vertex.</title>',\r\n        '</path>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    arrowheadMarkup: [\r\n        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\r\n        '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    defaults: {\r\n\r\n        type: 'link',\r\n        source: {},\r\n        target: {}\r\n    },\r\n\r\n    isLink: function() {\r\n\r\n        return true;\r\n    },\r\n\r\n    disconnect: function() {\r\n\r\n        return this.set({ source: g.point(0, 0), target: g.point(0, 0) });\r\n    },\r\n\r\n    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\r\n    label: function(idx, value, opt) {\r\n\r\n        idx = idx || 0;\r\n\r\n        // Is it a getter?\r\n        if (arguments.length <= 1) {\r\n            return this.prop(['labels', idx]);\r\n        }\r\n\r\n        return this.prop(['labels', idx], value, opt);\r\n    },\r\n\r\n    translate: function(tx, ty, opt) {\r\n\r\n        // enrich the option object\r\n        opt = opt || {};\r\n        opt.translateBy = opt.translateBy || this.id;\r\n        opt.tx = tx;\r\n        opt.ty = ty;\r\n\r\n        return this.applyToPoints(function(p) {\r\n            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\r\n        }, opt);\r\n    },\r\n\r\n    scale: function(sx, sy, origin, opt) {\r\n\r\n        return this.applyToPoints(function(p) {\r\n            return g.point(p).scale(sx, sy, origin).toJSON();\r\n        }, opt);\r\n    },\r\n\r\n    applyToPoints: function(fn, opt) {\r\n\r\n        if (!_.isFunction(fn)) {\r\n            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\r\n        }\r\n\r\n        var attrs = {};\r\n\r\n        var source = this.get('source');\r\n        if (!source.id) {\r\n            attrs.source = fn(source);\r\n        }\r\n\r\n        var target = this.get('target');\r\n        if (!target.id) {\r\n            attrs.target = fn(target);\r\n        }\r\n\r\n        var vertices = this.get('vertices');\r\n        if (vertices && vertices.length > 0) {\r\n            attrs.vertices = _.map(vertices, fn);\r\n        }\r\n\r\n        return this.set(attrs, opt);\r\n    },\r\n\r\n    reparent: function(opt) {\r\n\r\n        var newParent;\r\n\r\n        if (this.graph) {\r\n\r\n            var source = this.graph.getCell(this.get('source').id);\r\n            var target = this.graph.getCell(this.get('target').id);\r\n            var prevParent = this.graph.getCell(this.get('parent'));\r\n\r\n            if (source && target) {\r\n                newParent = this.graph.getCommonAncestor(source, target);\r\n            }\r\n\r\n            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\r\n                // Unembed the link if source and target has no common ancestor\r\n                // or common ancestor changed\r\n                prevParent.unembed(this, opt);\r\n            }\r\n\r\n            if (newParent) {\r\n                newParent.embed(this, opt);\r\n            }\r\n        }\r\n\r\n        return newParent;\r\n    },\r\n\r\n    hasLoop: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var sourceId = this.get('source').id;\r\n        var targetId = this.get('target').id;\r\n\r\n        if (!sourceId || !targetId) {\r\n            // Link \"pinned\" to the paper does not have a loop.\r\n            return false;\r\n        }\r\n\r\n        var loop = sourceId === targetId;\r\n\r\n        // Note that there in the deep mode a link can have a loop,\r\n        // even if it connects only a parent and its embed.\r\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\r\n        if (!loop && opt.deep && this.graph) {\r\n\r\n            var sourceElement = this.graph.getCell(sourceId);\r\n            var targetElement = this.graph.getCell(targetId);\r\n\r\n            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\r\n        }\r\n\r\n        return loop;\r\n    },\r\n\r\n    getSourceElement: function() {\r\n\r\n        var source = this.get('source');\r\n\r\n        return (source && source.id && this.graph && this.graph.getCell(source.id)) || null;\r\n    },\r\n\r\n    getTargetElement: function() {\r\n\r\n        var target = this.get('target');\r\n\r\n        return (target && target.id && this.graph && this.graph.getCell(target.id)) || null;\r\n    },\r\n\r\n    // Returns the common ancestor for the source element,\r\n    // target element and the link itself.\r\n    getRelationshipAncestor: function() {\r\n\r\n        var connectionAncestor;\r\n\r\n        if (this.graph) {\r\n\r\n            var cells = _.compact([\r\n                this,\r\n                this.getSourceElement(), // null if source is a point\r\n                this.getTargetElement() // null if target is a point\r\n            ]);\r\n\r\n            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\r\n        }\r\n\r\n        return connectionAncestor || null;\r\n    },\r\n\r\n    // Is source, target and the link itself embedded in a given element?\r\n    isRelationshipEmbeddedIn: function(element) {\r\n\r\n        var elementId = _.isString(element) ? element : element.id;\r\n        var ancestor = this.getRelationshipAncestor();\r\n\r\n        return !!ancestor && (ancestor.id === elementId || ancestor.isEmbeddedIn(elementId));\r\n    }\r\n},\r\n    {\r\n        endsEqual: function(a, b) {\r\n\r\n            var portsEqual = a.port === b.port || !a.port && !b.port;\r\n            return a.id === b.id && portsEqual;\r\n        }\r\n    });\r\n\r\n\r\n// joint.dia.Link base view and controller.\r\n// ----------------------------------------\r\n\r\njoint.dia.LinkView = joint.dia.CellView.extend({\r\n\r\n    className: function() {\r\n\r\n        var classNames = joint.dia.CellView.prototype.className.apply(this).split(' ');\r\n\r\n        classNames.push('link');\r\n\r\n        return classNames.join(' ');\r\n    },\r\n\r\n    options: {\r\n\r\n        shortLinkLength: 100,\r\n        doubleLinkTools: false,\r\n        longLinkLength: 160,\r\n        linkToolsOffset: 40,\r\n        doubleLinkToolsOffset: 60,\r\n        sampleInterval: 50\r\n    },\r\n\r\n    _z: null,\r\n\r\n    initialize: function(options) {\r\n\r\n        joint.dia.CellView.prototype.initialize.apply(this, arguments);\r\n\r\n        // create methods in prototype, so they can be accessed from any instance and\r\n        // don't need to be create over and over\r\n        if (typeof this.constructor.prototype.watchSource !== 'function') {\r\n            this.constructor.prototype.watchSource = this.createWatcher('source');\r\n            this.constructor.prototype.watchTarget = this.createWatcher('target');\r\n        }\r\n\r\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\r\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\r\n        // nodes in `updateLabelPosition()` in order to update the label positions.\r\n        this._labelCache = {};\r\n\r\n        // keeps markers bboxes and positions again for quicker access\r\n        this._markerCache = {};\r\n\r\n        // bind events\r\n        this.startListening();\r\n    },\r\n\r\n    startListening: function() {\r\n\r\n        var model = this.model;\r\n\r\n        this.listenTo(model, 'change:markup', this.render);\r\n        this.listenTo(model, 'change:smooth change:manhattan change:router change:connector', this.update);\r\n        this.listenTo(model, 'change:toolMarkup', this.onToolsChange);\r\n        this.listenTo(model, 'change:labels change:labelMarkup', this.onLabelsChange);\r\n        this.listenTo(model, 'change:vertices change:vertexMarkup', this.onVerticesChange);\r\n        this.listenTo(model, 'change:source', this.onSourceChange);\r\n        this.listenTo(model, 'change:target', this.onTargetChange);\r\n    },\r\n\r\n    onSourceChange: function(cell, source, opt) {\r\n\r\n        // Start watching the new source model.\r\n        this.watchSource(cell, source);\r\n        // This handler is called when the source attribute is changed.\r\n        // This can happen either when someone reconnects the link (or moves arrowhead),\r\n        // or when an embedded link is translated by its ancestor.\r\n        // 1. Always do update.\r\n        // 2. Do update only if the opposite end ('target') is also a point.\r\n        if (!opt.translateBy || !this.model.get('target').id) {\r\n            opt.updateConnectionOnly = true;\r\n            this.update(this.model, null, opt);\r\n        }\r\n    },\r\n\r\n    onTargetChange: function(cell, target, opt) {\r\n\r\n        // Start watching the new target model.\r\n        this.watchTarget(cell, target);\r\n        // See `onSourceChange` method.\r\n        if (!opt.translateBy) {\r\n            opt.updateConnectionOnly = true;\r\n            this.update(this.model, null, opt);\r\n        }\r\n    },\r\n\r\n    onVerticesChange: function(cell, changed, opt) {\r\n\r\n        this.renderVertexMarkers();\r\n\r\n        // If the vertices have been changed by a translation we do update only if the link was\r\n        // the only link that was translated. If the link was translated via another element which the link\r\n        // is embedded in, this element will be translated as well and that triggers an update.\r\n        // Note that all embeds in a model are sorted - first comes links, then elements.\r\n        if (!opt.translateBy || opt.translateBy === this.model.id) {\r\n            // Vertices were changed (not as a reaction on translate)\r\n            // or link.translate() was called or\r\n            opt.updateConnectionOnly = true;\r\n            this.update(cell, null, opt);\r\n        }\r\n    },\r\n\r\n    onToolsChange: function() {\r\n\r\n        this.renderTools().updateToolsPosition();\r\n    },\r\n\r\n    onLabelsChange: function() {\r\n\r\n        this.renderLabels().updateLabelPositions();\r\n    },\r\n\r\n    // Rendering\r\n    //----------\r\n\r\n    render: function() {\r\n\r\n        this.$el.empty();\r\n\r\n        // A special markup can be given in the `properties.markup` property. This might be handy\r\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\r\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\r\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\r\n        // special markup passed in `properties.markup`.\r\n        var model = this.model;\r\n        var markup = model.get('markup') || model.markup;\r\n        var children = V(markup);\r\n\r\n        // custom markup may contain only one children\r\n        if (!_.isArray(children)) children = [children];\r\n\r\n        // Cache all children elements for quicker access.\r\n        this._V = {}; // vectorized markup;\r\n        _.each(children, function(child) {\r\n\r\n            var className = child.attr('class');\r\n\r\n            if (className) {\r\n                // Strip the joint class name prefix, if there is one.\r\n                className = joint.util.removeClassNamePrefix(className);\r\n                this._V[$.camelCase(className)] = child;\r\n            }\r\n\r\n        }, this);\r\n\r\n        // Only the connection path is mandatory\r\n        if (!this._V.connection) throw new Error('link: no connection path in the markup');\r\n\r\n        // partial rendering\r\n        this.renderTools();\r\n        this.renderVertexMarkers();\r\n        this.renderArrowheadMarkers();\r\n\r\n        this.vel.append(children);\r\n\r\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\r\n        // returns zero values)\r\n        this.renderLabels();\r\n\r\n        // start watching the ends of the link for changes\r\n        this.watchSource(model, model.get('source'))\r\n            .watchTarget(model, model.get('target'))\r\n            .update();\r\n\r\n        return this;\r\n    },\r\n\r\n    renderLabels: function() {\r\n\r\n        var vLabels = this._V.labels;\r\n        if (!vLabels) {\r\n            return this;\r\n        }\r\n\r\n        vLabels.empty();\r\n\r\n        var model = this.model;\r\n        var labels = model.get('labels') || [];\r\n        var labelCache = this._labelCache = {};\r\n        var labelsCount = labels.length;\r\n        if (labelsCount === 0) {\r\n            return this;\r\n        }\r\n\r\n        var labelTemplate = joint.util.template(model.get('labelMarkup') || model.labelMarkup);\r\n        // This is a prepared instance of a vectorized SVGDOM node for the label element resulting from\r\n        // compilation of the labelTemplate. The purpose is that all labels will just `clone()` this\r\n        // node to create a duplicate.\r\n        var labelNodeInstance = V(labelTemplate());\r\n        var canLabelMove = this.can('labelMove');\r\n\r\n        for (var i = 0; i < labelsCount; i++) {\r\n\r\n            var label = labels[i];\r\n            var labelMarkup = label.markup;\r\n            // Cache label nodes so that the `updateLabels()` can just update the label node positions.\r\n            var vLabelNode = labelCache[i] = (labelMarkup)\r\n                ? V('g').append(V(labelMarkup))\r\n                : labelNodeInstance.clone();\r\n\r\n            vLabelNode\r\n                .addClass('label')\r\n                .attr({\r\n                    'label-idx': i,\r\n                    'cursor': (canLabelMove ? 'move' : 'default')\r\n                })\r\n                .appendTo(vLabels);\r\n\r\n            var labelAttrs = label.attrs;\r\n            if (!labelMarkup) {\r\n                // Default attributes to maintain backwards compatibility\r\n                labelAttrs = _.merge({\r\n                    text: {\r\n                        textAnchor: 'middle',\r\n                        fontSize: 14,\r\n                        pointerEvents: 'none',\r\n                        yAlignment: 'middle'\r\n                    },\r\n                    rect: {\r\n                        ref: 'text',\r\n                        fill: 'white',\r\n                        rx: 3,\r\n                        ry: 3,\r\n                        refWidth: 1,\r\n                        refHeight: 1,\r\n                        refX: 0,\r\n                        refY: 0\r\n                    }\r\n                }, labelAttrs);\r\n            }\r\n\r\n            this.updateDOMSubtreeAttributes(vLabelNode.node, labelAttrs);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    renderTools: function() {\r\n\r\n        if (!this._V.linkTools) return this;\r\n\r\n        // Tools are a group of clickable elements that manipulate the whole link.\r\n        // A good example of this is the remove tool that removes the whole link.\r\n        // Tools appear after hovering the link close to the `source` element/point of the link\r\n        // but are offset a bit so that they don't cover the `marker-arrowhead`.\r\n\r\n        var $tools = $(this._V.linkTools.node).empty();\r\n        var toolTemplate = joint.util.template(this.model.get('toolMarkup') || this.model.toolMarkup);\r\n        var tool = V(toolTemplate());\r\n\r\n        $tools.append(tool.node);\r\n\r\n        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\r\n        this._toolCache = tool;\r\n\r\n        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\r\n        // link as well but only if the link is longer than `longLinkLength`.\r\n        if (this.options.doubleLinkTools) {\r\n\r\n            var tool2;\r\n            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\r\n                toolTemplate = joint.util.template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\r\n                tool2 = V(toolTemplate());\r\n            } else {\r\n                tool2 = tool.clone();\r\n            }\r\n\r\n            $tools.append(tool2.node);\r\n            this._tool2Cache = tool2;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    renderVertexMarkers: function() {\r\n\r\n        if (!this._V.markerVertices) return this;\r\n\r\n        var $markerVertices = $(this._V.markerVertices.node).empty();\r\n\r\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\r\n        // if default styling (elements) are not desired. This makes it possible to use any\r\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\r\n        var markupTemplate = joint.util.template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\r\n\r\n        _.each(this.model.get('vertices'), function(vertex, idx) {\r\n\r\n            $markerVertices.append(V(markupTemplate(_.extend({ idx: idx }, vertex))).node);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    renderArrowheadMarkers: function() {\r\n\r\n        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\r\n        if (!this._V.markerArrowheads) return this;\r\n\r\n        var $markerArrowheads = $(this._V.markerArrowheads.node);\r\n\r\n        $markerArrowheads.empty();\r\n\r\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\r\n        // if default styling (elements) are not desired. This makes it possible to use any\r\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\r\n        var markupTemplate = joint.util.template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\r\n\r\n        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\r\n        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\r\n\r\n        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\r\n\r\n        return this;\r\n    },\r\n\r\n    // Updating\r\n    //---------\r\n\r\n    // Default is to process the `attrs` object and set attributes on subelements based on the selectors.\r\n    update: function(model, attributes, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        if (!opt.updateConnectionOnly) {\r\n            // update SVG attributes defined by 'attrs/'.\r\n            this.updateDOMSubtreeAttributes(this.el, this.model.attr());\r\n        }\r\n\r\n        // update the link path, label position etc.\r\n        this.updateConnection(opt);\r\n        this.updateLabelPositions();\r\n        this.updateToolsPosition();\r\n        this.updateArrowheadMarkers();\r\n\r\n        // Local perpendicular flag (as opposed to one defined on paper).\r\n        // Could be enabled inside a connector/router. It's valid only\r\n        // during the update execution.\r\n        this.options.perpendicular = null;\r\n        // Mark that postponed update has been already executed.\r\n        this.updatePostponed = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    updateConnection: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var model = this.model;\r\n        var route;\r\n\r\n        if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\r\n            // The link is being translated by an ancestor that will\r\n            // shift source point, target point and all vertices\r\n            // by an equal distance.\r\n            var tx = opt.tx || 0;\r\n            var ty = opt.ty || 0;\r\n\r\n            route = this.route =  _.map(this.route, function(point) {\r\n                // translate point by point by delta translation\r\n                return g.point(point).offset(tx, ty);\r\n            });\r\n\r\n            // translate source and target connection and marker points.\r\n            this._translateConnectionPoints(tx, ty);\r\n\r\n        } else {\r\n            // Necessary path finding\r\n            route = this.route = this.findRoute(model.get('vertices') || [], opt);\r\n            // finds all the connection points taking new vertices into account\r\n            this._findConnectionPoints(route);\r\n        }\r\n\r\n        var pathData = this.getPathData(route);\r\n\r\n        // The markup needs to contain a `.connection`\r\n        this._V.connection.attr('d', pathData);\r\n        this._V.connectionWrap && this._V.connectionWrap.attr('d', pathData);\r\n\r\n        this._translateAndAutoOrientArrows(this._V.markerSource, this._V.markerTarget);\r\n    },\r\n\r\n    _findConnectionPoints: function(vertices) {\r\n\r\n        // cache source and target points\r\n        var sourcePoint, targetPoint, sourceMarkerPoint, targetMarkerPoint;\r\n\r\n        var firstVertex = _.first(vertices);\r\n\r\n        sourcePoint = this.getConnectionPoint(\r\n            'source', this.model.get('source'), firstVertex || this.model.get('target')\r\n        ).round();\r\n\r\n        var lastVertex = _.last(vertices);\r\n\r\n        targetPoint = this.getConnectionPoint(\r\n            'target', this.model.get('target'), lastVertex || sourcePoint\r\n        ).round();\r\n\r\n        // Move the source point by the width of the marker taking into account\r\n        // its scale around x-axis. Note that scale is the only transform that\r\n        // makes sense to be set in `.marker-source` attributes object\r\n        // as all other transforms (translate/rotate) will be replaced\r\n        // by the `translateAndAutoOrient()` function.\r\n        var cache = this._markerCache;\r\n\r\n        if (this._V.markerSource) {\r\n\r\n            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.bbox(true);\r\n\r\n            sourceMarkerPoint = g.point(sourcePoint).move(\r\n                firstVertex || targetPoint,\r\n                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\r\n            ).round();\r\n        }\r\n\r\n        if (this._V.markerTarget) {\r\n\r\n            cache.targetBBox = cache.targetBBox || this._V.markerTarget.bbox(true);\r\n\r\n            targetMarkerPoint = g.point(targetPoint).move(\r\n                lastVertex || sourcePoint,\r\n                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\r\n            ).round();\r\n        }\r\n\r\n        // if there was no markup for the marker, use the connection point.\r\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\r\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\r\n\r\n        // make connection points public\r\n        this.sourcePoint = sourcePoint;\r\n        this.targetPoint = targetPoint;\r\n    },\r\n\r\n    _translateConnectionPoints: function(tx, ty) {\r\n\r\n        var cache = this._markerCache;\r\n\r\n        cache.sourcePoint.offset(tx, ty);\r\n        cache.targetPoint.offset(tx, ty);\r\n        this.sourcePoint.offset(tx, ty);\r\n        this.targetPoint.offset(tx, ty);\r\n    },\r\n\r\n    updateLabelPositions: function() {\r\n\r\n        if (!this._V.labels) return this;\r\n\r\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\r\n        // by their indexes in the `this.get('labels')` array. This is done in the `renderLabels()` method.\r\n\r\n        var labels = this.model.get('labels') || [];\r\n        if (!labels.length) return this;\r\n\r\n        var connectionElement = this._V.connection.node;\r\n        var connectionLength = connectionElement.getTotalLength();\r\n\r\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\r\n        // In that case we won't update labels at all.\r\n        if (!_.isNaN(connectionLength)) {\r\n\r\n            var samples;\r\n\r\n            _.each(labels, function(label, idx) {\r\n\r\n                var position = label.position;\r\n                var distance = _.isObject(position) ? position.distance : position;\r\n                var offset = _.isObject(position) ? position.offset : { x: 0, y: 0 };\r\n\r\n                if (_.isFinite(distance)) {\r\n                    distance = (distance > connectionLength) ? connectionLength : distance; // sanity check\r\n                    distance = (distance < 0) ? connectionLength + distance : distance;\r\n                    distance = (distance > 1) ? distance : connectionLength * distance;\r\n                } else {\r\n                    distance = connectionLength / 2;\r\n                }\r\n\r\n                var labelCoordinates = connectionElement.getPointAtLength(distance);\r\n\r\n                if (_.isObject(offset)) {\r\n\r\n                    // Just offset the label by the x,y provided in the offset object.\r\n                    labelCoordinates = g.point(labelCoordinates).offset(offset);\r\n\r\n                } else if (_.isFinite(offset)) {\r\n\r\n                    if (!samples) {\r\n                        samples = this._samples || this._V.connection.sample(this.options.sampleInterval);\r\n                    }\r\n\r\n                    // Offset the label by the amount provided in `offset` to an either\r\n                    // side of the link.\r\n\r\n                    // 1. Find the closest sample & its left and right neighbours.\r\n                    var minSqDistance = Infinity;\r\n                    var closestSampleIndex, sample, sqDistance;\r\n                    for (var i = 0; i < samples.length; i++) {\r\n                        sample = samples[i];\r\n                        sqDistance = g.line(sample, labelCoordinates).squaredLength();\r\n                        if (sqDistance < minSqDistance) {\r\n                            minSqDistance = sqDistance;\r\n                            closestSampleIndex = i;\r\n                        }\r\n                    }\r\n                    var prevSample = samples[closestSampleIndex - 1];\r\n                    var nextSample = samples[closestSampleIndex + 1];\r\n\r\n                    // 2. Offset the label on the perpendicular line between\r\n                    // the current label coordinate (\"at `distance`\") and\r\n                    // the next sample.\r\n                    var angle = 0;\r\n                    if (nextSample) {\r\n                        angle = g.point(labelCoordinates).theta(nextSample);\r\n                    } else if (prevSample) {\r\n                        angle = g.point(prevSample).theta(labelCoordinates);\r\n                    }\r\n                    labelCoordinates = g.point(labelCoordinates).offset(offset).rotate(labelCoordinates, angle - 90);\r\n                }\r\n\r\n                this._labelCache[idx].attr('transform', 'translate(' + labelCoordinates.x + ', ' + labelCoordinates.y + ')');\r\n\r\n            }, this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n\r\n    updateToolsPosition: function() {\r\n\r\n        if (!this._V.linkTools) return this;\r\n\r\n        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\r\n        // Note that the offset is hardcoded here. The offset should be always\r\n        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\r\n        // this up all the time would be slow.\r\n\r\n        var scale = '';\r\n        var offset = this.options.linkToolsOffset;\r\n        var connectionLength = this.getConnectionLength();\r\n\r\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\r\n        // In that case we won't update tools position at all.\r\n        if (!_.isNaN(connectionLength)) {\r\n\r\n            // If the link is too short, make the tools half the size and the offset twice as low.\r\n            if (connectionLength < this.options.shortLinkLength) {\r\n                scale = 'scale(.5)';\r\n                offset /= 2;\r\n            }\r\n\r\n            var toolPosition = this.getPointAtLength(offset);\r\n\r\n            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\r\n\r\n            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\r\n\r\n                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\r\n\r\n                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\r\n                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\r\n                this._tool2Cache.attr('visibility', 'visible');\r\n\r\n            } else if (this.options.doubleLinkTools) {\r\n\r\n                this._tool2Cache.attr('visibility', 'hidden');\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n\r\n    updateArrowheadMarkers: function() {\r\n\r\n        if (!this._V.markerArrowheads) return this;\r\n\r\n        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\r\n        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\r\n\r\n        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\r\n        this._V.sourceArrowhead.scale(sx);\r\n        this._V.targetArrowhead.scale(sx);\r\n\r\n        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\r\n\r\n        return this;\r\n    },\r\n\r\n    // Returns a function observing changes on an end of the link. If a change happens and new end is a new model,\r\n    // it stops listening on the previous one and starts listening to the new one.\r\n    createWatcher: function(endType) {\r\n\r\n        // create handler for specific end type (source|target).\r\n        var onModelChange = _.partial(this.onEndModelChange, endType);\r\n\r\n        function watchEndModel(link, end) {\r\n\r\n            end = end || {};\r\n\r\n            var endModel = null;\r\n            var previousEnd = link.previous(endType) || {};\r\n\r\n            if (previousEnd.id) {\r\n                this.stopListening(this.paper.getModelById(previousEnd.id), 'change', onModelChange);\r\n            }\r\n\r\n            if (end.id) {\r\n                // If the observed model changes, it caches a new bbox and do the link update.\r\n                endModel = this.paper.getModelById(end.id);\r\n                this.listenTo(endModel, 'change', onModelChange);\r\n            }\r\n\r\n            onModelChange.call(this, endModel, { cacheOnly: true });\r\n\r\n            return this;\r\n        }\r\n\r\n        return watchEndModel;\r\n    },\r\n\r\n    onEndModelChange: function(endType, endModel, opt) {\r\n\r\n        var doUpdate = !opt.cacheOnly;\r\n        var model = this.model;\r\n        var end = model.get(endType) || {};\r\n\r\n        if (endModel) {\r\n\r\n            var selector = this.constructor.makeSelector(end);\r\n            var oppositeEndType = endType == 'source' ? 'target' : 'source';\r\n            var oppositeEnd = model.get(oppositeEndType) || {};\r\n            var oppositeSelector = oppositeEnd.id && this.constructor.makeSelector(oppositeEnd);\r\n\r\n            // Caching end models bounding boxes.\r\n            // If `opt.handleBy` equals the client-side ID of this link view and it is a loop link, then we already cached\r\n            // the bounding boxes in the previous turn (e.g. for loop link, the change:source event is followed\r\n            // by change:target and so on change:source, we already chached the bounding boxes of - the same - element).\r\n            if (opt.handleBy === this.cid && selector == oppositeSelector) {\r\n\r\n                // Source and target elements are identical. We're dealing with a loop link. We are handling `change` event for the\r\n                // second time now. There is no need to calculate bbox and find magnet element again.\r\n                // It was calculated already for opposite link end.\r\n                this[endType + 'BBox'] = this[oppositeEndType + 'BBox'];\r\n                this[endType + 'View'] = this[oppositeEndType + 'View'];\r\n                this[endType + 'Magnet'] = this[oppositeEndType + 'Magnet'];\r\n\r\n            } else if (opt.translateBy) {\r\n                // `opt.translateBy` optimizes the way we calculate bounding box of the source/target element.\r\n                // If `opt.translateBy` is an ID of the element that was originally translated. This allows us\r\n                // to just offset the cached bounding box by the translation instead of calculating the bounding\r\n                // box from scratch on every translate.\r\n\r\n                var bbox = this[endType + 'BBox'];\r\n                bbox.x += opt.tx;\r\n                bbox.y += opt.ty;\r\n\r\n            } else {\r\n                // The slowest path, source/target could have been rotated or resized or any attribute\r\n                // that affects the bounding box of the view might have been changed.\r\n\r\n                var view = this.paper.findViewByModel(end.id);\r\n                var magnetElement = view.el.querySelector(selector);\r\n\r\n                this[endType + 'BBox'] = view.getStrokeBBox(magnetElement);\r\n                this[endType + 'View'] = view;\r\n                this[endType + 'Magnet'] = magnetElement;\r\n            }\r\n\r\n            if (opt.handleBy === this.cid && opt.translateBy &&\r\n                model.isEmbeddedIn(endModel) &&\r\n                !_.isEmpty(model.get('vertices'))) {\r\n                // Loop link whose element was translated and that has vertices (that need to be translated with\r\n                // the parent in which my element is embedded).\r\n                // If the link is embedded, has a loop and vertices and the end model\r\n                // has been translated, do not update yet. There are vertices still to be updated (change:vertices\r\n                // event will come in the next turn).\r\n                doUpdate = false;\r\n            }\r\n\r\n            if (!this.updatePostponed && oppositeEnd.id) {\r\n                // The update was not postponed (that can happen e.g. on the first change event) and the opposite\r\n                // end is a model (opposite end is the opposite end of the link we're just updating, e.g. if\r\n                // we're reacting on change:source event, the oppositeEnd is the target model).\r\n\r\n                var oppositeEndModel = this.paper.getModelById(oppositeEnd.id);\r\n\r\n                // Passing `handleBy` flag via event option.\r\n                // Note that if we are listening to the same model for event 'change' twice.\r\n                // The same event will be handled by this method also twice.\r\n                if (end.id === oppositeEnd.id) {\r\n                    // We're dealing with a loop link. Tell the handlers in the next turn that they should update\r\n                    // the link instead of me. (We know for sure there will be a next turn because\r\n                    // loop links react on at least two events: change on the source model followed by a change on\r\n                    // the target model).\r\n                    opt.handleBy = this.cid;\r\n                }\r\n\r\n                if (opt.handleBy === this.cid || (opt.translateBy && oppositeEndModel.isEmbeddedIn(opt.translateBy))) {\r\n\r\n                    // Here are two options:\r\n                    // - Source and target are connected to the same model (not necessarily the same port).\r\n                    // - Both end models are translated by the same ancestor. We know that opposite end\r\n                    //   model will be translated in the next turn as well.\r\n                    // In both situations there will be more changes on the model that trigger an\r\n                    // update. So there is no need to update the linkView yet.\r\n                    this.updatePostponed = true;\r\n                    doUpdate = false;\r\n                }\r\n            }\r\n\r\n        } else {\r\n\r\n            // the link end is a point ~ rect 1x1\r\n            this[endType + 'BBox'] = g.rect(end.x || 0, end.y || 0, 1, 1);\r\n            this[endType + 'View'] = this[endType + 'Magnet'] = null;\r\n        }\r\n\r\n        if (doUpdate) {\r\n            opt.updateConnectionOnly = true;\r\n            this.update(model, null, opt);\r\n        }\r\n    },\r\n\r\n    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\r\n\r\n        // Make the markers \"point\" to their sticky points being auto-oriented towards\r\n        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\r\n        if (sourceArrow) {\r\n            sourceArrow.translateAndAutoOrient(\r\n                this.sourcePoint,\r\n                _.first(this.route) || this.targetPoint,\r\n                this.paper.viewport\r\n            );\r\n        }\r\n\r\n        if (targetArrow) {\r\n            targetArrow.translateAndAutoOrient(\r\n                this.targetPoint,\r\n                _.last(this.route) || this.sourcePoint,\r\n                this.paper.viewport\r\n            );\r\n        }\r\n    },\r\n\r\n    removeVertex: function(idx) {\r\n\r\n        var vertices = _.clone(this.model.get('vertices'));\r\n\r\n        if (vertices && vertices.length) {\r\n\r\n            vertices.splice(idx, 1);\r\n            this.model.set('vertices', vertices, { ui: true });\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // This method ads a new vertex to the `vertices` array of `.connection`. This method\r\n    // uses a heuristic to find the index at which the new `vertex` should be placed at assuming\r\n    // the new vertex is somewhere on the path.\r\n    addVertex: function(vertex) {\r\n\r\n        // As it is very hard to find a correct index of the newly created vertex,\r\n        // a little heuristics is taking place here.\r\n        // The heuristics checks if length of the newly created\r\n        // path is lot more than length of the old path. If this is the case,\r\n        // new vertex was probably put into a wrong index.\r\n        // Try to put it into another index and repeat the heuristics again.\r\n\r\n        var vertices = (this.model.get('vertices') || []).slice();\r\n        // Store the original vertices for a later revert if needed.\r\n        var originalVertices = vertices.slice();\r\n\r\n        // A `<path>` element used to compute the length of the path during heuristics.\r\n        var path = this._V.connection.node.cloneNode(false);\r\n\r\n        // Length of the original path.\r\n        var originalPathLength = path.getTotalLength();\r\n        // Current path length.\r\n        var pathLength;\r\n        // Tolerance determines the highest possible difference between the length\r\n        // of the old and new path. The number has been chosen heuristically.\r\n        var pathLengthTolerance = 20;\r\n        // Total number of vertices including source and target points.\r\n        var idx = vertices.length + 1;\r\n\r\n        // Loop through all possible indexes and check if the difference between\r\n        // path lengths changes significantly. If not, the found index is\r\n        // most probably the right one.\r\n        while (idx--) {\r\n\r\n            vertices.splice(idx, 0, vertex);\r\n            V(path).attr('d', this.getPathData(this.findRoute(vertices)));\r\n\r\n            pathLength = path.getTotalLength();\r\n\r\n            // Check if the path lengths changed significantly.\r\n            if (pathLength - originalPathLength > pathLengthTolerance) {\r\n\r\n                // Revert vertices to the original array. The path length has changed too much\r\n                // so that the index was not found yet.\r\n                vertices = originalVertices.slice();\r\n\r\n            } else {\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (idx === -1) {\r\n            // If no suitable index was found for such a vertex, make the vertex the first one.\r\n            idx = 0;\r\n            vertices.splice(idx, 0, vertex);\r\n        }\r\n\r\n        this.model.set('vertices', vertices, { ui: true });\r\n\r\n        return idx;\r\n    },\r\n\r\n    // Send a token (an SVG element, usually a circle) along the connection path.\r\n    // Example: `paper.findViewByModel(link).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\r\n    // `duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\r\n    // `callback` is optional and is a function to be called once the token reaches the target.\r\n    sendToken: function(token, duration, callback) {\r\n\r\n        duration = duration || 1000;\r\n\r\n        V(this.paper.viewport).append(token);\r\n        V(token).animateAlongPath({ dur: duration + 'ms', repeatCount: 1 }, this._V.connection.node);\r\n        _.delay(function() { V(token).remove(); callback && callback(); }, duration);\r\n    },\r\n\r\n    findRoute: function(oldVertices) {\r\n\r\n        var namespace = joint.routers;\r\n        var router = this.model.get('router');\r\n        var defaultRouter = this.paper.options.defaultRouter;\r\n\r\n        if (!router) {\r\n\r\n            if (this.model.get('manhattan')) {\r\n                // backwards compability\r\n                router = { name: 'orthogonal' };\r\n            } else if (defaultRouter) {\r\n                router = defaultRouter;\r\n            } else {\r\n                return oldVertices;\r\n            }\r\n        }\r\n\r\n        var args = router.args || {};\r\n        var routerFn = _.isFunction(router) ? router : namespace[router.name];\r\n\r\n        if (!_.isFunction(routerFn)) {\r\n            throw new Error('unknown router: \"' + router.name + '\"');\r\n        }\r\n\r\n        var newVertices = routerFn.call(this, oldVertices || [], args, this);\r\n\r\n        return newVertices;\r\n    },\r\n\r\n    // Return the `d` attribute value of the `<path>` element representing the link\r\n    // between `source` and `target`.\r\n    getPathData: function(vertices) {\r\n\r\n        var namespace = joint.connectors;\r\n        var connector = this.model.get('connector');\r\n        var defaultConnector = this.paper.options.defaultConnector;\r\n\r\n        if (!connector) {\r\n\r\n            // backwards compability\r\n            if (this.model.get('smooth')) {\r\n                connector = { name: 'smooth' };\r\n            } else {\r\n                connector = defaultConnector || {};\r\n            }\r\n        }\r\n\r\n        var connectorFn = _.isFunction(connector) ? connector : namespace[connector.name];\r\n        var args = connector.args || {};\r\n\r\n        if (!_.isFunction(connectorFn)) {\r\n            throw new Error('unknown connector: \"' + connector.name + '\"');\r\n        }\r\n\r\n        var pathData = connectorFn.call(\r\n            this,\r\n            this._markerCache.sourcePoint, // Note that the value is translated by the size\r\n            this._markerCache.targetPoint, // of the marker. (We'r not using this.sourcePoint)\r\n            vertices || (this.model.get('vertices') || {}),\r\n            args, // options\r\n            this\r\n        );\r\n\r\n        return pathData;\r\n    },\r\n\r\n    // Find a point that is the start of the connection.\r\n    // If `selectorOrPoint` is a point, then we're done and that point is the start of the connection.\r\n    // If the `selectorOrPoint` is an element however, we need to know a reference point (or element)\r\n    // that the link leads to in order to determine the start of the connection on the original element.\r\n    getConnectionPoint: function(end, selectorOrPoint, referenceSelectorOrPoint) {\r\n\r\n        var spot;\r\n\r\n        // If the `selectorOrPoint` (or `referenceSelectorOrPoint`) is `undefined`, the `source`/`target` of the link model is `undefined`.\r\n        // We want to allow this however so that one can create links such as `var link = new joint.dia.Link` and\r\n        // set the `source`/`target` later.\r\n        _.isEmpty(selectorOrPoint) && (selectorOrPoint = { x: 0, y: 0 });\r\n        _.isEmpty(referenceSelectorOrPoint) && (referenceSelectorOrPoint = { x: 0, y: 0 });\r\n\r\n        if (!selectorOrPoint.id) {\r\n\r\n            // If the source is a point, we don't need a reference point to find the sticky point of connection.\r\n            spot = g.Point(selectorOrPoint);\r\n\r\n        } else {\r\n\r\n            // If the source is an element, we need to find a point on the element boundary that is closest\r\n            // to the reference point (or reference element).\r\n            // Get the bounding box of the spot relative to the paper viewport. This is necessary\r\n            // in order to follow paper viewport transformations (scale/rotate).\r\n            // `_sourceBbox` (`_targetBbox`) comes from `_sourceBboxUpdate` (`_sourceBboxUpdate`)\r\n            // method, it exists since first render and are automatically updated\r\n            var spotBBox = g.Rect(end === 'source' ? this.sourceBBox : this.targetBBox);\r\n\r\n            var reference;\r\n\r\n            if (!referenceSelectorOrPoint.id) {\r\n\r\n                // Reference was passed as a point, therefore, we're ready to find the sticky point of connection on the source element.\r\n                reference = g.Point(referenceSelectorOrPoint);\r\n\r\n            } else {\r\n\r\n                // Reference was passed as an element, therefore we need to find a point on the reference\r\n                // element boundary closest to the source element.\r\n                // Get the bounding box of the spot relative to the paper viewport. This is necessary\r\n                // in order to follow paper viewport transformations (scale/rotate).\r\n                var referenceBBox = g.Rect(end === 'source' ? this.targetBBox : this.sourceBBox);\r\n\r\n                reference = referenceBBox.intersectionWithLineFromCenterToPoint(spotBBox.center());\r\n                reference = reference || referenceBBox.center();\r\n            }\r\n\r\n            var paperOptions = this.paper.options;\r\n            // If `perpendicularLinks` flag is set on the paper and there are vertices\r\n            // on the link, then try to find a connection point that makes the link perpendicular\r\n            // even though the link won't point to the center of the targeted object.\r\n            if (paperOptions.perpendicularLinks || this.options.perpendicular) {\r\n\r\n                var nearestSide;\r\n                var spotOrigin = spotBBox.origin();\r\n                var spotCorner = spotBBox.corner();\r\n\r\n                if (spotOrigin.y <= reference.y && reference.y <= spotCorner.y) {\r\n\r\n                    nearestSide = spotBBox.sideNearestToPoint(reference);\r\n                    switch (nearestSide) {\r\n                        case 'left':\r\n                            spot = g.Point(spotOrigin.x, reference.y);\r\n                            break;\r\n                        case 'right':\r\n                            spot = g.Point(spotCorner.x, reference.y);\r\n                            break;\r\n                        default:\r\n                            spot = spotBBox.center();\r\n                            break;\r\n                    }\r\n\r\n                } else if (spotOrigin.x <= reference.x && reference.x <= spotCorner.x) {\r\n\r\n                    nearestSide = spotBBox.sideNearestToPoint(reference);\r\n                    switch (nearestSide) {\r\n                        case 'top':\r\n                            spot = g.Point(reference.x, spotOrigin.y);\r\n                            break;\r\n                        case 'bottom':\r\n                            spot = g.Point(reference.x, spotCorner.y);\r\n                            break;\r\n                        default:\r\n                            spot = spotBBox.center();\r\n                            break;\r\n                    }\r\n\r\n                } else {\r\n\r\n                    // If there is no intersection horizontally or vertically with the object bounding box,\r\n                    // then we fall back to the regular situation finding straight line (not perpendicular)\r\n                    // between the object and the reference point.\r\n                    spot = spotBBox.intersectionWithLineFromCenterToPoint(reference);\r\n                    spot = spot || spotBBox.center();\r\n                }\r\n\r\n            } else if (paperOptions.linkConnectionPoint) {\r\n\r\n                var view = end === 'target' ? this.targetView : this.sourceView;\r\n                var magnet = end === 'target' ? this.targetMagnet : this.sourceMagnet;\r\n\r\n                spot = paperOptions.linkConnectionPoint(this, view, magnet, reference);\r\n\r\n            } else {\r\n\r\n                spot = spotBBox.intersectionWithLineFromCenterToPoint(reference);\r\n                spot = spot || spotBBox.center();\r\n            }\r\n        }\r\n\r\n        return spot;\r\n    },\r\n\r\n    // Public API\r\n    // ----------\r\n\r\n    getConnectionLength: function() {\r\n\r\n        return this._V.connection.node.getTotalLength();\r\n    },\r\n\r\n    getPointAtLength: function(length) {\r\n\r\n        return this._V.connection.node.getPointAtLength(length);\r\n    },\r\n\r\n    // Interaction. The controller part.\r\n    // ---------------------------------\r\n\r\n    _beforeArrowheadMove: function() {\r\n\r\n        this._z = this.model.get('z');\r\n        this.model.toFront();\r\n\r\n        // Let the pointer propagate throught the link view elements so that\r\n        // the `evt.target` is another element under the pointer, not the link itself.\r\n        this.el.style.pointerEvents = 'none';\r\n\r\n        if (this.paper.options.markAvailable) {\r\n            this._markAvailableMagnets();\r\n        }\r\n    },\r\n\r\n    _afterArrowheadMove: function() {\r\n\r\n        if (!_.isNull(this._z)) {\r\n            this.model.set('z', this._z, { ui: true });\r\n            this._z = null;\r\n        }\r\n\r\n        // Put `pointer-events` back to its original value. See `startArrowheadMove()` for explanation.\r\n        // Value `auto` doesn't work in IE9. We force to use `visiblePainted` instead.\r\n        // See `https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events`.\r\n        this.el.style.pointerEvents = 'visiblePainted';\r\n\r\n        if (this.paper.options.markAvailable) {\r\n            this._unmarkAvailableMagnets();\r\n        }\r\n    },\r\n\r\n    _createValidateConnectionArgs: function(arrowhead) {\r\n        // It makes sure the arguments for validateConnection have the following form:\r\n        // (source view, source magnet, target view, target magnet and link view)\r\n        var args = [];\r\n\r\n        args[4] = arrowhead;\r\n        args[5] = this;\r\n\r\n        var oppositeArrowhead;\r\n        var i = 0;\r\n        var j = 0;\r\n\r\n        if (arrowhead === 'source') {\r\n            i = 2;\r\n            oppositeArrowhead = 'target';\r\n        } else {\r\n            j = 2;\r\n            oppositeArrowhead = 'source';\r\n        }\r\n\r\n        var end = this.model.get(oppositeArrowhead);\r\n\r\n        if (end.id) {\r\n            args[i] = this.paper.findViewByModel(end.id);\r\n            args[i + 1] = end.selector && args[i].el.querySelector(end.selector);\r\n        }\r\n\r\n        function validateConnectionArgs(cellView, magnet) {\r\n            args[j] = cellView;\r\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\r\n            return args;\r\n        }\r\n\r\n        return validateConnectionArgs;\r\n    },\r\n\r\n    _markAvailableMagnets: function() {\r\n\r\n        function isMagnetAvailable(view, magnet) {\r\n            var paper = view.paper;\r\n            var validate = paper.options.validateConnection;\r\n            return validate.apply(paper, this._validateConnectionArgs(view, magnet));\r\n        }\r\n\r\n        var paper = this.paper;\r\n        var elements = paper.model.getElements();\r\n        this._marked = {};\r\n\r\n        _.chain(elements).map(paper.findViewByModel, paper).each(function(view) {\r\n\r\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\r\n            if (view.el.getAttribute('magnet') !== 'false') {\r\n                // Element wrapping group is also a magnet\r\n                magnets.push(view.el);\r\n            }\r\n\r\n            var availableMagnets = _.filter(magnets, _.partial(isMagnetAvailable, view), this);\r\n            if (availableMagnets.length > 0) {\r\n                // highlight all available magnets\r\n                _.each(availableMagnets, _.partial(view.highlight, _, { magnetAvailability: true }), view);\r\n                // highlight the entire view\r\n                view.highlight(null, { elementAvailability: true });\r\n\r\n                this._marked[view.model.id] = availableMagnets;\r\n            }\r\n\r\n        }, this).value();\r\n    },\r\n\r\n    _unmarkAvailableMagnets: function() {\r\n\r\n        _.each(this._marked, function(markedMagnets, id) {\r\n            var view = this.paper.findViewByModel(id);\r\n            if (view) {\r\n                _.each(markedMagnets, _.partial(view.unhighlight, _, { magnetAvailability: true }), view);\r\n                view.unhighlight(null, { elementAvailability: true });\r\n            }\r\n        }, this);\r\n\r\n        this._marked = null;\r\n    },\r\n\r\n    startArrowheadMove: function(end, opt) {\r\n\r\n        opt = _.defaults(opt || {}, { whenNotAllowed: 'revert' });\r\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\r\n        // move without need to click on the actual arrowhead dom element.\r\n        this._action = 'arrowhead-move';\r\n        this._whenNotAllowed = opt.whenNotAllowed;\r\n        this._arrowhead = end;\r\n        this._initialMagnet = this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null);\r\n        this._initialEnd = _.clone(this.model.get(end)) || { x: 0, y: 0 };\r\n        this._validateConnectionArgs = this._createValidateConnectionArgs(this._arrowhead);\r\n        this._beforeArrowheadMove();\r\n    },\r\n\r\n    pointerdown: function(evt, x, y) {\r\n\r\n        joint.dia.CellView.prototype.pointerdown.apply(this, arguments);\r\n        this.notify('link:pointerdown', evt, x, y);\r\n\r\n        this._dx = x;\r\n        this._dy = y;\r\n\r\n        // if are simulating pointerdown on a link during a magnet click, skip link interactions\r\n        if (evt.target.getAttribute('magnet') != null) return;\r\n\r\n        var className = joint.util.removeClassNamePrefix(evt.target.getAttribute('class'));\r\n        var parentClassName = joint.util.removeClassNamePrefix(evt.target.parentNode.getAttribute('class'));\r\n        var labelNode;\r\n        if (parentClassName === 'label') {\r\n            className = parentClassName;\r\n            labelNode = evt.target.parentNode;\r\n        } else {\r\n            labelNode = evt.target;\r\n        }\r\n\r\n        switch (className) {\r\n\r\n            case 'marker-vertex':\r\n                if (this.can('vertexMove')) {\r\n                    this._action = 'vertex-move';\r\n                    this._vertexIdx = evt.target.getAttribute('idx');\r\n                }\r\n                break;\r\n\r\n            case 'marker-vertex-remove':\r\n            case 'marker-vertex-remove-area':\r\n                if (this.can('vertexRemove')) {\r\n                    this.removeVertex(evt.target.getAttribute('idx'));\r\n                }\r\n                break;\r\n\r\n            case 'marker-arrowhead':\r\n                if (this.can('arrowheadMove')) {\r\n                    this.startArrowheadMove(evt.target.getAttribute('end'));\r\n                }\r\n                break;\r\n\r\n            case 'label':\r\n                if (this.can('labelMove')) {\r\n                    this._action = 'label-move';\r\n                    this._labelIdx = parseInt(V(labelNode).attr('label-idx'), 10);\r\n                    // Precalculate samples so that we don't have to do that\r\n                    // over and over again while dragging the label.\r\n                    this._samples = this._V.connection.sample(1);\r\n                    this._linkLength = this._V.connection.node.getTotalLength();\r\n                }\r\n                break;\r\n\r\n            default:\r\n\r\n                var targetParentEvent = evt.target.parentNode.getAttribute('event');\r\n                if (targetParentEvent) {\r\n                    if (this.can('useLinkTools')) {\r\n                        // `remove` event is built-in. Other custom events are triggered on the paper.\r\n                        if (targetParentEvent === 'remove') {\r\n                            this.model.remove();\r\n                        } else {\r\n                            this.notify(targetParentEvent, evt, x, y);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.can('vertexAdd')) {\r\n\r\n                        // Store the index at which the new vertex has just been placed.\r\n                        // We'll be update the very same vertex position in `pointermove()`.\r\n                        this._vertexIdx = this.addVertex({ x: x, y: y });\r\n                        this._action = 'vertex-move';\r\n                    }\r\n                }\r\n        }\r\n    },\r\n\r\n    pointermove: function(evt, x, y) {\r\n\r\n        switch (this._action) {\r\n\r\n            case 'vertex-move':\r\n\r\n                var vertices = _.clone(this.model.get('vertices'));\r\n                vertices[this._vertexIdx] = { x: x, y: y };\r\n                this.model.set('vertices', vertices, { ui: true });\r\n                break;\r\n\r\n            case 'label-move':\r\n\r\n                var dragPoint = { x: x, y: y };\r\n                var samples = this._samples;\r\n                var minSqDistance = Infinity;\r\n                var closestSample;\r\n                var closestSampleIndex;\r\n                var p;\r\n                var sqDistance;\r\n                for (var i = 0, len = samples.length; i < len; i++) {\r\n                    p = samples[i];\r\n                    sqDistance = g.line(p, dragPoint).squaredLength();\r\n                    if (sqDistance < minSqDistance) {\r\n                        minSqDistance = sqDistance;\r\n                        closestSample = p;\r\n                        closestSampleIndex = i;\r\n                    }\r\n                }\r\n                var prevSample = samples[closestSampleIndex - 1];\r\n                var nextSample = samples[closestSampleIndex + 1];\r\n                var offset = 0;\r\n                if (prevSample && nextSample) {\r\n                    offset = g.line(prevSample, nextSample).pointOffset(dragPoint);\r\n                } else if (prevSample) {\r\n                    offset = g.line(prevSample, closestSample).pointOffset(dragPoint);\r\n                } else if (nextSample) {\r\n                    offset = g.line(closestSample, nextSample).pointOffset(dragPoint);\r\n                }\r\n\r\n                this.model.label(this._labelIdx, {\r\n                    position: {\r\n                        distance: closestSample.distance / this._linkLength,\r\n                        offset: offset\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case 'arrowhead-move':\r\n\r\n                if (this.paper.options.snapLinks) {\r\n\r\n                    // checking view in close area of the pointer\r\n\r\n                    var r = this.paper.options.snapLinks.radius || 50;\r\n                    var viewsInArea = this.paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\r\n\r\n                    if (this._closestView) {\r\n                        this._closestView.unhighlight(this._closestEnd.selector, {\r\n                            connecting: true,\r\n                            snapping: true\r\n                        });\r\n                    }\r\n                    this._closestView = this._closestEnd = null;\r\n\r\n                    var distance;\r\n                    var minDistance = Number.MAX_VALUE;\r\n                    var pointer = g.point(x, y);\r\n\r\n                    _.each(viewsInArea, function(view) {\r\n\r\n                        // skip connecting to the element in case '.': { magnet: false } attribute present\r\n                        if (view.el.getAttribute('magnet') !== 'false') {\r\n\r\n                            // find distance from the center of the model to pointer coordinates\r\n                            distance = view.model.getBBox().center().distance(pointer);\r\n\r\n                            // the connection is looked up in a circle area by `distance < r`\r\n                            if (distance < r && distance < minDistance) {\r\n\r\n                                if (this.paper.options.validateConnection.apply(\r\n                                    this.paper, this._validateConnectionArgs(view, null)\r\n                                )) {\r\n                                    minDistance = distance;\r\n                                    this._closestView = view;\r\n                                    this._closestEnd = { id: view.model.id };\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        view.$('[magnet]').each(_.bind(function(index, magnet) {\r\n\r\n                            var bbox = V(magnet).bbox(false, this.paper.viewport);\r\n\r\n                            distance = pointer.distance({\r\n                                x: bbox.x + bbox.width / 2,\r\n                                y: bbox.y + bbox.height / 2\r\n                            });\r\n\r\n                            if (distance < r && distance < minDistance) {\r\n\r\n                                if (this.paper.options.validateConnection.apply(\r\n                                    this.paper, this._validateConnectionArgs(view, magnet)\r\n                                )) {\r\n                                    minDistance = distance;\r\n                                    this._closestView = view;\r\n                                    this._closestEnd = {\r\n                                        id: view.model.id,\r\n                                        selector: view.getSelector(magnet),\r\n                                        port: magnet.getAttribute('port')\r\n                                    };\r\n                                }\r\n                            }\r\n\r\n                        }, this));\r\n\r\n                    }, this);\r\n\r\n                    if (this._closestView) {\r\n                        this._closestView.highlight(this._closestEnd.selector, {\r\n                            connecting: true,\r\n                            snapping: true\r\n                        });\r\n                    }\r\n\r\n                    this.model.set(this._arrowhead, this._closestEnd || { x: x, y: y }, { ui: true });\r\n\r\n                } else {\r\n\r\n                    // checking views right under the pointer\r\n\r\n                    // Touchmove event's target is not reflecting the element under the coordinates as mousemove does.\r\n                    // It holds the element when a touchstart triggered.\r\n                    var target = (evt.type === 'mousemove')\r\n                        ? evt.target\r\n                        : document.elementFromPoint(evt.clientX, evt.clientY);\r\n\r\n                    if (this._targetEvent !== target) {\r\n                        // Unhighlight the previous view under pointer if there was one.\r\n                        if (this._magnetUnderPointer) {\r\n                            this._viewUnderPointer.unhighlight(this._magnetUnderPointer, {\r\n                                connecting: true\r\n                            });\r\n                        }\r\n\r\n                        this._viewUnderPointer = this.paper.findView(target);\r\n                        if (this._viewUnderPointer) {\r\n                            // If we found a view that is under the pointer, we need to find the closest\r\n                            // magnet based on the real target element of the event.\r\n                            this._magnetUnderPointer = this._viewUnderPointer.findMagnet(target);\r\n\r\n                            if (this._magnetUnderPointer && this.paper.options.validateConnection.apply(\r\n                                this.paper,\r\n                                this._validateConnectionArgs(this._viewUnderPointer, this._magnetUnderPointer)\r\n                            )) {\r\n                                // If there was no magnet found, do not highlight anything and assume there\r\n                                // is no view under pointer we're interested in reconnecting to.\r\n                                // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\r\n                                if (this._magnetUnderPointer) {\r\n                                    this._viewUnderPointer.highlight(this._magnetUnderPointer, {\r\n                                        connecting: true\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                // This type of connection is not valid. Disregard this magnet.\r\n                                this._magnetUnderPointer = null;\r\n                            }\r\n                        } else {\r\n                            // Make sure we'll unset previous magnet.\r\n                            this._magnetUnderPointer = null;\r\n                        }\r\n                    }\r\n\r\n                    this._targetEvent = target;\r\n\r\n                    this.model.set(this._arrowhead, { x: x, y: y }, { ui: true });\r\n                }\r\n                break;\r\n        }\r\n\r\n        this._dx = x;\r\n        this._dy = y;\r\n\r\n        joint.dia.CellView.prototype.pointermove.apply(this, arguments);\r\n        this.notify('link:pointermove', evt, x, y);\r\n    },\r\n\r\n    pointerup: function(evt, x, y) {\r\n\r\n        if (this._action === 'label-move') {\r\n\r\n            this._samples = null;\r\n\r\n        } else if (this._action === 'arrowhead-move') {\r\n\r\n            var paper = this.paper;\r\n            var paperOptions = paper.options;\r\n            var arrowhead = this._arrowhead;\r\n            var initialEnd = this._initialEnd;\r\n            var magnetUnderPointer;\r\n\r\n            if (paperOptions.snapLinks) {\r\n\r\n                // Finish off link snapping.\r\n                // Everything except view unhighlighting was already done on pointermove.\r\n                if (this._closestView) {\r\n                    this._closestView.unhighlight(this._closestEnd.selector, {\r\n                        connecting: true,\r\n                        snapping: true\r\n                    });\r\n\r\n                    magnetUnderPointer = this._closestView.findMagnet(this._closestEnd.selector);\r\n                }\r\n\r\n                this._closestView = this._closestEnd = null;\r\n\r\n            } else {\r\n\r\n                var viewUnderPointer = this._viewUnderPointer;\r\n                magnetUnderPointer = this._magnetUnderPointer;\r\n\r\n                this._viewUnderPointer = null;\r\n                this._magnetUnderPointer = null;\r\n\r\n                if (magnetUnderPointer) {\r\n\r\n                    viewUnderPointer.unhighlight(magnetUnderPointer, { connecting: true });\r\n                    // Find a unique `selector` of the element under pointer that is a magnet. If the\r\n                    // `this._magnetUnderPointer` is the root element of the `this._viewUnderPointer` itself,\r\n                    // the returned `selector` will be `undefined`. That means we can directly pass it to the\r\n                    // `source`/`target` attribute of the link model below.\r\n                    var selector = viewUnderPointer.getSelector(magnetUnderPointer);\r\n                    var port = magnetUnderPointer.getAttribute('port');\r\n                    var arrowheadValue = { id: viewUnderPointer.model.id };\r\n                    if (port != null) arrowheadValue.port = port;\r\n                    if (selector != null) arrowheadValue.selector = selector;\r\n                    this.model.set(arrowhead, arrowheadValue, { ui: true });\r\n                }\r\n            }\r\n\r\n            // If the changed link is not allowed, revert to its previous state.\r\n            if (!paper.linkAllowed(this)) {\r\n\r\n                switch (this._whenNotAllowed) {\r\n\r\n                    case 'remove':\r\n                        this.model.remove();\r\n                        break;\r\n\r\n                    case 'revert':\r\n                    default:\r\n                        this.model.set(arrowhead, initialEnd, { ui: true });\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Reparent the link if embedding is enabled\r\n            if (paperOptions.embeddingMode && this.model.reparent()) {\r\n                // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\r\n                this._z = null;\r\n            }\r\n\r\n            var currentEnd = this.model.prop(arrowhead) || {};\r\n            var endChanged = !joint.dia.Link.endsEqual(initialEnd, currentEnd);\r\n\r\n            if (endChanged) {\r\n\r\n                if (initialEnd.id) {\r\n                    this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), this._initialMagnet, arrowhead);\r\n                }\r\n                if (currentEnd.id) {\r\n                    this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), magnetUnderPointer, arrowhead);\r\n                }\r\n            }\r\n\r\n            this._afterArrowheadMove();\r\n        }\r\n\r\n        this._action = null;\r\n        this._whenNotAllowed = null;\r\n        this._initialMagnet = null;\r\n        this._initialEnd = null;\r\n        this._validateConnectionArgs = null;\r\n\r\n        this.notify('link:pointerup', evt, x, y);\r\n        joint.dia.CellView.prototype.pointerup.apply(this, arguments);\r\n    },\r\n\r\n    mouseenter: function(evt) {\r\n\r\n        joint.dia.CellView.prototype.mouseenter.apply(this, arguments);\r\n        this.notify('link:mouseenter', evt);\r\n    },\r\n\r\n    mouseleave: function(evt) {\r\n\r\n        joint.dia.CellView.prototype.mouseleave.apply(this, arguments);\r\n        this.notify('link:mouseleave', evt);\r\n    }\r\n\r\n}, {\r\n\r\n    makeSelector: function(end) {\r\n\r\n        var selector = '[model-id=\"' + end.id + '\"]';\r\n        // `port` has a higher precendence over `selector`. This is because the selector to the magnet\r\n        // might change while the name of the port can stay the same.\r\n        if (end.port) {\r\n            selector += ' [port=\"' + end.port + '\"]';\r\n        } else if (end.selector) {\r\n            selector += ' ' + end.selector;\r\n        }\r\n\r\n        return selector;\r\n    }\r\n\r\n});\r\n\r\n\r\njoint.dia.Paper = joint.mvc.View.extend({\r\n\r\n    className: 'paper',\r\n\r\n    options: {\r\n\r\n        width: 800,\r\n        height: 600,\r\n        origin: { x: 0, y: 0 }, // x,y coordinates in top-left corner\r\n        gridSize: 1,\r\n\r\n        // Whether or not to draw the grid lines on the paper's DOM element.\r\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\r\n        drawGrid: false,\r\n\r\n        // Whether or not to draw the background on the paper's DOM element.\r\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\r\n        background: false,\r\n\r\n        perpendicularLinks: false,\r\n        elementView: joint.dia.ElementView,\r\n        linkView: joint.dia.LinkView,\r\n        snapLinks: false, // false, true, { radius: value }\r\n\r\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\r\n        multiLinks: true,\r\n\r\n        // For adding custom guard logic.\r\n        guard: function(evt, view) {\r\n\r\n            // FALSE means the event isn't guarded.\r\n            return false;\r\n        },\r\n\r\n        highlighting: {\r\n            'default': {\r\n                name: 'stroke',\r\n                options: {\r\n                    padding: 3\r\n                }\r\n            },\r\n            magnetAvailability: {\r\n                name: 'addClass',\r\n                options: {\r\n                    className: 'available-magnet'\r\n                }\r\n            },\r\n            elementAvailability: {\r\n                name: 'addClass',\r\n                options: {\r\n                    className: 'available-cell'\r\n                }\r\n            }\r\n        },\r\n\r\n        // Prevent the default context menu from being displayed.\r\n        preventContextMenu: true,\r\n\r\n        // Restrict the translation of elements by given bounding box.\r\n        // Option accepts a boolean:\r\n        //  true - the translation is restricted to the paper area\r\n        //  false - no restrictions\r\n        // A method:\r\n        // restrictTranslate: function(elementView) {\r\n        //     var parentId = elementView.model.get('parent');\r\n        //     return parentId && this.model.getCell(parentId).getBBox();\r\n        // },\r\n        // Or a bounding box:\r\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\r\n        restrictTranslate: false,\r\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\r\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\r\n        // when the dragging is stopped.\r\n        markAvailable: false,\r\n\r\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\r\n        // Value could be the Backbone.model or a function returning the Backbone.model\r\n        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\r\n        defaultLink: new joint.dia.Link,\r\n\r\n        // A connector that is used by links with no connector defined on the model.\r\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\r\n        defaultConnector: { name: 'normal' },\r\n\r\n        // A router that is used by links with no router defined on the model.\r\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\r\n        defaultRouter: { name: 'normal' },\r\n\r\n        /* CONNECTING */\r\n\r\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\r\n        validateMagnet: function(cellView, magnet) {\r\n            return magnet.getAttribute('magnet') !== 'passive';\r\n        },\r\n\r\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\r\n        // being changed.\r\n        validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {\r\n            return (end === 'target' ? cellViewT : cellViewS) instanceof joint.dia.ElementView;\r\n        },\r\n\r\n        /* EMBEDDING */\r\n\r\n        // Enables embedding. Reparents the dragged element with elements under it and makes sure that\r\n        // all links and elements are visible taken the level of embedding into account.\r\n        embeddingMode: false,\r\n\r\n        // Check whether to allow or disallow the element embedding while an element being translated.\r\n        validateEmbedding: function(childView, parentView) {\r\n            // by default all elements can be in relation child-parent\r\n            return true;\r\n        },\r\n\r\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\r\n        // The cell with the highest z-index (visually on the top) will be choosen.\r\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\r\n\r\n        // If enabled only the element on the very front is taken into account for the embedding.\r\n        // If disabled the elements under the dragged view are tested one by one\r\n        // (from front to back) until a valid parent found.\r\n        frontParentOnly: true,\r\n\r\n        // Interactive flags. See online docs for the complete list of interactive flags.\r\n        interactive: {\r\n            labelMove: false\r\n        },\r\n\r\n        // When set to true the links can be pinned to the paper.\r\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\r\n        linkPinning: true,\r\n\r\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\r\n        clickThreshold: 0,\r\n\r\n        // The namespace, where all the cell views are defined.\r\n        cellViewNamespace: joint.shapes,\r\n\r\n        // The namespace, where all the cell views are defined.\r\n        highlighterNamespace: joint.highlighters\r\n    },\r\n\r\n    events: {\r\n\r\n        'mousedown': 'pointerdown',\r\n        'dblclick': 'mousedblclick',\r\n        'click': 'mouseclick',\r\n        'touchstart': 'pointerdown',\r\n        'touchend': 'mouseclick',\r\n        'touchmove': 'pointermove',\r\n        'mousemove': 'pointermove',\r\n        'mouseover .joint-cell': 'cellMouseover',\r\n        'mouseout .joint-cell': 'cellMouseout',\r\n        'contextmenu': 'contextmenu',\r\n        'mousewheel': 'mousewheel',\r\n        'DOMMouseScroll': 'mousewheel',\r\n        'mouseenter .joint-cell': 'cellMouseenter',\r\n        'mouseleave .joint-cell': 'cellMouseleave'\r\n    },\r\n\r\n    _highlights: {},\r\n\r\n    init: function() {\r\n\r\n        _.bindAll(this, 'pointerup');\r\n\r\n        var model = this.model = this.options.model || new joint.dia.Graph;\r\n\r\n        this.setGrid(this.options.drawGrid);\r\n        this.cloneOptions();\r\n        this.render();\r\n        this.setDimensions();\r\n\r\n        this.listenTo(model, 'add', this.onCellAdded)\r\n            .listenTo(model, 'remove', this.removeView)\r\n            .listenTo(model, 'reset', this.resetViews)\r\n            .listenTo(model, 'sort', this._onSort)\r\n            .listenTo(model, 'batch:stop', this._onBatchStop);\r\n\r\n        this.on('cell:highlight', this.onCellHighlight)\r\n            .on('cell:unhighlight', this.onCellUnhighlight)\r\n            .on('scale translate', this.update);\r\n\r\n        // Hold the value when mouse has been moved: when mouse moved, no click event will be triggered.\r\n        this._mousemoved = 0;\r\n        // Hash of all cell views.\r\n        this._views = {};\r\n        // Reference to the paper owner document\r\n        this.$document = $(this.el.ownerDocument);\r\n    },\r\n\r\n    cloneOptions: function() {\r\n\r\n        var options = this.options;\r\n\r\n        // This is a fix for the case where two papers share the same options.\r\n        // Changing origin.x for one paper would change the value of origin.x for the other.\r\n        // This prevents that behavior.\r\n        options.origin = _.clone(options.origin);\r\n        options.defaultConnector = _.clone(options.defaultConnector);\r\n        // Return the default highlighting options into the user specified options.\r\n        options.highlighting = _.defaultsDeep(\r\n            {},\r\n            options.highlighting,\r\n            this.constructor.prototype.options.highlighting\r\n        );\r\n    },\r\n\r\n    bindDocumentEvents: function() {\r\n        var eventNS = this.getEventNamespace();\r\n        this.$document.on('mouseup' + eventNS + ' touchend' + eventNS, this.pointerup);\r\n    },\r\n\r\n    unbindDocumentEvents: function() {\r\n        this.$document.off(this.getEventNamespace());\r\n    },\r\n\r\n    render: function() {\r\n\r\n        this.$el.empty();\r\n\r\n        this.svg = V('svg').attr({ width: '100%', height: '100%' }).node;\r\n        this.viewport = V('g').addClass(joint.util.addClassNamePrefix('viewport')).node;\r\n        this.defs = V('defs').node;\r\n\r\n        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\r\n        V(this.svg).append([this.viewport, this.defs]);\r\n\r\n        this.$background = $('<div/>').addClass(joint.util.addClassNamePrefix('paper-background'));\r\n        if (this.options.background) {\r\n            this.drawBackground(this.options.background);\r\n        }\r\n\r\n        this.$grid = $('<div/>').addClass(joint.util.addClassNamePrefix('paper-grid'));\r\n        if (this.options.drawGrid) {\r\n            this.drawGrid();\r\n        }\r\n\r\n        this.$el.append(this.$background, this.$grid, this.svg);\r\n\r\n        return this;\r\n    },\r\n\r\n    update: function() {\r\n\r\n        if (this.options.drawGrid) {\r\n            this.drawGrid();\r\n        }\r\n\r\n        if (this._background) {\r\n            this.updateBackgroundImage(this._background);\r\n        }\r\n    },\r\n\r\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\r\n    _viewportMatrix: null,\r\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\r\n    // could have been manipulated directly.\r\n    _viewportTransformString: null,\r\n\r\n    matrix: function(ctm) {\r\n\r\n        var viewport = this.viewport;\r\n\r\n        // Getter:\r\n        if (ctm === undefined) {\r\n\r\n            var transformString = viewport.getAttribute('transform');\r\n\r\n            if ((this._viewportTransformString || null) === transformString) {\r\n                // It's ok to return the cached matrix. The transform attribute has not changed since\r\n                // the matrix was stored.\r\n                ctm = this._viewportMatrix;\r\n            } else {\r\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\r\n                ctm = viewport.getCTM();\r\n                this._viewportMatrix = ctm;\r\n                this._viewportTransformString = transformString;\r\n            }\r\n\r\n            // Clone the cached current transformation matrix.\r\n            // If no matrix previously stored the identity matrix is returned.\r\n            return V.createSVGMatrix(ctm);\r\n        }\r\n\r\n        // Setter:\r\n        ctm = V.createSVGMatrix(ctm);\r\n        V(viewport).transform(ctm, { absolute: true });\r\n        this._viewportMatrix = ctm;\r\n        this._viewportTransformString = viewport.getAttribute('transform');\r\n\r\n        return this;\r\n    },\r\n\r\n    clientMatrix: function() {\r\n\r\n        return V.createSVGMatrix(this.viewport.getScreenCTM());\r\n    },\r\n\r\n    _onSort: function() {\r\n        if (!this.model.hasActiveBatch('add')) {\r\n            this.sortViews();\r\n        }\r\n    },\r\n\r\n    _onBatchStop: function(data) {\r\n        var name = data && data.batchName;\r\n        if (name === 'add' && !this.model.hasActiveBatch('add')) {\r\n            this.sortViews();\r\n        }\r\n    },\r\n\r\n    onRemove: function() {\r\n\r\n        //clean up all DOM elements/views to prevent memory leaks\r\n        this.removeViews();\r\n        this.unbindDocumentEvents();\r\n    },\r\n\r\n    setDimensions: function(width, height) {\r\n\r\n        width = this.options.width = width || this.options.width;\r\n        height = this.options.height = height || this.options.height;\r\n\r\n        this.$el.css({\r\n            width: Math.round(width),\r\n            height: Math.round(height)\r\n        });\r\n\r\n        this.trigger('resize', width, height);\r\n    },\r\n\r\n    setOrigin: function(ox, oy) {\r\n\r\n        return this.translate(ox || 0, oy || 0, { absolute: true });\r\n    },\r\n\r\n    // Expand/shrink the paper to fit the content. Snap the width/height to the grid\r\n    // defined in `gridWidth`, `gridHeight`. `padding` adds to the resulting width/height of the paper.\r\n    // When options { fitNegative: true } it also translates the viewport in order to make all\r\n    // the content visible.\r\n    fitToContent: function(gridWidth, gridHeight, padding, opt) { // alternatively function(opt)\r\n\r\n        if (_.isObject(gridWidth)) {\r\n            // first parameter is an option object\r\n            opt = gridWidth;\r\n            gridWidth = opt.gridWidth || 1;\r\n            gridHeight = opt.gridHeight || 1;\r\n            padding = opt.padding || 0;\r\n\r\n        } else {\r\n\r\n            opt = opt || {};\r\n            gridWidth = gridWidth || 1;\r\n            gridHeight = gridHeight || 1;\r\n            padding = padding || 0;\r\n        }\r\n\r\n        padding = joint.util.normalizeSides(padding);\r\n\r\n        // Calculate the paper size to accomodate all the graph's elements.\r\n        var bbox = V(this.viewport).bbox(true, this.svg);\r\n\r\n        var currentScale = this.scale();\r\n        var currentTranslate = this.translate();\r\n\r\n        bbox.x *= currentScale.sx;\r\n        bbox.y *= currentScale.sy;\r\n        bbox.width *= currentScale.sx;\r\n        bbox.height *= currentScale.sy;\r\n\r\n        var calcWidth = Math.max(Math.ceil((bbox.width + bbox.x) / gridWidth), 1) * gridWidth;\r\n        var calcHeight = Math.max(Math.ceil((bbox.height + bbox.y) / gridHeight), 1) * gridHeight;\r\n\r\n        var tx = 0;\r\n        var ty = 0;\r\n\r\n        if ((opt.allowNewOrigin == 'negative' && bbox.x < 0) || (opt.allowNewOrigin == 'positive' && bbox.x >= 0) || opt.allowNewOrigin == 'any') {\r\n            tx = Math.ceil(-bbox.x / gridWidth) * gridWidth;\r\n            tx += padding.left;\r\n            calcWidth += tx;\r\n        }\r\n\r\n        if ((opt.allowNewOrigin == 'negative' && bbox.y < 0) || (opt.allowNewOrigin == 'positive' && bbox.y >= 0) || opt.allowNewOrigin == 'any') {\r\n            ty = Math.ceil(-bbox.y / gridHeight) * gridHeight;\r\n            ty += padding.top;\r\n            calcHeight += ty;\r\n        }\r\n\r\n        calcWidth += padding.right;\r\n        calcHeight += padding.bottom;\r\n\r\n        // Make sure the resulting width and height are greater than minimum.\r\n        calcWidth = Math.max(calcWidth, opt.minWidth || 0);\r\n        calcHeight = Math.max(calcHeight, opt.minHeight || 0);\r\n\r\n        // Make sure the resulting width and height are lesser than maximum.\r\n        calcWidth = Math.min(calcWidth, opt.maxWidth || Number.MAX_VALUE);\r\n        calcHeight = Math.min(calcHeight, opt.maxHeight || Number.MAX_VALUE);\r\n\r\n        var dimensionChange = calcWidth != this.options.width || calcHeight != this.options.height;\r\n        var originChange = tx != currentTranslate.tx || ty != currentTranslate.ty;\r\n\r\n        // Change the dimensions only if there is a size discrepency or an origin change\r\n        if (originChange) {\r\n            this.translate(tx, ty);\r\n        }\r\n        if (dimensionChange) {\r\n            this.setDimensions(calcWidth, calcHeight);\r\n        }\r\n    },\r\n\r\n    scaleContentToFit: function(opt) {\r\n\r\n        var contentBBox = this.getContentBBox();\r\n\r\n        if (!contentBBox.width || !contentBBox.height) return;\r\n\r\n        opt = opt || {};\r\n\r\n        _.defaults(opt, {\r\n            padding: 0,\r\n            preserveAspectRatio: true,\r\n            scaleGrid: null,\r\n            minScale: 0,\r\n            maxScale: Number.MAX_VALUE\r\n            //minScaleX\r\n            //minScaleY\r\n            //maxScaleX\r\n            //maxScaleY\r\n            //fittingBBox\r\n        });\r\n\r\n        var padding = opt.padding;\r\n\r\n        var minScaleX = opt.minScaleX || opt.minScale;\r\n        var maxScaleX = opt.maxScaleX || opt.maxScale;\r\n        var minScaleY = opt.minScaleY || opt.minScale;\r\n        var maxScaleY = opt.maxScaleY || opt.maxScale;\r\n\r\n        var fittingBBox;\r\n        if (opt.fittingBBox) {\r\n            fittingBBox = opt.fittingBBox;\r\n        } else {\r\n            var currentTranslate = this.translate();\r\n            fittingBBox = {\r\n                x: currentTranslate.tx,\r\n                y: currentTranslate.ty,\r\n                width: this.options.width,\r\n                height: this.options.height\r\n            };\r\n        }\r\n\r\n        fittingBBox = g.rect(fittingBBox).moveAndExpand({\r\n            x: padding,\r\n            y: padding,\r\n            width: -2 * padding,\r\n            height: -2 * padding\r\n        });\r\n\r\n        var currentScale = this.scale();\r\n\r\n        var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\r\n        var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\r\n\r\n        if (opt.preserveAspectRatio) {\r\n            newSx = newSy = Math.min(newSx, newSy);\r\n        }\r\n\r\n        // snap scale to a grid\r\n        if (opt.scaleGrid) {\r\n\r\n            var gridSize = opt.scaleGrid;\r\n\r\n            newSx = gridSize * Math.floor(newSx / gridSize);\r\n            newSy = gridSize * Math.floor(newSy / gridSize);\r\n        }\r\n\r\n        // scale min/max boundaries\r\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\r\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\r\n\r\n        this.scale(newSx, newSy);\r\n\r\n        var contentTranslation = this.getContentBBox();\r\n\r\n        var newOx = fittingBBox.x - contentTranslation.x;\r\n        var newOy = fittingBBox.y - contentTranslation.y;\r\n\r\n        this.translate(newOx, newOy);\r\n    },\r\n\r\n    getContentBBox: function() {\r\n\r\n        var crect = this.viewport.getBoundingClientRect();\r\n\r\n        // Using Screen CTM was the only way to get the real viewport bounding box working in both\r\n        // Google Chrome and Firefox.\r\n        var clientCTM = this.clientMatrix();\r\n\r\n        // for non-default origin we need to take the viewport translation into account\r\n        var currentTranslate = this.translate();\r\n\r\n        return g.rect({\r\n            x: crect.left - clientCTM.e + currentTranslate.tx,\r\n            y: crect.top - clientCTM.f + currentTranslate.ty,\r\n            width: crect.width,\r\n            height: crect.height\r\n        });\r\n    },\r\n\r\n    // Returns a geometry rectangle represeting the entire\r\n    // paper area (coordinates from the left paper border to the right one\r\n    // and the top border to the bottom one).\r\n    getArea: function() {\r\n\r\n        return this.paperToLocalRect({\r\n            x: 0,\r\n            y: 0,\r\n            width: this.options.width,\r\n            height: this.options.height\r\n        });\r\n    },\r\n\r\n    getRestrictedArea: function() {\r\n\r\n        var restrictedArea;\r\n\r\n        if (_.isFunction(this.options.restrictTranslate)) {\r\n            // A method returning a bounding box\r\n            restrictedArea = this.options.restrictTranslate.apply(this, arguments);\r\n        } else if (this.options.restrictTranslate === true) {\r\n            // The paper area\r\n            restrictedArea = this.getArea();\r\n        } else {\r\n            // Either false or a bounding box\r\n            restrictedArea = this.options.restrictTranslate || null;\r\n        }\r\n\r\n        return restrictedArea;\r\n    },\r\n\r\n    createViewForModel: function(cell) {\r\n\r\n        // A class taken from the paper options.\r\n        var optionalViewClass;\r\n\r\n        // A default basic class (either dia.ElementView or dia.LinkView)\r\n        var defaultViewClass;\r\n\r\n        // A special class defined for this model in the corresponding namespace.\r\n        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\r\n        var namespace = this.options.cellViewNamespace;\r\n        var type = cell.get('type') + 'View';\r\n        var namespaceViewClass = joint.util.getByPath(namespace, type, '.');\r\n\r\n        if (cell.isLink()) {\r\n            optionalViewClass = this.options.linkView;\r\n            defaultViewClass = joint.dia.LinkView;\r\n        } else {\r\n            optionalViewClass = this.options.elementView;\r\n            defaultViewClass = joint.dia.ElementView;\r\n        }\r\n\r\n        // a) the paper options view is a class (deprecated)\r\n        //  1. search the namespace for a view\r\n        //  2. if no view was found, use view from the paper options\r\n        // b) the paper options view is a function\r\n        //  1. call the function from the paper options\r\n        //  2. if no view was return, search the namespace for a view\r\n        //  3. if no view was found, use the default\r\n        var ViewClass = (optionalViewClass.prototype instanceof Backbone.View)\r\n            ? namespaceViewClass || optionalViewClass\r\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\r\n\r\n        return new ViewClass({\r\n            model: cell,\r\n            interactive: this.options.interactive\r\n        });\r\n    },\r\n\r\n    onCellAdded: function(cell, graph, opt) {\r\n\r\n        if (this.options.async && opt.async !== false && _.isNumber(opt.position)) {\r\n\r\n            this._asyncCells = this._asyncCells || [];\r\n            this._asyncCells.push(cell);\r\n\r\n            if (opt.position == 0) {\r\n\r\n                if (this._frameId) throw new Error('another asynchronous rendering in progress');\r\n\r\n                this.asyncRenderViews(this._asyncCells, opt);\r\n                delete this._asyncCells;\r\n            }\r\n\r\n        } else {\r\n\r\n            this.renderView(cell);\r\n        }\r\n    },\r\n\r\n    removeView: function(cell) {\r\n\r\n        var view = this._views[cell.id];\r\n\r\n        if (view) {\r\n            view.remove();\r\n            delete this._views[cell.id];\r\n        }\r\n\r\n        return view;\r\n    },\r\n\r\n    renderView: function(cell) {\r\n\r\n        var view = this._views[cell.id] = this.createViewForModel(cell);\r\n\r\n        V(this.viewport).append(view.el);\r\n        view.paper = this;\r\n        view.render();\r\n\r\n        // This is the only way to prevent image dragging in Firefox that works.\r\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\r\n        $(view.el).find('image').on('dragstart', function() { return false; });\r\n\r\n        return view;\r\n    },\r\n\r\n    beforeRenderViews: function(cells) {\r\n\r\n        // Make sure links are always added AFTER elements.\r\n        // They wouldn't find their sources/targets in the DOM otherwise.\r\n        cells.sort(function(a) { return a instanceof joint.dia.Link ? 1 : -1; });\r\n\r\n        return cells;\r\n    },\r\n\r\n    afterRenderViews: function() {\r\n\r\n        this.sortViews();\r\n    },\r\n\r\n    resetViews: function(cellsCollection, opt) {\r\n\r\n        // clearing views removes any event listeners\r\n        this.removeViews();\r\n\r\n        var cells = cellsCollection.models.slice();\r\n\r\n        // `beforeRenderViews()` can return changed cells array (e.g sorted).\r\n        cells = this.beforeRenderViews(cells, opt) || cells;\r\n\r\n        if (this._frameId) {\r\n\r\n            joint.util.cancelFrame(this._frameId);\r\n            delete this._frameId;\r\n        }\r\n\r\n        if (this.options.async) {\r\n\r\n            this.asyncRenderViews(cells, opt);\r\n            // Sort the cells once all elements rendered (see asyncRenderViews()).\r\n\r\n        } else {\r\n\r\n            _.each(cells, this.renderView, this);\r\n\r\n            // Sort the cells in the DOM manually as we might have changed the order they\r\n            // were added to the DOM (see above).\r\n            this.sortViews();\r\n        }\r\n    },\r\n\r\n    removeViews: function() {\r\n\r\n        _.invoke(this._views, 'remove');\r\n\r\n        this._views = {};\r\n    },\r\n\r\n    asyncBatchAdded: _.noop,\r\n\r\n    asyncRenderViews: function(cells, opt) {\r\n\r\n        if (this._frameId) {\r\n\r\n            var batchSize = (this.options.async && this.options.async.batchSize) || 50;\r\n            var batchCells = cells.splice(0, batchSize);\r\n\r\n            _.each(batchCells, function(cell) {\r\n\r\n                // The cell has to be part of the graph.\r\n                // There is a chance in asynchronous rendering\r\n                // that a cell was removed before it's rendered to the paper.\r\n                if (cell.graph === this.model) this.renderView(cell);\r\n\r\n            }, this);\r\n\r\n            this.asyncBatchAdded();\r\n        }\r\n\r\n        if (!cells.length) {\r\n\r\n            // No cells left to render.\r\n            delete this._frameId;\r\n            this.afterRenderViews(opt);\r\n            this.trigger('render:done', opt);\r\n\r\n        } else {\r\n\r\n            // Schedule a next batch to render.\r\n            this._frameId = joint.util.nextFrame(function() {\r\n                this.asyncRenderViews(cells, opt);\r\n            }, this);\r\n        }\r\n    },\r\n\r\n    sortViews: function() {\r\n\r\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\r\n        // associated model `z` attribute.\r\n\r\n        var $cells = $(this.viewport).children('[model-id]');\r\n        var cells = this.model.get('cells');\r\n\r\n        joint.util.sortElements($cells, function(a, b) {\r\n\r\n            var cellA = cells.get($(a).attr('model-id'));\r\n            var cellB = cells.get($(b).attr('model-id'));\r\n\r\n            return (cellA.get('z') || 0) > (cellB.get('z') || 0) ? 1 : -1;\r\n        });\r\n    },\r\n\r\n    scale: function(sx, sy, ox, oy) {\r\n\r\n        // getter\r\n        if (sx === undefined) {\r\n            return V.matrixToScale(this.matrix());\r\n        }\r\n\r\n        // setter\r\n        if (sy === undefined) {\r\n            sy = sx;\r\n        }\r\n        if (ox === undefined) {\r\n            ox = 0;\r\n            oy = 0;\r\n        }\r\n\r\n        var translate = this.translate();\r\n\r\n        if (ox || oy || translate.tx || translate.ty) {\r\n            var newTx = translate.tx - ox * (sx - 1);\r\n            var newTy = translate.ty - oy * (sy - 1);\r\n            this.translate(newTx, newTy);\r\n        }\r\n\r\n        var ctm = this.matrix();\r\n        ctm.a = sx || 0;\r\n        ctm.d = sy || 0;\r\n\r\n        this.matrix(ctm);\r\n\r\n        this.trigger('scale', sx, sy, ox, oy);\r\n\r\n        return this;\r\n    },\r\n\r\n    // Experimental - do not use in production.\r\n    rotate: function(angle, cx, cy) {\r\n\r\n        // getter\r\n        if (angle === undefined) {\r\n            return V.matrixToRotate(this.matrix());\r\n        }\r\n\r\n        // setter\r\n\r\n        // If the origin is not set explicitely, rotate around the center. Note that\r\n        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\r\n        // the real bounding box (`bbox()`) including transformations).\r\n        if (cx === undefined) {\r\n            var bbox = this.viewport.getBBox();\r\n            cx = bbox.width / 2;\r\n            cy = bbox.height / 2;\r\n        }\r\n\r\n        var ctm = this.matrix().translate(cx,cy).rotate(angle).translate(-cx,-cy);\r\n        this.matrix(ctm);\r\n\r\n        return this;\r\n    },\r\n\r\n    translate: function(tx, ty) {\r\n\r\n        // getter\r\n        if (tx === undefined) {\r\n            return V.matrixToTranslate(this.matrix());\r\n        }\r\n\r\n        // setter\r\n\r\n        var ctm = this.matrix();\r\n        ctm.e = tx || 0;\r\n        ctm.f = ty || 0;\r\n\r\n        this.matrix(ctm);\r\n\r\n        var newTranslate = this.translate();\r\n        var origin = this.options.origin;\r\n        origin.x = newTranslate.tx;\r\n        origin.y = newTranslate.ty;\r\n\r\n        this.trigger('translate', newTranslate.tx, newTranslate.ty);\r\n\r\n        if (this.options.drawGrid) {\r\n            this.drawGrid();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\r\n    // be a selector or a jQuery object.\r\n    findView: function($el) {\r\n\r\n        var el = _.isString($el)\r\n            ? this.viewport.querySelector($el)\r\n            : $el instanceof $ ? $el[0] : $el;\r\n\r\n        while (el && el !== this.el && el !== document) {\r\n\r\n            var id = el.getAttribute('model-id');\r\n            if (id) return this._views[id];\r\n\r\n            el = el.parentNode;\r\n        }\r\n\r\n        return undefined;\r\n    },\r\n\r\n    // Find a view for a model `cell`. `cell` can also be a string representing a model `id`.\r\n    findViewByModel: function(cell) {\r\n\r\n        var id = _.isString(cell) ? cell : cell.id;\r\n\r\n        return this._views[id];\r\n    },\r\n\r\n    // Find all views at given point\r\n    findViewsFromPoint: function(p) {\r\n\r\n        p = g.point(p);\r\n\r\n        var views = _.map(this.model.getElements(), this.findViewByModel, this);\r\n\r\n        return _.filter(views, function(view) {\r\n            return view && g.rect(view.vel.bbox(false, this.viewport)).containsPoint(p);\r\n        }, this);\r\n    },\r\n\r\n    // Find all views in given area\r\n    findViewsInArea: function(rect, opt) {\r\n\r\n        opt = _.defaults(opt || {}, { strict: false });\r\n        rect = g.rect(rect);\r\n\r\n        var views = _.map(this.model.getElements(), this.findViewByModel, this);\r\n        var method = opt.strict ? 'containsRect' : 'intersect';\r\n\r\n        return _.filter(views, function(view) {\r\n            return view && rect[method](g.rect(view.vel.bbox(false, this.viewport)));\r\n        }, this);\r\n    },\r\n\r\n    getModelById: function(id) {\r\n\r\n        return this.model.getCell(id);\r\n    },\r\n\r\n    snapToGrid: function(x, y) {\r\n\r\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\r\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\r\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\r\n    },\r\n\r\n    localToPaperPoint: function(x, y) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var localPoint = g.Point(x, y);\r\n        var paperPoint = V.transformPoint(localPoint, this.matrix());\r\n        return g.Point(paperPoint);\r\n    },\r\n\r\n    localToPaperRect: function(x, y, width, height) {\r\n        // allow `x` to be a rectangle and rest arguments undefined\r\n        var localRect = g.Rect(x, y);\r\n        var paperRect = V.transformRect(localRect, this.matrix());\r\n        return g.Rect(paperRect);\r\n    },\r\n\r\n    paperToLocalPoint: function(x, y) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var paperPoint = g.Point(x, y);\r\n        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\r\n        return g.Point(localPoint);\r\n    },\r\n\r\n    paperToLocalRect: function(x, y, width, height) {\r\n        // allow `x` to be a rectangle and rest arguments undefined\r\n        var paperRect = g.Rect(x, y, width, height);\r\n        var localRect = V.transformRect(paperRect, this.matrix().inverse());\r\n        return g.Rect(localRect);\r\n    },\r\n\r\n    localToClientPoint: function(x, y) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var localPoint = g.Point(x, y);\r\n        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\r\n        return g.Point(clientPoint);\r\n    },\r\n\r\n    localToClientRect: function(x, y, width, height) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var localRect = g.Rect(x, y, width, height);\r\n        var clientRect = V.transformRect(localRect, this.clientMatrix());\r\n        return g.Rect(clientRect);\r\n    },\r\n\r\n    // Transform client coordinates to the paper local coordinates.\r\n    // Useful when you have a mouse event object and you'd like to get coordinates\r\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\r\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\r\n    clientToLocalPoint: function(x, y) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var clientPoint = g.Point(x, y);\r\n        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\r\n        return g.Point(localPoint);\r\n    },\r\n\r\n    clientToLocalRect: function(x, y, width, height) {\r\n        // allow `x` to be a point and `y` undefined\r\n        var clientRect = g.Rect(x, y, width, height);\r\n        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\r\n        return g.Rect(localRect);\r\n    },\r\n\r\n    localToPagePoint: function(x, y) {\r\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\r\n    },\r\n\r\n    localToPageRect: function(x, y, width, height) {\r\n        return this.localToPaperRect(x, y, width, height).moveAndExpand(this.pageOffset());\r\n    },\r\n\r\n    pageToLocalPoint: function(x, y) {\r\n        var pagePoint = g.Point(x, y);\r\n        var paperPoint = pagePoint.difference(this.pageOffset());\r\n        return this.paperToLocalPoint(paperPoint);\r\n    },\r\n\r\n    pageToLocalRect: function(x, y, width, height) {\r\n        var pageOffset = this.pageOffset();\r\n        var paperRect = g.Rect(x, y, width, height);\r\n        paperRect.x -= pageOffset.x;\r\n        paperRect.y -= pageOffset.y;\r\n        return this.paperToLocalRect(paperRect);\r\n    },\r\n\r\n    clientOffset: function() {\r\n        var clientRect = this.svg.getBoundingClientRect();\r\n        return g.Point(clientRect.left, clientRect.top);\r\n    },\r\n\r\n    pageOffset: function() {\r\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\r\n    },\r\n\r\n    linkAllowed: function(linkViewOrModel) {\r\n\r\n        var link;\r\n\r\n        if (linkViewOrModel instanceof joint.dia.Link) {\r\n            link = linkViewOrModel;\r\n        } else if (linkViewOrModel instanceof joint.dia.LinkView) {\r\n            link = linkViewOrModel.model;\r\n        } else {\r\n            throw new Error('Must provide link model or view.');\r\n        }\r\n\r\n        if (!this.options.multiLinks) {\r\n\r\n            // Do not allow multiple links to have the same source and target.\r\n\r\n            var source = link.get('source');\r\n            var target = link.get('target');\r\n\r\n            if (source.id && target.id) {\r\n\r\n                var sourceModel = link.getSourceElement();\r\n\r\n                if (sourceModel) {\r\n\r\n                    var connectedLinks = this.model.getConnectedLinks(sourceModel, {\r\n                        outbound: true,\r\n                        inbound: false\r\n                    });\r\n\r\n                    var numSameLinks = _.filter(connectedLinks, function(_link) {\r\n\r\n                        var _source = _link.get('source');\r\n                        var _target = _link.get('target');\r\n\r\n                        return _source && _source.id === source.id &&\r\n                                (!_source.port || (_source.port === source.port)) &&\r\n                                _target && _target.id === target.id &&\r\n                                (!_target.port || (_target.port === target.port));\r\n\r\n                    }).length;\r\n\r\n                    if (numSameLinks > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (\r\n            !this.options.linkPinning &&\r\n            (\r\n                !_.has(link.get('source'), 'id') ||\r\n                !_.has(link.get('target'), 'id')\r\n            )\r\n        ) {\r\n            // Link pinning is not allowed and the link is not connected to the target.\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    getDefaultLink: function(cellView, magnet) {\r\n\r\n        return _.isFunction(this.options.defaultLink)\r\n        // default link is a function producing link model\r\n            ? this.options.defaultLink.call(this, cellView, magnet)\r\n        // default link is the Backbone model\r\n            : this.options.defaultLink.clone();\r\n    },\r\n\r\n    // Cell highlighting\r\n    // -----------------\r\n    resolveHighlighter: function(opt) {\r\n\r\n        opt = opt || {};\r\n        var highlighterDef = opt.highlighter;\r\n        var paperOpt = this.options;\r\n\r\n        /*\r\n            Expecting opt.highlighter to have the following structure:\r\n            {\r\n                name: 'highlighter-name',\r\n                options: {\r\n                    some: 'value'\r\n                }\r\n            }\r\n        */\r\n        if (_.isUndefined(highlighterDef)) {\r\n\r\n            // check for built-in types\r\n            var type = _.chain(opt)\r\n                .pick('embedding', 'connecting', 'magnetAvailability', 'elementAvailability')\r\n                .keys().first().value();\r\n\r\n            highlighterDef = (type && paperOpt.highlighting[type]) || paperOpt.highlighting['default'];\r\n        }\r\n\r\n        // Do nothing if opt.highlighter is falsey.\r\n        // This allows the case to not highlight cell(s) in certain cases.\r\n        // For example, if you want to NOT highlight when embedding elements.\r\n        if (!highlighterDef) return false;\r\n\r\n        // Allow specifying a highlighter by name.\r\n        if (_.isString(highlighterDef)) {\r\n            highlighterDef = {\r\n                name: highlighterDef\r\n            };\r\n        }\r\n\r\n        var name = highlighterDef.name;\r\n        var highlighter = paperOpt.highlighterNamespace[name];\r\n\r\n        // Highlighter validation\r\n        if (!highlighter) {\r\n            throw new Error('Unknown highlighter (\"' + name + '\")');\r\n        }\r\n        if (typeof highlighter.highlight !== 'function') {\r\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\r\n        }\r\n        if (typeof highlighter.unhighlight !== 'function') {\r\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\r\n        }\r\n\r\n        return {\r\n            highlighter: highlighter,\r\n            options: highlighterDef.options || {},\r\n            name: name\r\n        };\r\n    },\r\n\r\n    onCellHighlight: function(cellView, magnetEl, opt) {\r\n\r\n        opt = this.resolveHighlighter(opt);\r\n        if (!opt) return;\r\n        if (!magnetEl.id) {\r\n            magnetEl.id = V.uniqueId();\r\n        }\r\n\r\n        var key = opt.name + magnetEl.id + JSON.stringify(opt.options);\r\n        if (!this._highlights[key]) {\r\n\r\n            var highlighter = opt.highlighter;\r\n            highlighter.highlight(cellView, magnetEl, _.clone(opt.options));\r\n\r\n            this._highlights[key] = {\r\n                cellView: cellView,\r\n                magnetEl: magnetEl,\r\n                opt: opt.options,\r\n                highlighter: highlighter\r\n            };\r\n        }\r\n    },\r\n\r\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\r\n\r\n        opt = this.resolveHighlighter(opt);\r\n        if (!opt) return;\r\n\r\n        var key = opt.name + magnetEl.id + JSON.stringify(opt.options);\r\n        var highlight = this._highlights[key];\r\n        if (highlight) {\r\n\r\n            // Use the cellView and magnetEl that were used by the highlighter.highlight() method.\r\n            highlight.highlighter.unhighlight(highlight.cellView, highlight.magnetEl, highlight.opt);\r\n\r\n            this._highlights[key] = null;\r\n        }\r\n    },\r\n\r\n    // Interaction.\r\n    // ------------\r\n\r\n    mousedblclick: function(evt) {\r\n\r\n        evt.preventDefault();\r\n        evt = joint.util.normalizeEvent(evt);\r\n\r\n        var view = this.findView(evt.target);\r\n        if (this.guard(evt, view)) return;\r\n\r\n        var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n        if (view) {\r\n\r\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\r\n\r\n        } else {\r\n\r\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\r\n        }\r\n    },\r\n\r\n    mouseclick: function(evt) {\r\n\r\n        // Trigger event when mouse not moved.\r\n        if (this._mousemoved <= this.options.clickThreshold) {\r\n\r\n            evt = joint.util.normalizeEvent(evt);\r\n\r\n            var view = this.findView(evt.target);\r\n            if (this.guard(evt, view)) return;\r\n\r\n            var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n            if (view) {\r\n\r\n                view.pointerclick(evt, localPoint.x, localPoint.y);\r\n\r\n            } else {\r\n\r\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\r\n            }\r\n        }\r\n    },\r\n\r\n    // Guard guards the event received. If the event is not interesting, guard returns `true`.\r\n    // Otherwise, it return `false`.\r\n    guard: function(evt, view) {\r\n\r\n        if (this.options.guard && this.options.guard(evt, view)) {\r\n            return true;\r\n        }\r\n\r\n        if (evt.data && !_.isUndefined(evt.data.guarded)) {\r\n            return evt.data.guarded;\r\n        }\r\n\r\n        if (view && view.model && (view.model instanceof joint.dia.Cell)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.svg === evt.target || this.el === evt.target || $.contains(this.svg, evt.target)) {\r\n            return false;\r\n        }\r\n\r\n        return true;    // Event guarded. Paper should not react on it in any way.\r\n    },\r\n\r\n    contextmenu: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n\r\n        if (this.options.preventContextMenu) {\r\n            evt.preventDefault();\r\n        }\r\n\r\n        var view = this.findView(evt.target);\r\n        if (this.guard(evt, view)) return;\r\n\r\n        var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n        if (view) {\r\n\r\n            view.contextmenu(evt, localPoint.x, localPoint.y);\r\n\r\n        } else {\r\n\r\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\r\n        }\r\n    },\r\n\r\n    pointerdown: function(evt) {\r\n\r\n        this.bindDocumentEvents();\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n\r\n        var view = this.findView(evt.target);\r\n        if (this.guard(evt, view)) return;\r\n\r\n        evt.preventDefault();\r\n\r\n        this._mousemoved = 0;\r\n\r\n        var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n        if (view) {\r\n\r\n            this.sourceView = view;\r\n\r\n            view.pointerdown(evt, localPoint.x, localPoint.y);\r\n\r\n        } else {\r\n\r\n            this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\r\n        }\r\n    },\r\n\r\n    pointermove: function(evt) {\r\n\r\n        if (this.sourceView) {\r\n\r\n            evt.preventDefault();\r\n            evt = joint.util.normalizeEvent(evt);\r\n\r\n            // Mouse moved counter.\r\n            this._mousemoved++;\r\n\r\n            var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n            this.sourceView.pointermove(evt, localPoint.x, localPoint.y);\r\n        }\r\n    },\r\n\r\n    pointerup: function(evt) {\r\n\r\n        this.unbindDocumentEvents();\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n\r\n        var localPoint = this.snapToGrid({ x: evt.clientX, y: evt.clientY });\r\n\r\n        if (this.sourceView) {\r\n\r\n            this.sourceView.pointerup(evt, localPoint.x, localPoint.y);\r\n\r\n            //\"delete sourceView\" occasionally throws an error in chrome (illegal access exception)\r\n            this.sourceView = null;\r\n\r\n        } else {\r\n\r\n            this.trigger('blank:pointerup', evt, localPoint.x, localPoint.y);\r\n        }\r\n    },\r\n\r\n    mousewheel: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n        var view = this.findView(evt.target);\r\n        if (this.guard(evt, view)) return;\r\n\r\n        var originalEvent = evt.originalEvent;\r\n        var localPoint = this.snapToGrid({ x: originalEvent.clientX, y: originalEvent.clientY });\r\n        var delta = Math.max(-1, Math.min(1, (originalEvent.wheelDelta || -originalEvent.detail)));\r\n\r\n        if (view) {\r\n\r\n            view.mousewheel(evt, localPoint.x, localPoint.y, delta);\r\n\r\n        } else {\r\n\r\n            this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\r\n        }\r\n    },\r\n\r\n    cellMouseover: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n        var view = this.findView(evt.target);\r\n        if (view) {\r\n            if (this.guard(evt, view)) return;\r\n            view.mouseover(evt);\r\n        }\r\n    },\r\n\r\n    cellMouseout: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n        var view = this.findView(evt.target);\r\n        if (view) {\r\n            if (this.guard(evt, view)) return;\r\n            view.mouseout(evt);\r\n        }\r\n    },\r\n\r\n    cellMouseenter: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n        var view = this.findView(evt.target);\r\n        if (view && !this.guard(evt, view)) {\r\n            view.mouseenter(evt);\r\n        }\r\n    },\r\n\r\n    cellMouseleave: function(evt) {\r\n\r\n        evt = joint.util.normalizeEvent(evt);\r\n        var view = this.findView(evt.target);\r\n        if (view && !this.guard(evt, view)) {\r\n            view.mouseleave(evt);\r\n        }\r\n    },\r\n\r\n    setGridSize: function(gridSize) {\r\n\r\n        this.options.gridSize = gridSize;\r\n\r\n        if (this.options.drawGrid) {\r\n            this.drawGrid();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    clearGrid: function() {\r\n\r\n        if (this.$grid) {\r\n            this.$grid.css('backgroundImage', 'none');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    _getGriRefs: function () {\r\n\r\n        if (!this._gridCache) {\r\n\r\n            this._gridCache = {\r\n                root: V('svg', { width: '100%', height: '100%' }, V('defs')),\r\n                patterns: {},\r\n                add: function (id, vel) {\r\n                    V(this.root.node.childNodes[0]).append(vel);\r\n                    this.patterns[id] = vel;\r\n                    this.root.append(V('rect', { width: \"100%\", height: \"100%\", fill: 'url(#' + id + ')' }));\r\n                },\r\n                get: function (id) {\r\n                    return  this.patterns[id]\r\n                },\r\n                exist: function (id) {\r\n                    return this.patterns[id] !== undefined;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._gridCache;\r\n    },\r\n\r\n    setGrid:function (drawGrid) {\r\n\r\n        this.clearGrid();\r\n\r\n        this._gridCache = null;\r\n        this._gridSettings = [];\r\n\r\n        var optionsList = _.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\r\n        _.each(optionsList, function (item) {\r\n            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\r\n        }, this);\r\n        return this;\r\n    },\r\n\r\n    _resolveDrawGridOption: function (opt) {\r\n\r\n        var namespace = this.constructor.gridPatterns;\r\n        if (_.isString(opt) && namespace[opt]) {\r\n            return _.map(namespace[opt], _.clone);\r\n        }\r\n\r\n        var options = opt || { args: [{}] };\r\n        var isArray = _.isArray(options);\r\n        var name = options.name;\r\n\r\n        if (!isArray && !name && !options.markup ) {\r\n            name = 'dot';\r\n        }\r\n\r\n        if (name && namespace[name]) {\r\n            var pattern = _.map(namespace[name], _.clone);\r\n\r\n            var args = _.isArray(options.args) ? options.args : [options.args || {}];\r\n\r\n            _.defaults(args[0], _.omit(opt, 'args'));\r\n            for (var i = 0; i < args.length; i++) {\r\n                if (pattern[i]) {\r\n                    _.extend(pattern[i], args[i]);\r\n                }\r\n            }\r\n            return pattern;\r\n        }\r\n\r\n        return isArray ? options : [options];\r\n    },\r\n\r\n    drawGrid: function(opt) {\r\n\r\n        var gridSize = this.options.gridSize;\r\n        if (gridSize <= 1) {\r\n            return this.clearGrid();\r\n        }\r\n\r\n        var localOptions = _.isArray(opt) ? opt : [opt];\r\n\r\n        var ctm = this.matrix();\r\n        var refs = this._getGriRefs();\r\n\r\n        _.each(this._gridSettings, function (gridLayerSetting, index) {\r\n\r\n            var id = 'pattern_'  + index;\r\n            var options = _.merge(gridLayerSetting, localOptions[index], {\r\n                sx: ctm.a || 1,\r\n                sy: ctm.d || 1,\r\n                ox: ctm.e || 0,\r\n                oy: ctm.f || 0\r\n            });\r\n\r\n            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\r\n            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\r\n\r\n            if (!refs.exist(id)) {\r\n                refs.add(id, V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup)))\r\n            }\r\n\r\n            var patternDefVel = refs.get(id);\r\n\r\n            if (_.isFunction(options.update)) {\r\n                options.update(patternDefVel.node.childNodes[0], options);\r\n            }\r\n\r\n            var x = options.ox % options.width;\r\n            if (x < 0) x += options.width;\r\n\r\n            var y = options.oy % options.height;\r\n            if (y < 0) y += options.height;\r\n\r\n            patternDefVel.attr({\r\n                x: x,\r\n                y: y,\r\n                width: options.width,\r\n                height: options.height\r\n            });\r\n        });\r\n\r\n        var patternUri = new XMLSerializer().serializeToString(refs.root.node);\r\n        patternUri = 'url(data:image/svg+xml;base64,' + btoa(patternUri) + ')';\r\n\r\n        this.$grid.css('backgroundImage', patternUri);\r\n\r\n        return this;\r\n    },\r\n\r\n    updateBackgroundImage: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var backgroundPosition = opt.position || 'center';\r\n        var backgroundSize = opt.size || 'auto auto';\r\n\r\n        var currentScale = this.scale();\r\n        var currentTranslate = this.translate();\r\n\r\n        // backgroundPosition\r\n        if (_.isObject(backgroundPosition)) {\r\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\r\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\r\n            backgroundPosition = x + 'px ' + y + 'px';\r\n        }\r\n\r\n        // backgroundSize\r\n        if (_.isObject(backgroundSize)) {\r\n            backgroundSize = g.rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\r\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\r\n        }\r\n\r\n        this.$background.css({\r\n            backgroundSize: backgroundSize,\r\n            backgroundPosition: backgroundPosition\r\n        });\r\n    },\r\n\r\n    drawBackgroundImage: function(img, opt) {\r\n\r\n        // Clear the background image if no image provided\r\n        if (!(img instanceof HTMLImageElement)) {\r\n            this.$background.css('backgroundImage', '');\r\n            return;\r\n        }\r\n\r\n        opt = opt || {};\r\n\r\n        var backgroundImage;\r\n        var backgroundSize = opt.size;\r\n        var backgroundRepeat = opt.repeat || 'no-repeat';\r\n        var backgroundOpacity = opt.opacity || 1;\r\n        var backgroundQuality = Math.abs(opt.quality) || 1;\r\n        var backgroundPattern = this.constructor.backgroundPatterns[_.camelCase(backgroundRepeat)];\r\n\r\n        if (_.isFunction(backgroundPattern)) {\r\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\r\n            img.width *= backgroundQuality;\r\n            img.height *= backgroundQuality;\r\n            var canvas = backgroundPattern(img, opt);\r\n            if (!(canvas instanceof HTMLCanvasElement)) {\r\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\r\n            }\r\n\r\n            backgroundImage = canvas.toDataURL('image/png');\r\n            backgroundRepeat = 'repeat';\r\n            if (_.isObject(backgroundSize)) {\r\n                // recalculate the tile size if an object passed in\r\n                backgroundSize.width *= canvas.width / img.width;\r\n                backgroundSize.height *= canvas.height / img.height;\r\n            } else if (_.isUndefined(backgroundSize)) {\r\n                // calcule the tile size if no provided\r\n                opt.size = {\r\n                    width: canvas.width / backgroundQuality,\r\n                    height: canvas.height / backgroundQuality\r\n                };\r\n            }\r\n        } else {\r\n            // backgroundRepeat:\r\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\r\n            backgroundImage = img.src;\r\n            if (_.isUndefined(backgroundSize)) {\r\n                // pass the image size for  the backgroundSize if no size provided\r\n                opt.size = {\r\n                    width: img.width,\r\n                    height: img.height\r\n                };\r\n            }\r\n        }\r\n\r\n        this.$background.css({\r\n            opacity: backgroundOpacity,\r\n            backgroundRepeat: backgroundRepeat,\r\n            backgroundImage: 'url(' + backgroundImage + ')'\r\n        });\r\n\r\n        this.updateBackgroundImage(opt);\r\n    },\r\n\r\n    updateBackgroundColor: function(color) {\r\n\r\n        this.$el.css('backgroundColor', color || '');\r\n    },\r\n\r\n    drawBackground: function(opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        this.updateBackgroundColor(opt.color);\r\n\r\n        if (opt.image) {\r\n            opt = this._background = _.cloneDeep(opt);\r\n            var img = document.createElement('img');\r\n            img.onload = _.bind(this.drawBackgroundImage, this, img, opt);\r\n            img.src = opt.image;\r\n        } else {\r\n            this.drawBackgroundImage(null);\r\n            this._background = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    setInteractivity: function(value) {\r\n\r\n        this.options.interactive = value;\r\n\r\n        _.invoke(this._views, 'setInteractivity', value);\r\n    },\r\n\r\n    // Paper Defs\r\n\r\n    isDefined: function(defId) {\r\n        return !!this.svg.getElementById(defId);\r\n    },\r\n\r\n    defineFilter: function(filter) {\r\n\r\n        if (!_.isObject(filter)) {\r\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\r\n        }\r\n\r\n        var filterId = filter.id;\r\n        var name = filter.name;\r\n        // Generate a hash code from the stringified filter definition. This gives us\r\n        // a unique filter ID for different definitions.\r\n        if (!filterId) {\r\n            filterId = name + this.svg.id + joint.util.hashCode(JSON.stringify(filter));\r\n        }\r\n        // If the filter already exists in the document,\r\n        // we're done and we can just use it (reference it using `url()`).\r\n        // If not, create one.\r\n        if (!this.isDefined(filterId)) {\r\n\r\n            var namespace = joint.util.filter;\r\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\r\n            if (!filterSVGString) {\r\n                throw new Error('Non-existing filter ' + name);\r\n            }\r\n\r\n            // Set the filter area to be 3x the bounding box of the cell\r\n            // and center the filter around the cell.\r\n            var filterAttrs = _.extend({\r\n                filterUnits: 'objectBoundingBox',\r\n                x: -1,\r\n                y: -1,\r\n                width: 3,\r\n                height: 3\r\n            }, filter.attrs, {\r\n                id: filterId\r\n            });\r\n\r\n            V(filterSVGString, filterAttrs).appendTo(this.defs);\r\n        }\r\n\r\n        return filterId;\r\n    },\r\n\r\n    defineGradient: function(gradient) {\r\n\r\n        if (!_.isObject(gradient)) {\r\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\r\n        }\r\n\r\n        var gradientId = gradient.id;\r\n        var type = gradient.type;\r\n        var stops = gradient.stops;\r\n        // Generate a hash code from the stringified filter definition. This gives us\r\n        // a unique filter ID for different definitions.\r\n        if (!gradientId) {\r\n            gradientId = type + this.svg.id + joint.util.hashCode(JSON.stringify(gradient));\r\n        }\r\n        // If the gradient already exists in the document,\r\n        // we're done and we can just use it (reference it using `url()`).\r\n        // If not, create one.\r\n        if (!this.isDefined(gradientId)) {\r\n\r\n            var stopTemplate = joint.util.template('<stop offset=\"${offset}\" stop-color=\"${color}\" stop-opacity=\"${opacity}\"/>');\r\n            var gradientStopsStrings = _.map(stops, function(stop) {\r\n                return stopTemplate({\r\n                    offset: stop.offset,\r\n                    color: stop.color,\r\n                    opacity: _.isFinite(stop.opacity) ? stop.opacity : 1\r\n                });\r\n            });\r\n\r\n            var gradientSVGString = [\r\n                '<' + type + '>',\r\n                gradientStopsStrings.join(''),\r\n                '</' + type + '>'\r\n            ].join('');\r\n\r\n            var gradientAttrs = _.extend({ id: gradientId }, gradient.attrs);\r\n\r\n            V(gradientSVGString, gradientAttrs).appendTo(this.defs);\r\n        }\r\n\r\n        return gradientId;\r\n    },\r\n\r\n    defineMarker: function(marker) {\r\n\r\n        if (!_.isObject(marker)) {\r\n            throw new TypeError('dia.Paper: defineMarker() requires 1. argument to be an object.');\r\n        }\r\n\r\n        var markerId = marker.id;\r\n\r\n        // Generate a hash code from the stringified filter definition. This gives us\r\n        // a unique filter ID for different definitions.\r\n        if (!markerId) {\r\n            markerId = this.svg.id + joint.util.hashCode(JSON.stringify(marker));\r\n        }\r\n\r\n        if (!this.isDefined(markerId)) {\r\n\r\n            var attrs = _.omit(marker, 'type', 'userSpaceOnUse');\r\n            var pathMarker = V('marker', {\r\n                id: markerId,\r\n                orient: 'auto',\r\n                overflow: 'visible',\r\n                markerUnits: marker.markerUnits || 'userSpaceOnUse'\r\n            }, [\r\n                V(marker.type || 'path', attrs)\r\n            ]);\r\n\r\n            pathMarker.appendTo(this.defs);\r\n        }\r\n\r\n        return markerId;\r\n    }\r\n\r\n}, {\r\n\r\n    backgroundPatterns: {\r\n\r\n        flipXy: function(img) {\r\n            // d b\r\n            // q p\r\n\r\n            var canvas = document.createElement('canvas');\r\n            var imgWidth = img.width;\r\n            var imgHeight = img.height;\r\n\r\n            canvas.width = 2 * imgWidth;\r\n            canvas.height = 2 * imgHeight;\r\n\r\n            var ctx = canvas.getContext('2d');\r\n            // top-left image\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n            // xy-flipped bottom-right image\r\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n            // x-flipped top-right image\r\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n            // y-flipped bottom-left image\r\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n\r\n            return canvas;\r\n        },\r\n\r\n        flipX: function(img) {\r\n            // d b\r\n            // d b\r\n\r\n            var canvas = document.createElement('canvas');\r\n            var imgWidth = img.width;\r\n            var imgHeight = img.height;\r\n\r\n            canvas.width = imgWidth * 2;\r\n            canvas.height = imgHeight;\r\n\r\n            var ctx = canvas.getContext('2d');\r\n            // left image\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n            // flipped right image\r\n            ctx.translate(2 * imgWidth, 0);\r\n            ctx.scale(-1, 1);\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n\r\n            return canvas;\r\n        },\r\n\r\n        flipY: function(img) {\r\n            // d d\r\n            // q q\r\n\r\n            var canvas = document.createElement('canvas');\r\n            var imgWidth = img.width;\r\n            var imgHeight = img.height;\r\n\r\n            canvas.width = imgWidth;\r\n            canvas.height = imgHeight * 2;\r\n\r\n            var ctx = canvas.getContext('2d');\r\n            // top image\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n            // flipped bottom image\r\n            ctx.translate(0, 2 * imgHeight);\r\n            ctx.scale(1, -1);\r\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\r\n\r\n            return canvas;\r\n        },\r\n\r\n        watermark: function(img, opt) {\r\n            //   d\r\n            // d\r\n\r\n            opt = opt || {};\r\n\r\n            var imgWidth = img.width;\r\n            var imgHeight = img.height;\r\n\r\n            var canvas = document.createElement('canvas');\r\n            canvas.width = imgWidth * 3;\r\n            canvas.height = imgHeight * 3;\r\n\r\n            var ctx = canvas.getContext('2d');\r\n            var angle = _.isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\r\n            var radians = g.toRad(angle);\r\n            var stepX = canvas.width / 4;\r\n            var stepY = canvas.height / 4;\r\n\r\n            for (var i = 0; i < 4; i ++) {\r\n                for (var j = 0; j < 4; j++) {\r\n                    if ((i + j) % 2 > 0) {\r\n                        // reset the current transformations\r\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1)  * stepY);\r\n                        ctx.rotate(radians);\r\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return canvas;\r\n        }\r\n    },\r\n\r\n    gridPatterns: {\r\n        dot: [{\r\n            color: '#AAAAAA',\r\n            thickness: 1,\r\n            markup: 'rect',\r\n            update: function(el, opt) {\r\n                V(el).attr({\r\n                    width: opt.thickness * opt.sx,\r\n                    height: opt.thickness * opt.sy,\r\n                    fill: opt.color\r\n                });\r\n            }\r\n        }],\r\n        fixedDot: [{\r\n            color: '#AAAAAA',\r\n            thickness: 1,\r\n            markup: 'rect',\r\n            update: function(el, opt) {\r\n                var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\r\n                V(el).attr({ width: size, height: size, fill: opt.color });\r\n            }\r\n        }],\r\n        mesh: [{\r\n            color: '#AAAAAA',\r\n            thickness: 1,\r\n            markup: 'path',\r\n            update: function(el, opt) {\r\n\r\n                var d;\r\n                var width = opt.width;\r\n                var height = opt.height;\r\n                var thickness = opt.thickness;\r\n\r\n                if (width - thickness >= 0 && height - thickness >= 0) {\r\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\r\n                } else {\r\n                    d = 'M 0 0 0 0';\r\n                }\r\n\r\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\r\n            }\r\n        }],\r\n        doubleMesh: [{\r\n            color: '#AAAAAA',\r\n            thickness: 1,\r\n            markup: 'path',\r\n            update: function(el, opt) {\r\n\r\n                var d;\r\n                var width = opt.width;\r\n                var height = opt.height;\r\n                var thickness = opt.thickness;\r\n\r\n                if (width - thickness >= 0 && height - thickness >= 0) {\r\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\r\n                } else {\r\n                    d = 'M 0 0 0 0';\r\n                }\r\n\r\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\r\n            }\r\n        }, {\r\n            color: '#000000',\r\n            thickness: 3,\r\n            scaleFactor: 4,\r\n            markup: 'path',\r\n            update: function(el, opt) {\r\n\r\n                var d;\r\n                var width = opt.width;\r\n                var height = opt.height;\r\n                var thickness = opt.thickness;\r\n\r\n                if (width - thickness >= 0 && height - thickness >= 0) {\r\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\r\n                } else {\r\n                    d = 'M 0 0 0 0';\r\n                }\r\n\r\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\r\n            }\r\n        }]\r\n    }\r\n});\r\n\r\n(function(joint, _) {\r\n\r\n    var PortData = function(data) {\r\n\r\n        var clonedData = _.cloneDeep(data) || {};\r\n        this.ports = [];\r\n        this.groups = {};\r\n        this.portLayoutNamespace = joint.layout.Port;\r\n        this.portLabelLayoutNamespace = joint.layout.PortLabel;\r\n\r\n        this._init(clonedData);\r\n    };\r\n\r\n    PortData.prototype = {\r\n\r\n        getPorts: function() {\r\n            return this.ports;\r\n        },\r\n\r\n        getGroup: function(name) {\r\n            return this.groups[name] || {};\r\n        },\r\n\r\n        getPortsByGroup: function(groupName) {\r\n\r\n            return _.filter(this.ports, function(port) {\r\n                return port.group === groupName;\r\n            });\r\n        },\r\n\r\n        getGroupPortsMetrics: function(groupName, elBBox) {\r\n\r\n            var group = this.getGroup(groupName);\r\n            var ports = this.getPortsByGroup(groupName);\r\n\r\n            var groupPosition = group.position || {};\r\n            var groupPositionName = groupPosition.name;\r\n            var namespace = this.portLayoutNamespace;\r\n            if (!namespace[groupPositionName]) {\r\n                groupPositionName = 'left';\r\n            }\r\n\r\n            var groupArgs = groupPosition.args || {};\r\n            var portsArgs = _.pluck(ports, 'position.args');\r\n            var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\r\n\r\n            return _.transform(groupPortTransformations, _.bind(function(result, portTransformation, index) {\r\n                var port = ports[index];\r\n                result.push({\r\n                    portId: port.id,\r\n                    portTransformation: portTransformation,\r\n                    labelTransformation: this._getPortLabelLayout(port, g.Point(portTransformation), elBBox),\r\n                    portAttrs: port.attrs,\r\n                    portSize: port.size,\r\n                    labelSize: port.label.size\r\n                });\r\n            }, this), []);\r\n        },\r\n\r\n        _getPortLabelLayout: function(port, portPosition, elBBox) {\r\n\r\n            var namespace = this.portLabelLayoutNamespace;\r\n            var labelPosition = port.label.position.name || 'left';\r\n\r\n            if (namespace[labelPosition]) {\r\n                return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\r\n            }\r\n\r\n            return null;\r\n        },\r\n\r\n        _init: function(data) {\r\n\r\n            // prepare groups\r\n            _.transform(data.groups || {}, _.bind(this._evaluateGroup, this), this.groups);\r\n            // prepare ports\r\n            _.transform(data.items || [], _.bind(this._evaluatePort, this), this.ports);\r\n        },\r\n\r\n        _evaluateGroup: function (resultMap, group, key) {\r\n\r\n            resultMap[key] = _.merge(group, {\r\n                position: this._getPosition(group.position, true),\r\n                label: this._getLabel(group, true)\r\n            });\r\n        },\r\n\r\n        _evaluatePort: function(resultArray, port) {\r\n\r\n            var evaluated = _.clone(port);\r\n\r\n            var group = this.getGroup(port.group);\r\n\r\n            evaluated.markup = evaluated.markup || group.markup;\r\n            evaluated.attrs = _.merge({}, group.attrs, evaluated.attrs);\r\n            evaluated.position = this._createPositionNode(group, evaluated);\r\n            evaluated.label = _.merge({}, group.label, this._getLabel(evaluated));\r\n            evaluated.z = this._getZIndex(group, evaluated);\r\n            evaluated.size = _.extend({}, group.size, evaluated.size);\r\n\r\n            resultArray.push(evaluated);\r\n        },\r\n\r\n        _getZIndex: function(group, port) {\r\n\r\n            if (_.isNumber(port.z)) {\r\n                return port.z;\r\n            }\r\n            if (_.isNumber(group.z) || group.z === 'auto') {\r\n                return group.z;\r\n            }\r\n            return 'auto';\r\n        },\r\n\r\n        _createPositionNode: function(group, port) {\r\n\r\n            return _.merge({\r\n                name: 'left',\r\n                args: {}\r\n            }, group.position, { args: port.args });\r\n        },\r\n\r\n        _getPosition: function(position, setDefault) {\r\n\r\n            var args = {};\r\n            var positionName;\r\n\r\n            if (_.isFunction(position)) {\r\n                positionName = 'fn';\r\n                args.fn = position;\r\n            } else if (_.isString(position)) {\r\n                positionName = position;\r\n            } else if (_.isUndefined(position)) {\r\n                positionName = setDefault ? 'left' : null;\r\n            } else if (_.isArray(position)) {\r\n                positionName = 'absolute';\r\n                args.x = position[0];\r\n                args.y = position[1];\r\n            } else if (_.isObject(position)) {\r\n                positionName = position.name;\r\n                _.extend(args, position.args);\r\n            }\r\n\r\n            var result = { args: args };\r\n\r\n            if (positionName) {\r\n                result.name = positionName;\r\n            }\r\n            return result;\r\n        },\r\n\r\n        _getLabel: function(item, setDefaults) {\r\n\r\n            var label = item.label || {};\r\n\r\n            var ret = label;\r\n            ret.position = this._getPosition(label.position, setDefaults);\r\n\r\n            return ret;\r\n        }\r\n    };\r\n\r\n    _.extend(joint.dia.Element.prototype, {\r\n\r\n        _initializePorts: function() {\r\n\r\n            this._createPortData();\r\n            this.on('change:ports', function() {\r\n\r\n                this._processRemovedPort();\r\n                this._createPortData();\r\n            }, this);\r\n        },\r\n\r\n        /**\r\n         * remove links tied wiht just removed element\r\n         * @private\r\n         */\r\n        _processRemovedPort: function() {\r\n\r\n            var current = this.get('ports') || {};\r\n            var currentItemsMap = {};\r\n\r\n            _.each(current.items, function(item) {\r\n                currentItemsMap[item.id] = true;\r\n            });\r\n\r\n            var previous = this.previous('ports') || {};\r\n            var removed = {};\r\n\r\n            _.each(previous.items, function(item) {\r\n                if (!currentItemsMap[item.id]) {\r\n                    removed[item.id] = true;\r\n                }\r\n            });\r\n\r\n            var graph = this.graph;\r\n            if (graph && !_.isEmpty(removed)) {\r\n\r\n                var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\r\n                _.each(inboundLinks, function(link) {\r\n\r\n                    if (removed[link.get('target').port]) link.remove();\r\n                });\r\n\r\n                var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\r\n                _.each(outboundLinks, function(link) {\r\n\r\n                    if (removed[link.get('source').port]) link.remove();\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @returns {boolean}\r\n         */\r\n        hasPorts: function() {\r\n\r\n            return this.prop('ports/items').length > 0;\r\n        },\r\n\r\n        /**\r\n         * @param {string} id\r\n         * @returns {boolean}\r\n         */\r\n        hasPort: function(id) {\r\n\r\n            return this.getPortIndex(id) !== -1;\r\n        },\r\n\r\n        /**\r\n         * @returns {Array<object>}\r\n         */\r\n        getPorts: function() {\r\n\r\n            return _.cloneDeep(this.prop('ports/items')) || [];\r\n        },\r\n\r\n        /**\r\n         * @param {string} id\r\n         * @returns {object}\r\n         */\r\n        getPort: function(id) {\r\n\r\n            return _.cloneDeep(_.find(this.prop('ports/items'), function(port) {\r\n                return port.id && port.id === id;\r\n            }));\r\n        },\r\n\r\n        /**\r\n         * @param {string} groupName\r\n         * @returns {Object<portId, {x: number, y: number, angle: number}>}\r\n         */\r\n        getPortsPositions: function(groupName) {\r\n\r\n            var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, g.Rect(this.size()));\r\n\r\n            return _.transform(portsMetrics, function(positions, metrics) {\r\n                var transformation = metrics.portTransformation;\r\n                positions[metrics.portId] = {\r\n                    x: transformation.x,\r\n                    y: transformation.y,\r\n                    angle: transformation.angle\r\n                };\r\n            }, {});\r\n        },\r\n\r\n        /**\r\n         * @param {string|Port} port port id or port\r\n         * @returns {number} port index\r\n         */\r\n        getPortIndex: function(port) {\r\n\r\n            var id = _.isObject(port) ? port.id : port;\r\n\r\n            if (!this._isValidPortId(id)) {\r\n                return -1;\r\n            }\r\n\r\n            return _.findIndex(this.prop('ports/items'), { id: id });\r\n        },\r\n\r\n        /**\r\n         * @param {object} port\r\n         * @param {object} [opt]\r\n         * @returns {joint.dia.Element}\r\n         */\r\n        addPort: function(port, opt) {\r\n\r\n            if (!_.isObject(port) || _.isArray(port)) {\r\n                throw new Error('Element: addPort requires an object.');\r\n            }\r\n\r\n            var ports = _.clone(this.prop('ports/items')) || [];\r\n            ports.push(port);\r\n            this.prop('ports/items', ports, opt);\r\n\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * @param {string} portId\r\n         * @param {string|object=} path\r\n         * @param {*=} value\r\n         * @param {object=} opt\r\n         * @returns {joint.dia.Element}\r\n         */\r\n        portProp: function(portId, path, value, opt) {\r\n\r\n            var index = this.getPortIndex(portId);\r\n\r\n            if (index === -1) {\r\n                throw new Error('Element: unable to find port with id ' + portId);\r\n            }\r\n\r\n            var args = Array.prototype.slice.call(arguments, 1);\r\n            if (_.isArray(path)) {\r\n                args[0] = ['ports', 'items', index].concat(path);\r\n            } else if (_.isString(path)) {\r\n\r\n                // Get/set an attribute by a special path syntax that delimits\r\n                // nested objects by the colon character.\r\n                args[0] = ['ports/items/', index, '/', path].join('');\r\n\r\n            } else {\r\n\r\n                args = ['ports/items/' + index];\r\n                if (_.isPlainObject(path)) {\r\n                    args.push(path);\r\n                    args.push(value);\r\n                }\r\n            }\r\n\r\n            return this.prop.apply(this, args);\r\n        },\r\n\r\n        _validatePorts: function() {\r\n\r\n            var portsAttr = this.get('ports') || {};\r\n\r\n            var errorMessages = [];\r\n            portsAttr = portsAttr || {};\r\n            var ports = portsAttr.items || [];\r\n\r\n            _.each(ports, function(p) {\r\n                if (!this._isValidPortId(p.id)) {\r\n                    p.id = joint.util.uuid();\r\n                }\r\n            }, this);\r\n\r\n            if (_.uniq(ports, 'id').length !== ports.length) {\r\n                errorMessages.push('Element: found id duplicities in ports.');\r\n            }\r\n\r\n            return errorMessages;\r\n        },\r\n\r\n        /**\r\n         * @param {string} id port id\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _isValidPortId: function(id) {\r\n\r\n            return !_.isNull(id) && !_.isUndefined(id) && !_.isObject(id);\r\n        },\r\n\r\n        addPorts: function(ports, opt) {\r\n\r\n            if (ports.length) {\r\n                this.prop('ports/items', (_.clone(this.prop('ports/items')) || []).concat(ports), opt);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        removePort: function(port, opt) {\r\n\r\n            var options = opt || {};\r\n            var ports = _.clone(this.prop('ports/items'));\r\n\r\n            var index = this.getPortIndex(port);\r\n\r\n            if (index !== -1) {\r\n                ports.splice(index, 1);\r\n                options.rewrite = true;\r\n                this.prop('ports/items', ports, options);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _createPortData: function() {\r\n\r\n            var err = this._validatePorts();\r\n\r\n            if (err.length > 0) {\r\n                this.set('ports', this.previous('ports'));\r\n                throw new Error(err.join(' '));\r\n            }\r\n\r\n            var prevPortData;\r\n\r\n            if (this._portSettingsData) {\r\n\r\n                prevPortData = this._portSettingsData.getPorts();\r\n            }\r\n\r\n            this._portSettingsData = new PortData(this.get('ports'));\r\n\r\n            var curPortData = this._portSettingsData.getPorts();\r\n\r\n            if (prevPortData) {\r\n\r\n                // _.filter can be replaced with _.differenceBy in lodash 4\r\n                var added = _.filter(curPortData, function(item) {\r\n                    if (!_.find(prevPortData, 'id', item.id)) {\r\n                        return item;\r\n                    }\r\n                });\r\n\r\n                var removed = _.filter(prevPortData, function(item) {\r\n                    if (!_.find(curPortData, 'id', item.id)) {\r\n                        return item;\r\n                    }\r\n                });\r\n\r\n                if (removed.length > 0) {\r\n                    this.trigger('ports:remove', this, removed);\r\n                }\r\n\r\n                if (added.length > 0) {\r\n                    this.trigger('ports:add', this, added);\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    _.extend(joint.dia.ElementView.prototype, {\r\n\r\n        portContainerMarkup: '<g class=\"joint-port\"/>',\r\n        portMarkup: '<circle class=\"joint-port-body\" r=\"10\" fill=\"#FFFFFF\" stroke=\"#000000\"/>',\r\n        portLabelMarkup: '<text class=\"joint-port-label\" fill=\"#000000\"/>',\r\n        /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\r\n        _portElementsCache: null,\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _initializePorts: function() {\r\n\r\n            this._portElementsCache = {};\r\n\r\n            this.listenTo(this.model, 'change:ports', function() {\r\n\r\n                this._refreshPorts();\r\n            });\r\n        },\r\n\r\n        /**\r\n         * @typedef {Object} Port\r\n         *\r\n         * @property {string} id\r\n         * @property {Object} position\r\n         * @property {Object} label\r\n         * @property {Object} attrs\r\n         * @property {string} markup\r\n         * @property {string} group\r\n         */\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _refreshPorts: function() {\r\n\r\n            this._removePorts();\r\n            this._portElementsCache = {};\r\n\r\n            this._renderPorts();\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _renderPorts: function() {\r\n\r\n            // references to rendered elements without z-index\r\n            var elementReferences = [];\r\n            var elem = this._getContainerElement();\r\n            _.each(elem.node.childNodes, function(n) {\r\n                elementReferences.push(n);\r\n            });\r\n\r\n            var portsGropsByZ = _.groupBy(this.model._portSettingsData.getPorts(), 'z');\r\n            var withoutZKey = 'auto';\r\n\r\n            // render non-z first\r\n            _.each(portsGropsByZ[withoutZKey], function(port) {\r\n                var portElement = this._getPortElement(port);\r\n                elem.append(portElement);\r\n                elementReferences.push(portElement);\r\n            }, this);\r\n\r\n            _.each(portsGropsByZ, function(groupPorts, groupName) {\r\n                if (groupName !== withoutZKey) {\r\n                    var z = parseInt(groupName, 10);\r\n                    this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\r\n                }\r\n            }, this);\r\n\r\n            this._updatePorts();\r\n        },\r\n\r\n        /**\r\n         * @returns {V}\r\n         * @private\r\n         */\r\n        _getContainerElement: function() {\r\n\r\n            return this.rotatableNode || this.vel;\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Port>}ports\r\n         * @param {number} z\r\n         * @param refs\r\n         * @private\r\n         */\r\n        _appendPorts: function(ports, z, refs) {\r\n\r\n            var containerElement = this._getContainerElement();\r\n            var portElements = _.map(ports, this._getPortElement, this);\r\n\r\n            if (refs[z] || z < 0) {\r\n                V(refs[Math.max(z, 0)]).before(portElements);\r\n            } else {\r\n                containerElement.append(portElements);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Try to get element from cache,\r\n         * @param port\r\n         * @returns {*}\r\n         * @private\r\n         */\r\n        _getPortElement: function(port) {\r\n\r\n            if (this._portElementsCache[port.id]) {\r\n                return this._portElementsCache[port.id].portElement;\r\n            }\r\n            return this._createPortElement(port);\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _updatePorts: function() {\r\n\r\n            // layout ports without group\r\n            this._updatePortGroup(undefined);\r\n            // layout ports with explicit group\r\n            var groupsNames = _.keys(this.model._portSettingsData.groups);\r\n            _.each(groupsNames, this._updatePortGroup, this);\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        _removePorts: function() {\r\n            _.invoke(this._portElementsCache, 'portElement.remove');\r\n        },\r\n\r\n        /**\r\n         * @param {Port} port\r\n         * @returns {V}\r\n         * @private\r\n         */\r\n        _createPortElement: function(port) {\r\n\r\n            var portContentElement = V(this._getPortMarkup(port));\r\n            var portLabelContentElement = V(this._getPortLabelMarkup(port.label));\r\n\r\n            if (portContentElement && portContentElement.length > 1) {\r\n                throw new Error('ElementView: Invalid port markup - multiple roots.');\r\n            }\r\n\r\n            portContentElement.attr({\r\n                'port': port.id,\r\n                'port-group': port.group\r\n            });\r\n\r\n            var portElement = V(this.portContainerMarkup)\r\n                .append(portContentElement)\r\n                .append(portLabelContentElement);\r\n\r\n            this._portElementsCache[port.id] = {\r\n                portElement: portElement,\r\n                portLabelElement: portLabelContentElement\r\n            };\r\n\r\n            return portElement;\r\n        },\r\n\r\n        /**\r\n         * @param {string=} groupName\r\n         * @private\r\n         */\r\n        _updatePortGroup: function(groupName) {\r\n\r\n            var elementBBox = g.Rect(this.model.size());\r\n            var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\r\n\r\n            for (var i = 0, n = portsMetrics.length; i < n; i++) {\r\n                var metrics = portsMetrics[i];\r\n                var portId = metrics.portId;\r\n                var cached = this._portElementsCache[portId] || {};\r\n                var portTransformation = metrics.portTransformation;\r\n                this.applyPortTransform(cached.portElement, portTransformation);\r\n                this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\r\n                    rootBBox: g.Rect(metrics.portSize)\r\n                });\r\n\r\n                var labelTransformation = metrics.labelTransformation;\r\n                if (labelTransformation) {\r\n                    this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\r\n                    this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\r\n                        rootBBox: g.Rect(metrics.labelSize)\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @param {Vectorizer} element\r\n         * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\r\n         * @param {number=} initialAngle\r\n         * @constructor\r\n         */\r\n        applyPortTransform: function(element, transformData, initialAngle) {\r\n\r\n            var matrix = V.createSVGMatrix()\r\n                .rotate(initialAngle || 0)\r\n                .translate(transformData.x || 0, transformData.y || 0)\r\n                .rotate(transformData.angle || 0);\r\n\r\n            element.transform(matrix, { absolute: true });\r\n        },\r\n\r\n        /**\r\n         * @param {Port} port\r\n         * @returns {string}\r\n         * @private\r\n         */\r\n        _getPortMarkup: function(port) {\r\n\r\n            return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\r\n        },\r\n\r\n        /**\r\n         * @param {Object} label\r\n         * @returns {string}\r\n         * @private\r\n         */\r\n        _getPortLabelMarkup: function(label) {\r\n\r\n            return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\r\n        }\r\n\r\n    });\r\n}(joint, _));\r\n\r\n\r\njoint.shapes.basic = {};\r\n\r\njoint.shapes.basic.Generic = joint.dia.Element.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Generic',\r\n        attrs: {\r\n            '.': { fill: '#ffffff', stroke: 'none' }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Rect = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Rect',\r\n        attrs: {\r\n            'rect': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000',\r\n                width: 100,\r\n                height: 60\r\n            },\r\n            'text': {\r\n                fill: '#000000',\r\n                text: '',\r\n                'font-size': 14,\r\n                'ref-x': .5,\r\n                'ref-y': .5,\r\n                'text-anchor': 'middle',\r\n                'y-alignment': 'middle',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.TextView = joint.dia.ElementView.extend({\r\n\r\n    initialize: function() {\r\n        joint.dia.ElementView.prototype.initialize.apply(this, arguments);\r\n        // The element view is not automatically rescaled to fit the model size\r\n        // when the attribute 'attrs' is changed.\r\n        this.listenTo(this.model, 'change:attrs', this.resize);\r\n    }\r\n});\r\n\r\njoint.shapes.basic.Text = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Text',\r\n        attrs: {\r\n            'text': {\r\n                'font-size': 18,\r\n                fill: '#000000'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Circle = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Circle',\r\n        size: { width: 60, height: 60 },\r\n        attrs: {\r\n            'circle': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000',\r\n                r: 30,\r\n                cx: 30,\r\n                cy: 30\r\n            },\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-y': .5,\r\n                'y-alignment': 'middle',\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Ellipse = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Ellipse',\r\n        size: { width: 60, height: 40 },\r\n        attrs: {\r\n            'ellipse': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000',\r\n                rx: 30,\r\n                ry: 20,\r\n                cx: 30,\r\n                cy: 20\r\n            },\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-y': .5,\r\n                'y-alignment': 'middle',\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Polygon = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Polygon',\r\n        size: { width: 60, height: 40 },\r\n        attrs: {\r\n            'polygon': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000'\r\n            },\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-dy': 20,\r\n                'y-alignment': 'middle',\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Polyline = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Polyline',\r\n        size: { width: 60, height: 40 },\r\n        attrs: {\r\n            'polyline': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000'\r\n            },\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-dy': 20,\r\n                'y-alignment': 'middle',\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Image = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Image',\r\n        attrs: {\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-dy': 20,\r\n                'y-alignment': 'middle',\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Path = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Path',\r\n        size: { width: 60, height: 60 },\r\n        attrs: {\r\n            'path': {\r\n                fill: '#ffffff',\r\n                stroke: '#000000'\r\n            },\r\n            'text': {\r\n                'font-size': 14,\r\n                text: '',\r\n                'text-anchor': 'middle',\r\n                'ref': 'path',\r\n                'ref-x': .5,\r\n                'ref-dy': 10,\r\n                fill: '#000000',\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.basic.Rhombus = joint.shapes.basic.Path.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.Rhombus',\r\n        attrs: {\r\n            'path': {\r\n                d: 'M 30 0 L 60 30 30 60 0 30 z'\r\n            },\r\n            'text': {\r\n                'ref-y': .5,\r\n                'ref-dy': null,\r\n                'y-alignment': 'middle'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Path.prototype.defaults)\r\n});\r\n\r\n\r\n// PortsModelInterface is a common interface for shapes that have ports. This interface makes it easy\r\n// to create new shapes with ports functionality. It is assumed that the new shapes have\r\n// `inPorts` and `outPorts` array properties. Only these properties should be used to set ports.\r\n// In other words, using this interface, it is no longer recommended to set ports directly through the\r\n// `attrs` object.\r\n\r\n// Usage:\r\n// joint.shapes.custom.MyElementWithPorts = joint.shapes.basic.Path.extend(_.extend({}, joint.shapes.basic.PortsModelInterface, {\r\n//     getPortAttrs: function(portName, index, total, selector, type) {\r\n//         var attrs = {};\r\n//         var portClass = 'port' + index;\r\n//         var portSelector = selector + '>.' + portClass;\r\n//         var portTextSelector = portSelector + '>text';\r\n//         var portBodySelector = portSelector + '>.port-body';\r\n//\r\n//         attrs[portTextSelector] = { text: portName };\r\n//         attrs[portBodySelector] = { port: { id: portName || _.uniqueId(type) , type: type } };\r\n//         attrs[portSelector] = { ref: 'rect', 'ref-y': (index + 0.5) * (1 / total) };\r\n//\r\n//         if (selector === '.outPorts') { attrs[portSelector]['ref-dx'] = 0; }\r\n//\r\n//         return attrs;\r\n//     }\r\n//}));\r\njoint.shapes.basic.PortsModelInterface = {\r\n\r\n    initialize: function() {\r\n\r\n        this.updatePortsAttrs();\r\n        this.on('change:inPorts change:outPorts', this.updatePortsAttrs, this);\r\n\r\n        // Call the `initialize()` of the parent.\r\n        this.constructor.__super__.constructor.__super__.initialize.apply(this, arguments);\r\n    },\r\n\r\n    updatePortsAttrs: function(eventName) {\r\n\r\n        if (this._portSelectors) {\r\n\r\n            var newAttrs = _.omit(this.get('attrs'), this._portSelectors);\r\n            this.set('attrs', newAttrs, { silent: true });\r\n        }\r\n\r\n        // This holds keys to the `attrs` object for all the port specific attribute that\r\n        // we set in this method. This is necessary in order to remove previously set\r\n        // attributes for previous ports.\r\n        this._portSelectors = [];\r\n\r\n        var attrs = {};\r\n\r\n        _.each(this.get('inPorts'), function(portName, index, ports) {\r\n            var portAttributes = this.getPortAttrs(portName, index, ports.length, '.inPorts', 'in');\r\n            this._portSelectors = this._portSelectors.concat(_.keys(portAttributes));\r\n            _.extend(attrs, portAttributes);\r\n        }, this);\r\n\r\n        _.each(this.get('outPorts'), function(portName, index, ports) {\r\n            var portAttributes = this.getPortAttrs(portName, index, ports.length, '.outPorts', 'out');\r\n            this._portSelectors = this._portSelectors.concat(_.keys(portAttributes));\r\n            _.extend(attrs, portAttributes);\r\n        }, this);\r\n\r\n        // Silently set `attrs` on the cell so that noone knows the attrs have changed. This makes sure\r\n        // that, for example, command manager does not register `change:attrs` command but only\r\n        // the important `change:inPorts`/`change:outPorts` command.\r\n        this.attr(attrs, { silent: true });\r\n        // Manually call the `processPorts()` method that is normally called on `change:attrs` (that we just made silent).\r\n        this.processPorts();\r\n        // Let the outside world (mainly the `ModelView`) know that we're done configuring the `attrs` object.\r\n        this.trigger('process:ports');\r\n    },\r\n\r\n    getPortSelector: function(name) {\r\n\r\n        var selector = '.inPorts';\r\n        var index = this.get('inPorts').indexOf(name);\r\n\r\n        if (index < 0) {\r\n            selector = '.outPorts';\r\n            index = this.get('outPorts').indexOf(name);\r\n\r\n            if (index < 0) throw new Error(\"getPortSelector(): Port doesn't exist.\");\r\n        }\r\n\r\n        return selector + '>g:nth-child(' + (index + 1) + ')>.port-body';\r\n    }\r\n};\r\n\r\njoint.shapes.basic.PortsViewInterface = {\r\n\r\n    initialize: function() {\r\n\r\n        // `Model` emits the `process:ports` whenever it's done configuring the `attrs` object for ports.\r\n        this.listenTo(this.model, 'process:ports', this.update);\r\n\r\n        joint.dia.ElementView.prototype.initialize.apply(this, arguments);\r\n    },\r\n\r\n    update: function() {\r\n\r\n        // First render ports so that `attrs` can be applied to those newly created DOM elements\r\n        // in `ElementView.prototype.update()`.\r\n        this.renderPorts();\r\n        joint.dia.ElementView.prototype.update.apply(this, arguments);\r\n    },\r\n\r\n    renderPorts: function() {\r\n\r\n        var $inPorts = this.$('.inPorts').empty();\r\n        var $outPorts = this.$('.outPorts').empty();\r\n\r\n        var portTemplate = joint.util.template(this.model.portMarkup);\r\n\r\n        _.each(_.filter(this.model.ports, function(p) { return p.type === 'in'; }), function(port, index) {\r\n\r\n            $inPorts.append(V(portTemplate({ id: index, port: port })).node);\r\n        });\r\n\r\n        _.each(_.filter(this.model.ports, function(p) { return p.type === 'out'; }), function(port, index) {\r\n\r\n            $outPorts.append(V(portTemplate({ id: index, port: port })).node);\r\n        });\r\n    }\r\n};\r\n\r\njoint.shapes.basic.TextBlock = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: [\r\n        '<g class=\"rotatable\">',\r\n        '<g class=\"scalable\"><rect/></g>',\r\n        joint.env.test('svgforeignobject') ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>' : '<text class=\"content\"/>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'basic.TextBlock',\r\n\r\n        // see joint.css for more element styles\r\n        attrs: {\r\n            rect: {\r\n                fill: '#ffffff',\r\n                stroke: '#000000',\r\n                width: 80,\r\n                height: 100\r\n            },\r\n            text: {\r\n                fill: '#000000',\r\n                'font-size': 14,\r\n                'font-family': 'Arial, helvetica, sans-serif'\r\n            },\r\n            '.content': {\r\n                text: '',\r\n                'ref-x': .5,\r\n                'ref-y': .5,\r\n                'y-alignment': 'middle',\r\n                'x-alignment': 'middle'\r\n            }\r\n        },\r\n\r\n        content: ''\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults),\r\n\r\n    initialize: function() {\r\n\r\n        this.listenTo(this, 'change:size', this.updateSize);\r\n        this.listenTo(this, 'change:content', this.updateContent);\r\n        this.updateSize(this, this.get('size'));\r\n        this.updateContent(this, this.get('content'));\r\n        joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\r\n    },\r\n\r\n    updateSize: function(cell, size) {\r\n\r\n        // Selector `foreignObject' doesn't work accross all browsers, we'r using class selector instead.\r\n        // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.\r\n        this.attr({\r\n            '.fobj': _.clone(size),\r\n            div: {\r\n                style: _.clone(size)\r\n            }\r\n        });\r\n    },\r\n\r\n    updateContent: function(cell, content) {\r\n\r\n        if (joint.env.test('svgforeignobject')) {\r\n\r\n            // Content element is a <div> element.\r\n            this.attr({\r\n                '.content': {\r\n                    html: content\r\n                }\r\n            });\r\n\r\n        } else {\r\n\r\n            // Content element is a <text> element.\r\n            // SVG elements don't have innerHTML attribute.\r\n            this.attr({\r\n                '.content': {\r\n                    text: content\r\n                }\r\n            });\r\n        }\r\n    },\r\n\r\n    // Here for backwards compatibility:\r\n    setForeignObjectSize: function() {\r\n\r\n        this.updateSize.apply(this, arguments);\r\n    },\r\n\r\n    // Here for backwards compatibility:\r\n    setDivContent: function() {\r\n\r\n        this.updateContent.apply(this, arguments);\r\n    }\r\n\r\n});\r\n\r\n// TextBlockView implements the fallback for IE when no foreignObject exists and\r\n// the text needs to be manually broken.\r\njoint.shapes.basic.TextBlockView = joint.dia.ElementView.extend({\r\n\r\n    initialize: function() {\r\n\r\n        joint.dia.ElementView.prototype.initialize.apply(this, arguments);\r\n\r\n        // Keep this for backwards compatibility:\r\n        this.noSVGForeignObjectElement = !joint.env.test('svgforeignobject');\r\n\r\n        if (!joint.env.test('svgforeignobject')) {\r\n\r\n            this.listenTo(this.model, 'change:content change:size', function(cell) {\r\n                // avoiding pass of extra paramters\r\n                this.updateContent(cell);\r\n            });\r\n        }\r\n    },\r\n\r\n    update: function(cell, renderingOnlyAttrs) {\r\n\r\n        var model = this.model;\r\n\r\n        if (!joint.env.test('svgforeignobject')) {\r\n\r\n            // Update everything but the content first.\r\n            var noTextAttrs = _.omit(renderingOnlyAttrs || model.get('attrs'), '.content');\r\n            joint.dia.ElementView.prototype.update.call(this, model, noTextAttrs);\r\n\r\n            if (!renderingOnlyAttrs || _.has(renderingOnlyAttrs, '.content')) {\r\n                // Update the content itself.\r\n                this.updateContent(model, renderingOnlyAttrs);\r\n            }\r\n\r\n        } else {\r\n\r\n            joint.dia.ElementView.prototype.update.call(this, model, renderingOnlyAttrs);\r\n        }\r\n    },\r\n\r\n    updateContent: function(cell, renderingOnlyAttrs) {\r\n\r\n        // Create copy of the text attributes\r\n        var textAttrs = _.merge({}, (renderingOnlyAttrs || cell.get('attrs'))['.content']);\r\n\r\n        textAttrs = _.omit(textAttrs, 'text');\r\n\r\n        // Break the content to fit the element size taking into account the attributes\r\n        // set on the model.\r\n        var text = joint.util.breakText(cell.get('content'), cell.get('size'), textAttrs, {\r\n            // measuring sandbox svg document\r\n            svgDocument: this.paper.svg\r\n        });\r\n\r\n        // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}\r\n        var attrs = joint.util.setByPath({}, '.content', textAttrs, '/');\r\n\r\n        // Replace text attribute with the one we just processed.\r\n        attrs['.content'].text = text;\r\n\r\n        // Update the view using renderingOnlyAttributes parameter.\r\n        joint.dia.ElementView.prototype.update.call(this, cell, attrs);\r\n    }\r\n});\r\n\r\njoint.routers.manhattan = (function(g, _, joint) {\r\n\r\n    'use strict';\r\n\r\n    var config = {\r\n\r\n        // size of the step to find a route\r\n        step: 10,\r\n\r\n        // use of the perpendicular linkView option to connect center of element with first vertex\r\n        perpendicular: true,\r\n\r\n        // should be source or target not to be consider as an obstacle\r\n        excludeEnds: [], // 'source', 'target'\r\n\r\n        // should be any element with a certain type not to be consider as an obstacle\r\n        excludeTypes: ['basic.Text'],\r\n\r\n        // if number of route finding loops exceed the maximum, stops searching and returns\r\n        // fallback route\r\n        maximumLoops: 2000,\r\n\r\n        // possible starting directions from an element\r\n        startDirections: ['left', 'right', 'top', 'bottom'],\r\n\r\n        // possible ending directions to an element\r\n        endDirections: ['left', 'right', 'top', 'bottom'],\r\n\r\n        // specify directions above\r\n        directionMap: {\r\n            right: { x: 1, y: 0 },\r\n            bottom: { x: 0, y: 1 },\r\n            left: { x: -1, y: 0 },\r\n            top: { x: 0, y: -1 }\r\n        },\r\n\r\n        // maximum change of the direction\r\n        maxAllowedDirectionChange: 90,\r\n\r\n        // padding applied on the element bounding boxes\r\n        paddingBox: function() {\r\n\r\n            var step = this.step;\r\n\r\n            return {\r\n                x: -step,\r\n                y: -step,\r\n                width: 2 * step,\r\n                height: 2 * step\r\n            };\r\n        },\r\n\r\n        // an array of directions to find next points on the route\r\n        directions: function() {\r\n\r\n            var step = this.step;\r\n\r\n            return [\r\n                { offsetX: step  , offsetY: 0     , cost: step },\r\n                { offsetX: 0     , offsetY: step  , cost: step },\r\n                { offsetX: -step , offsetY: 0     , cost: step },\r\n                { offsetX: 0     , offsetY: -step , cost: step }\r\n            ];\r\n        },\r\n\r\n        // a penalty received for direction change\r\n        penalties: function() {\r\n\r\n            return {\r\n                0: 0,\r\n                45: this.step / 2,\r\n                90: this.step / 2\r\n            };\r\n        },\r\n\r\n        // * Deprecated *\r\n        // a simple route used in situations, when main routing method fails\r\n        // (exceed loops, inaccessible).\r\n        /* i.e.\r\n          function(from, to, opts) {\r\n            // Find an orthogonal route ignoring obstacles.\r\n            var point = ((opts.previousDirAngle || 0) % 180 === 0)\r\n                    ? g.point(from.x, to.y)\r\n                    : g.point(to.x, from.y);\r\n            return [point, to];\r\n          },\r\n        */\r\n        fallbackRoute: _.constant(null),\r\n\r\n        // if a function is provided, it's used to route the link while dragging an end\r\n        // i.e. function(from, to, opts) { return []; }\r\n        draggingRoute: null\r\n    };\r\n\r\n    // Map of obstacles\r\n    // Helper structure to identify whether a point lies in an obstacle.\r\n    function ObstacleMap(opt) {\r\n\r\n        this.map = {};\r\n        this.options = opt;\r\n        // tells how to divide the paper when creating the elements map\r\n        this.mapGridSize = 100;\r\n    }\r\n\r\n    ObstacleMap.prototype.build = function(graph, link) {\r\n\r\n        var opt = this.options;\r\n\r\n        // source or target element could be excluded from set of obstacles\r\n        var excludedEnds = _.chain(opt.excludeEnds)\r\n            .map(link.get, link)\r\n            .pluck('id')\r\n            .map(graph.getCell, graph).value();\r\n\r\n        // Exclude any embedded elements from the source and the target element.\r\n        var excludedAncestors = [];\r\n\r\n        var source = graph.getCell(link.get('source').id);\r\n        if (source) {\r\n            excludedAncestors = _.union(excludedAncestors, _.map(source.getAncestors(), 'id'));\r\n        }\r\n\r\n        var target = graph.getCell(link.get('target').id);\r\n        if (target) {\r\n            excludedAncestors = _.union(excludedAncestors, _.map(target.getAncestors(), 'id'));\r\n        }\r\n\r\n        // builds a map of all elements for quicker obstacle queries (i.e. is a point contained\r\n        // in any obstacle?) (a simplified grid search)\r\n        // The paper is divided to smaller cells, where each of them holds an information which\r\n        // elements belong to it. When we query whether a point is in an obstacle we don't need\r\n        // to go through all obstacles, we check only those in a particular cell.\r\n        var mapGridSize = this.mapGridSize;\r\n\r\n        _.chain(graph.getElements())\r\n            // remove source and target element if required\r\n            .difference(excludedEnds)\r\n            // remove all elements whose type is listed in excludedTypes array\r\n            .reject(function(element) {\r\n                // reject any element which is an ancestor of either source or target\r\n                return _.contains(opt.excludeTypes, element.get('type')) || _.contains(excludedAncestors, element.id);\r\n            })\r\n            // change elements (models) to their bounding boxes\r\n            .invoke('getBBox')\r\n            // expand their boxes by specific padding\r\n            .invoke('moveAndExpand', opt.paddingBox)\r\n            // build the map\r\n            .foldl(function(map, bbox) {\r\n\r\n                var origin = bbox.origin().snapToGrid(mapGridSize);\r\n                var corner = bbox.corner().snapToGrid(mapGridSize);\r\n\r\n                for (var x = origin.x; x <= corner.x; x += mapGridSize) {\r\n                    for (var y = origin.y; y <= corner.y; y += mapGridSize) {\r\n\r\n                        var gridKey = x + '@' + y;\r\n\r\n                        map[gridKey] = map[gridKey] || [];\r\n                        map[gridKey].push(bbox);\r\n                    }\r\n                }\r\n\r\n                return map;\r\n\r\n            }, this.map).value();\r\n\r\n        return this;\r\n    };\r\n\r\n    ObstacleMap.prototype.isPointAccessible = function(point) {\r\n\r\n        var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\r\n\r\n        return _.every(this.map[mapKey], function(obstacle) {\r\n            return !obstacle.containsPoint(point);\r\n        });\r\n    };\r\n\r\n    // Sorted Set\r\n    // Set of items sorted by given value.\r\n    function SortedSet() {\r\n        this.items = [];\r\n        this.hash = {};\r\n        this.values = {};\r\n        this.OPEN = 1;\r\n        this.CLOSE = 2;\r\n    }\r\n\r\n    SortedSet.prototype.add = function(item, value) {\r\n\r\n        if (this.hash[item]) {\r\n            // item removal\r\n            this.items.splice(this.items.indexOf(item), 1);\r\n        } else {\r\n            this.hash[item] = this.OPEN;\r\n        }\r\n\r\n        this.values[item] = value;\r\n\r\n        var index = _.sortedIndex(this.items, item, function(i) {\r\n            return this.values[i];\r\n        }, this);\r\n\r\n        this.items.splice(index, 0, item);\r\n    };\r\n\r\n    SortedSet.prototype.remove = function(item) {\r\n        this.hash[item] = this.CLOSE;\r\n    };\r\n\r\n    SortedSet.prototype.isOpen = function(item) {\r\n        return this.hash[item] === this.OPEN;\r\n    };\r\n\r\n    SortedSet.prototype.isClose = function(item) {\r\n        return this.hash[item] === this.CLOSE;\r\n    };\r\n\r\n    SortedSet.prototype.isEmpty = function() {\r\n        return this.items.length === 0;\r\n    };\r\n\r\n    SortedSet.prototype.pop = function() {\r\n        var item =  this.items.shift();\r\n        this.remove(item);\r\n        return item;\r\n    };\r\n\r\n    function normalizePoint(point) {\r\n        return g.point(\r\n            point.x === 0 ? 0 : Math.abs(point.x) / point.x,\r\n            point.y === 0 ? 0 : Math.abs(point.y) / point.y\r\n        );\r\n    }\r\n\r\n    // reconstructs a route by concating points with their parents\r\n    function reconstructRoute(parents, point, startCenter, endCenter) {\r\n\r\n        var route = [];\r\n        var prevDiff = normalizePoint(endCenter.difference(point));\r\n        var current = point;\r\n        var parent;\r\n\r\n        while ((parent = parents[current])) {\r\n\r\n            var diff = normalizePoint(current.difference(parent));\r\n\r\n            if (!diff.equals(prevDiff)) {\r\n\r\n                route.unshift(current);\r\n                prevDiff = diff;\r\n            }\r\n\r\n            current = parent;\r\n        }\r\n\r\n        var startDiff = normalizePoint(g.point(current).difference(startCenter));\r\n        if (!startDiff.equals(prevDiff)) {\r\n            route.unshift(current);\r\n        }\r\n\r\n        return route;\r\n    }\r\n\r\n    // find points around the rectangle taking given directions in the account\r\n    function getRectPoints(bbox, directionList, opt) {\r\n\r\n        var step = opt.step;\r\n        var center = bbox.center();\r\n        var startPoints = _.chain(opt.directionMap).pick(directionList).map(function(direction) {\r\n\r\n            var x = direction.x * bbox.width / 2;\r\n            var y = direction.y * bbox.height / 2;\r\n\r\n            var point = center.clone().offset(x, y);\r\n\r\n            if (bbox.containsPoint(point)) {\r\n\r\n                point.offset(direction.x * step, direction.y * step);\r\n            }\r\n\r\n            return point.snapToGrid(step);\r\n\r\n        }).value();\r\n\r\n        return startPoints;\r\n    }\r\n\r\n    // returns a direction index from start point to end point\r\n    function getDirectionAngle(start, end, dirLen) {\r\n\r\n        var q = 360 / dirLen;\r\n        return Math.floor(g.normalizeAngle(start.theta(end) + q / 2) / q) * q;\r\n    }\r\n\r\n    function getDirectionChange(angle1, angle2) {\r\n\r\n        var dirChange = Math.abs(angle1 - angle2);\r\n        return dirChange > 180 ? 360 - dirChange : dirChange;\r\n    }\r\n\r\n    // heurestic method to determine the distance between two points\r\n    function estimateCost(from, endPoints) {\r\n\r\n        var min = Infinity;\r\n\r\n        for (var i = 0, len = endPoints.length; i < len; i++) {\r\n            var cost = from.manhattanDistance(endPoints[i]);\r\n            if (cost < min) min = cost;\r\n        }\r\n\r\n        return min;\r\n    }\r\n\r\n    // finds the route between to points/rectangles implementing A* alghoritm\r\n    function findRoute(start, end, map, opt) {\r\n\r\n        var step = opt.step;\r\n        var startPoints, endPoints;\r\n        var startCenter, endCenter;\r\n\r\n        // set of points we start pathfinding from\r\n        if (start instanceof g.rect) {\r\n            startPoints = getRectPoints(start, opt.startDirections, opt);\r\n            startCenter = start.center().snapToGrid(step);\r\n        } else {\r\n            startCenter = start.clone().snapToGrid(step);\r\n            startPoints = [startCenter];\r\n        }\r\n\r\n        // set of points we want the pathfinding to finish at\r\n        if (end instanceof g.rect) {\r\n            endPoints = getRectPoints(end, opt.endDirections, opt);\r\n            endCenter = end.center().snapToGrid(step);\r\n        } else {\r\n            endCenter = end.clone().snapToGrid(step);\r\n            endPoints = [endCenter];\r\n        }\r\n\r\n        // take into account only accessible end points\r\n        startPoints = _.filter(startPoints, map.isPointAccessible, map);\r\n        endPoints = _.filter(endPoints, map.isPointAccessible, map);\r\n\r\n        // Check if there is a accessible end point.\r\n        // We would have to use a fallback route otherwise.\r\n        if (startPoints.length > 0 && endPoints.length >  0) {\r\n\r\n            // The set of tentative points to be evaluated, initially containing the start points.\r\n            var openSet = new SortedSet();\r\n            // Keeps reference to a point that is immediate predecessor of given element.\r\n            var parents = {};\r\n            // Cost from start to a point along best known path.\r\n            var costs = {};\r\n\r\n            _.each(startPoints, function(point) {\r\n                var key = point.toString();\r\n                openSet.add(key, estimateCost(point, endPoints));\r\n                costs[key] = 0;\r\n            });\r\n\r\n            // directions\r\n            var dir, dirChange;\r\n            var dirs = opt.directions;\r\n            var dirLen = dirs.length;\r\n            var loopsRemain = opt.maximumLoops;\r\n            var endPointsKeys = _.invoke(endPoints, 'toString');\r\n\r\n            // main route finding loop\r\n            while (!openSet.isEmpty() && loopsRemain > 0) {\r\n\r\n                // remove current from the open list\r\n                var currentKey = openSet.pop();\r\n                var currentPoint = g.point(currentKey);\r\n                var currentDist = costs[currentKey];\r\n                var previousDirAngle = currentDirAngle;\r\n                var currentDirAngle = parents[currentKey]\r\n                    ? getDirectionAngle(parents[currentKey], currentPoint, dirLen)\r\n                    : opt.previousDirAngle != null ? opt.previousDirAngle : getDirectionAngle(startCenter, currentPoint, dirLen);\r\n\r\n                // Check if we reached any endpoint\r\n                if (endPointsKeys.indexOf(currentKey) >= 0) {\r\n                    // We don't want to allow route to enter the end point in opposite direction.\r\n                    dirChange = getDirectionChange(currentDirAngle, getDirectionAngle(currentPoint, endCenter, dirLen));\r\n                    if (currentPoint.equals(endCenter) || dirChange < 180) {\r\n                        opt.previousDirAngle = currentDirAngle;\r\n                        return reconstructRoute(parents, currentPoint, startCenter, endCenter);\r\n                    }\r\n                }\r\n\r\n                // Go over all possible directions and find neighbors.\r\n                for (var i = 0; i < dirLen; i++) {\r\n\r\n                    dir = dirs[i];\r\n                    dirChange = getDirectionChange(currentDirAngle, dir.angle);\r\n                    // if the direction changed rapidly don't use this point\r\n                    // Note that check is relevant only for points with previousDirAngle i.e.\r\n                    // any direction is allowed for starting points\r\n                    if (previousDirAngle && dirChange > opt.maxAllowedDirectionChange) {\r\n                        continue;\r\n                    }\r\n\r\n                    var neighborPoint = currentPoint.clone().offset(dir.offsetX, dir.offsetY);\r\n                    var neighborKey = neighborPoint.toString();\r\n                    // Closed points from the openSet were already evaluated.\r\n                    if (openSet.isClose(neighborKey) || !map.isPointAccessible(neighborPoint)) {\r\n                        continue;\r\n                    }\r\n\r\n                    // The current direction is ok to proccess.\r\n                    var costFromStart = currentDist + dir.cost + opt.penalties[dirChange];\r\n\r\n                    if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\r\n                        // neighbor point has not been processed yet or the cost of the path\r\n                        // from start is lesser than previously calcluated.\r\n                        parents[neighborKey] = currentPoint;\r\n                        costs[neighborKey] = costFromStart;\r\n                        openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\r\n                    }\r\n                }\r\n\r\n                loopsRemain--;\r\n            }\r\n        }\r\n\r\n        // no route found ('to' point wasn't either accessible or finding route took\r\n        // way to much calculations)\r\n        return opt.fallbackRoute(startCenter, endCenter, opt);\r\n    }\r\n\r\n    // resolve some of the options\r\n    function resolveOptions(opt) {\r\n\r\n        opt.directions = _.result(opt, 'directions');\r\n        opt.penalties = _.result(opt, 'penalties');\r\n        opt.paddingBox = _.result(opt, 'paddingBox');\r\n\r\n        _.each(opt.directions, function(direction) {\r\n\r\n            var point1 = g.point(0, 0);\r\n            var point2 = g.point(direction.offsetX, direction.offsetY);\r\n\r\n            direction.angle = g.normalizeAngle(point1.theta(point2));\r\n        });\r\n    }\r\n\r\n    // initiation of the route finding\r\n    function router(vertices, opt) {\r\n\r\n        resolveOptions(opt);\r\n\r\n        // enable/disable linkView perpendicular option\r\n        this.options.perpendicular = !!opt.perpendicular;\r\n\r\n        // expand boxes by specific padding\r\n        var sourceBBox = g.rect(this.sourceBBox).moveAndExpand(opt.paddingBox);\r\n        var targetBBox = g.rect(this.targetBBox).moveAndExpand(opt.paddingBox);\r\n\r\n        // pathfinding\r\n        var map = (new ObstacleMap(opt)).build(this.paper.model, this.model);\r\n        var oldVertices = _.map(vertices, g.point);\r\n        var newVertices = [];\r\n        var tailPoint = sourceBBox.center().snapToGrid(opt.step);\r\n\r\n        // find a route by concating all partial routes (routes need to go through the vertices)\r\n        // startElement -> vertex[1] -> ... -> vertex[n] -> endElement\r\n        for (var i = 0, len = oldVertices.length; i <= len; i++) {\r\n\r\n            var partialRoute = null;\r\n\r\n            var from = to || sourceBBox;\r\n            var to = oldVertices[i];\r\n\r\n            if (!to) {\r\n\r\n                to = targetBBox;\r\n\r\n                // 'to' is not a vertex. If the target is a point (i.e. it's not an element), we\r\n                // might use dragging route instead of main routing method if that is enabled.\r\n                var endingAtPoint = !this.model.get('source').id || !this.model.get('target').id;\r\n\r\n                if (endingAtPoint && _.isFunction(opt.draggingRoute)) {\r\n                    // Make sure we passing points only (not rects).\r\n                    var dragFrom = from instanceof g.rect ? from.center() : from;\r\n                    partialRoute = opt.draggingRoute(dragFrom, to.origin(), opt);\r\n                }\r\n            }\r\n\r\n            // if partial route has not been calculated yet use the main routing method to find one\r\n            partialRoute = partialRoute || findRoute(from, to, map, opt);\r\n\r\n            if (partialRoute === null) {\r\n                // The partial route could not be found.\r\n                // use orthogonal (do not avoid elements) route instead.\r\n                if (!_.isFunction(joint.routers.orthogonal)) {\r\n                    throw new Error('Manhattan requires the orthogonal router.');\r\n                }\r\n                return joint.routers.orthogonal(vertices, opt, this);\r\n            }\r\n\r\n            var leadPoint = _.first(partialRoute);\r\n\r\n            if (leadPoint && leadPoint.equals(tailPoint)) {\r\n                // remove the first point if the previous partial route had the same point as last\r\n                partialRoute.shift();\r\n            }\r\n\r\n            tailPoint = _.last(partialRoute) || tailPoint;\r\n\r\n            Array.prototype.push.apply(newVertices, partialRoute);\r\n        }\r\n\r\n        return newVertices;\r\n    }\r\n\r\n    // public function\r\n    return function(vertices, opt, linkView) {\r\n\r\n        return router.call(linkView, vertices, _.extend({}, config, opt));\r\n    };\r\n\r\n})(g, _, joint);\r\n\r\njoint.routers.metro = (function() {\r\n\r\n    if (!_.isFunction(joint.routers.manhattan)) {\r\n\r\n        throw new Error('Metro requires the manhattan router.');\r\n    }\r\n\r\n    var config = {\r\n\r\n        // cost of a diagonal step (calculated if not defined).\r\n        diagonalCost: null,\r\n\r\n        // an array of directions to find next points on the route\r\n        directions: function() {\r\n\r\n            var step = this.step;\r\n            var diagonalCost = this.diagonalCost || Math.ceil(Math.sqrt(step * step << 1));\r\n\r\n            return [\r\n                { offsetX: step  , offsetY: 0     , cost: step },\r\n                { offsetX: step  , offsetY: step  , cost: diagonalCost },\r\n                { offsetX: 0     , offsetY: step  , cost: step },\r\n                { offsetX: -step , offsetY: step  , cost: diagonalCost },\r\n                { offsetX: -step , offsetY: 0     , cost: step },\r\n                { offsetX: -step , offsetY: -step , cost: diagonalCost },\r\n                { offsetX: 0     , offsetY: -step , cost: step },\r\n                { offsetX: step  , offsetY: -step , cost: diagonalCost }\r\n            ];\r\n        },\r\n        maxAllowedDirectionChange: 45,\r\n        // a simple route used in situations, when main routing method fails\r\n        // (exceed loops, inaccessible).\r\n        fallbackRoute: function(from, to, opts) {\r\n\r\n            // Find a route which breaks by 45 degrees ignoring all obstacles.\r\n\r\n            var theta = from.theta(to);\r\n\r\n            var a = { x: to.x, y: from.y };\r\n            var b = { x: from.x, y: to.y };\r\n\r\n            if (theta % 180 > 90) {\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n\r\n            var p1 = (theta % 90) < 45 ? a : b;\r\n\r\n            var l1 = g.line(from, p1);\r\n\r\n            var alpha = 90 * Math.ceil(theta / 90);\r\n\r\n            var p2 = g.point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\r\n\r\n            var l2 = g.line(to, p2);\r\n\r\n            var point = l1.intersection(l2);\r\n\r\n            return point ? [point.round(), to] : [to];\r\n        }\r\n    };\r\n\r\n    // public function\r\n    return function(vertices, opts, linkView) {\r\n\r\n        return joint.routers.manhattan(vertices, _.extend({}, config, opts), linkView);\r\n    };\r\n\r\n})();\r\n\r\n// Does not make any changes to vertices.\r\n// Returns the arguments that are passed to it, unchanged.\r\njoint.routers.normal = function(vertices, opt, linkView) {\r\n\r\n    return vertices;\r\n};\r\n\r\n// Routes the link always to/from a certain side\r\n//\r\n// Arguments:\r\n//   padding ... gap between the element and the first vertex. :: Default 40.\r\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\r\n//\r\njoint.routers.oneSide = function(vertices, opt, linkView) {\r\n\r\n    var side = opt.side || 'bottom';\r\n    var padding = opt.padding || 40;\r\n\r\n    // LinkView contains cached source an target bboxes.\r\n    // Note that those are Geometry rectangle objects.\r\n    var sourceBBox = linkView.sourceBBox;\r\n    var targetBBox = linkView.targetBBox;\r\n    var sourcePoint = sourceBBox.center();\r\n    var targetPoint = targetBBox.center();\r\n\r\n    var coordinate, dimension, direction;\r\n\r\n    switch (side) {\r\n        case 'bottom':\r\n            direction = 1;\r\n            coordinate = 'y';\r\n            dimension = 'height';\r\n            break;\r\n        case 'top':\r\n            direction = -1;\r\n            coordinate = 'y';\r\n            dimension = 'height';\r\n            break;\r\n        case 'left':\r\n            direction = -1;\r\n            coordinate = 'x';\r\n            dimension = 'width';\r\n            break;\r\n        case 'right':\r\n            direction = 1;\r\n            coordinate = 'x';\r\n            dimension = 'width';\r\n            break;\r\n        default:\r\n            throw new Error('Router: invalid side');\r\n    }\r\n\r\n    // move the points from the center of the element to outside of it.\r\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding);\r\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding);\r\n\r\n    // make link orthogonal (at least the first and last vertex).\r\n    if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\r\n        targetPoint[coordinate] = sourcePoint[coordinate];\r\n    } else {\r\n        sourcePoint[coordinate] = targetPoint[coordinate];\r\n    }\r\n\r\n    return [sourcePoint].concat(vertices, targetPoint);\r\n};\r\n\r\njoint.routers.orthogonal = (function() {\r\n\r\n    // bearing -> opposite bearing\r\n    var opposite = {\r\n        N: 'S',\r\n        S: 'N',\r\n        E: 'W',\r\n        W: 'E'\r\n    };\r\n\r\n    // bearing -> radians\r\n    var radians = {\r\n        N: -Math.PI / 2 * 3,\r\n        S: -Math.PI / 2,\r\n        E: 0,\r\n        W: Math.PI\r\n    };\r\n\r\n    // HELPERS //\r\n\r\n    // simple bearing method (calculates only orthogonal cardinals)\r\n    function bearing(from, to) {\r\n        if (from.x == to.x) return from.y > to.y ? 'N' : 'S';\r\n        if (from.y == to.y) return from.x > to.x ? 'W' : 'E';\r\n        return null;\r\n    }\r\n\r\n    // returns either width or height of a bbox based on the given bearing\r\n    function boxSize(bbox, brng) {\r\n        return bbox[brng == 'W' || brng == 'E' ? 'width' : 'height'];\r\n    }\r\n\r\n    // expands a box by specific value\r\n    function expand(bbox, val) {\r\n        return g.rect(bbox).moveAndExpand({ x: -val, y: -val, width: 2 * val, height: 2 * val });\r\n    }\r\n\r\n    // transform point to a rect\r\n    function pointBox(p) {\r\n        return g.rect(p.x, p.y, 0, 0);\r\n    }\r\n\r\n    // returns a minimal rect which covers the given boxes\r\n    function boundary(bbox1, bbox2) {\r\n\r\n        var x1 = Math.min(bbox1.x, bbox2.x);\r\n        var y1 = Math.min(bbox1.y, bbox2.y);\r\n        var x2 = Math.max(bbox1.x + bbox1.width, bbox2.x + bbox2.width);\r\n        var y2 = Math.max(bbox1.y + bbox1.height, bbox2.y + bbox2.height);\r\n\r\n        return g.rect(x1, y1, x2 - x1, y2 - y1);\r\n    }\r\n\r\n    // returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\r\n    // in the given box\r\n    function freeJoin(p1, p2, bbox) {\r\n\r\n        var p = g.point(p1.x, p2.y);\r\n        if (bbox.containsPoint(p)) p = g.point(p2.x, p1.y);\r\n        // kept for reference\r\n        // if (bbox.containsPoint(p)) p = null;\r\n        return p;\r\n    }\r\n\r\n    // PARTIAL ROUTERS //\r\n\r\n    function vertexVertex(from, to, brng) {\r\n\r\n        var p1 = g.point(from.x, to.y);\r\n        var p2 = g.point(to.x, from.y);\r\n        var d1 = bearing(from, p1);\r\n        var d2 = bearing(from, p2);\r\n        var xBrng = opposite[brng];\r\n\r\n        var p = (d1 == brng || (d1 != xBrng && (d2 == xBrng || d2 != brng))) ? p1 : p2;\r\n\r\n        return { points: [p], direction: bearing(p, to) };\r\n    }\r\n\r\n    function elementVertex(from, to, fromBBox) {\r\n\r\n        var p = freeJoin(from, to, fromBBox);\r\n\r\n        return { points: [p], direction: bearing(p, to) };\r\n    }\r\n\r\n    function vertexElement(from, to, toBBox, brng) {\r\n\r\n        var route = {};\r\n\r\n        var pts = [g.point(from.x, to.y), g.point(to.x, from.y)];\r\n        var freePts = _.filter(pts, function(pt) { return !toBBox.containsPoint(pt); });\r\n        var freeBrngPts = _.filter(freePts, function(pt) { return bearing(pt, from) != brng; });\r\n\r\n        var p;\r\n\r\n        if (freeBrngPts.length > 0) {\r\n\r\n            // try to pick a point which bears the same direction as the previous segment\r\n            p = _.filter(freeBrngPts, function(pt) { return bearing(from, pt) == brng; }).pop();\r\n            p = p || freeBrngPts[0];\r\n\r\n            route.points = [p];\r\n            route.direction = bearing(p, to);\r\n\r\n        } else {\r\n\r\n            // Here we found only points which are either contained in the element or they would create\r\n            // a link segment going in opposite direction from the previous one.\r\n            // We take the point inside element and move it outside the element in the direction the\r\n            // route is going. Now we can join this point with the current end (using freeJoin).\r\n\r\n            p = _.difference(pts, freePts)[0];\r\n\r\n            var p2 = g.point(to).move(p, -boxSize(toBBox, brng) / 2);\r\n            var p1 = freeJoin(p2, from, toBBox);\r\n\r\n            route.points = [p1, p2];\r\n            route.direction = bearing(p2, to);\r\n        }\r\n\r\n        return route;\r\n    }\r\n\r\n    function elementElement(from, to, fromBBox, toBBox) {\r\n\r\n        var route = elementVertex(to, from, toBBox);\r\n        var p1 = route.points[0];\r\n\r\n        if (fromBBox.containsPoint(p1)) {\r\n\r\n            route = elementVertex(from, to, fromBBox);\r\n            var p2 = route.points[0];\r\n\r\n            if (toBBox.containsPoint(p2)) {\r\n\r\n                var fromBorder = g.point(from).move(p2, -boxSize(fromBBox, bearing(from, p2)) / 2);\r\n                var toBorder = g.point(to).move(p1, -boxSize(toBBox, bearing(to, p1)) / 2);\r\n                var mid = g.line(fromBorder, toBorder).midpoint();\r\n\r\n                var startRoute = elementVertex(from, mid, fromBBox);\r\n                var endRoute = vertexVertex(mid, to, startRoute.direction);\r\n\r\n                route.points = [startRoute.points[0], endRoute.points[0]];\r\n                route.direction = endRoute.direction;\r\n            }\r\n        }\r\n\r\n        return route;\r\n    }\r\n\r\n    // Finds route for situations where one of end is inside the other.\r\n    // Typically the route is conduct outside the outer element first and\r\n    // let go back to the inner element.\r\n    function insideElement(from, to, fromBBox, toBBox, brng) {\r\n\r\n        var route = {};\r\n        var bndry = expand(boundary(fromBBox, toBBox), 1);\r\n\r\n        // start from the point which is closer to the boundary\r\n        var reversed = bndry.center().distance(to) > bndry.center().distance(from);\r\n        var start = reversed ? to : from;\r\n        var end = reversed ? from : to;\r\n\r\n        var p1, p2, p3;\r\n\r\n        if (brng) {\r\n            // Points on circle with radius equals 'W + H` are always outside the rectangle\r\n            // with width W and height H if the center of that circle is the center of that rectangle.\r\n            p1 = g.point.fromPolar(bndry.width + bndry.height, radians[brng], start);\r\n            p1 = bndry.pointNearestToPoint(p1).move(p1, -1);\r\n        } else {\r\n            p1 = bndry.pointNearestToPoint(start).move(start, 1);\r\n        }\r\n\r\n        p2 = freeJoin(p1, end, bndry);\r\n\r\n        if (p1.round().equals(p2.round())) {\r\n            p2 = g.point.fromPolar(bndry.width + bndry.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\r\n            p2 = bndry.pointNearestToPoint(p2).move(end, 1).round();\r\n            p3 = freeJoin(p1, p2, bndry);\r\n            route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\r\n        } else {\r\n            route.points = reversed ? [p2, p1] : [p1, p2];\r\n        }\r\n\r\n        route.direction = reversed ? bearing(p1, to) : bearing(p2, to);\r\n\r\n        return route;\r\n    }\r\n\r\n    // MAIN ROUTER //\r\n\r\n    // Return points that one needs to draw a connection through in order to have a orthogonal link\r\n    // routing from source to target going through `vertices`.\r\n    function findOrthogonalRoute(vertices, opt, linkView) {\r\n\r\n        var padding = opt.elementPadding || 20;\r\n\r\n        var orthogonalVertices = [];\r\n        var sourceBBox = expand(linkView.sourceBBox, padding);\r\n        var targetBBox = expand(linkView.targetBBox, padding);\r\n\r\n        vertices = _.map(vertices, g.point);\r\n        vertices.unshift(sourceBBox.center());\r\n        vertices.push(targetBBox.center());\r\n\r\n        var brng;\r\n\r\n        for (var i = 0, max = vertices.length - 1; i < max; i++) {\r\n\r\n            var route = null;\r\n            var from = vertices[i];\r\n            var to = vertices[i + 1];\r\n            var isOrthogonal = !!bearing(from, to);\r\n\r\n            if (i == 0) {\r\n\r\n                if (i + 1 == max) { // route source -> target\r\n\r\n                    // Expand one of elements by 1px so we detect also situations when they\r\n                    // are positioned one next other with no gap between.\r\n                    if (sourceBBox.intersect(expand(targetBBox, 1))) {\r\n                        route = insideElement(from, to, sourceBBox, targetBBox);\r\n                    } else if (!isOrthogonal) {\r\n                        route = elementElement(from, to, sourceBBox, targetBBox);\r\n                    }\r\n\r\n                } else { // route source -> vertex\r\n\r\n                    if (sourceBBox.containsPoint(to)) {\r\n                        route = insideElement(from, to, sourceBBox, expand(pointBox(to), padding));\r\n                    } else if (!isOrthogonal) {\r\n                        route = elementVertex(from, to, sourceBBox);\r\n                    }\r\n                }\r\n\r\n            } else if (i + 1 == max) { // route vertex -> target\r\n\r\n                var orthogonalLoop = isOrthogonal && bearing(to, from) == brng;\r\n\r\n                if (targetBBox.containsPoint(from) || orthogonalLoop) {\r\n                    route = insideElement(from, to, expand(pointBox(from), padding), targetBBox, brng);\r\n                } else if (!isOrthogonal) {\r\n                    route = vertexElement(from, to, targetBBox, brng);\r\n                }\r\n\r\n            } else if (!isOrthogonal) { // route vertex -> vertex\r\n                route = vertexVertex(from, to, brng);\r\n            }\r\n\r\n            if (route) {\r\n                Array.prototype.push.apply(orthogonalVertices, route.points);\r\n                brng = route.direction;\r\n            } else {\r\n                // orthogonal route and not looped\r\n                brng = bearing(from, to);\r\n            }\r\n\r\n            if (i + 1 < max) {\r\n                orthogonalVertices.push(to);\r\n            }\r\n        }\r\n\r\n        return orthogonalVertices;\r\n    }\r\n\r\n    return findOrthogonalRoute;\r\n\r\n})();\r\n\r\njoint.connectors.normal = function(sourcePoint, targetPoint, vertices) {\r\n\r\n    // Construct the `d` attribute of the `<path>` element.\r\n    var d = ['M', sourcePoint.x, sourcePoint.y];\r\n\r\n    _.each(vertices, function(vertex) {\r\n\r\n        d.push(vertex.x, vertex.y);\r\n    });\r\n\r\n    d.push(targetPoint.x, targetPoint.y);\r\n\r\n    return d.join(' ');\r\n};\r\n\r\njoint.connectors.rounded = function(sourcePoint, targetPoint, vertices, opts) {\r\n\r\n    opts = opts || {};\r\n\r\n    var offset = opts.radius || 10;\r\n\r\n    var c1, c2, d1, d2, prev, next;\r\n\r\n    // Construct the `d` attribute of the `<path>` element.\r\n    var d = ['M', sourcePoint.x, sourcePoint.y];\r\n\r\n    _.each(vertices, function(vertex, index) {\r\n\r\n        // the closest vertices\r\n        prev = vertices[index - 1] || sourcePoint;\r\n        next = vertices[index + 1] || targetPoint;\r\n\r\n        // a half distance to the closest vertex\r\n        d1 = d2 || g.point(vertex).distance(prev) / 2;\r\n        d2 = g.point(vertex).distance(next) / 2;\r\n\r\n        // control points\r\n        c1 = g.point(vertex).move(prev, -Math.min(offset, d1)).round();\r\n        c2 = g.point(vertex).move(next, -Math.min(offset, d2)).round();\r\n\r\n        d.push(c1.x, c1.y, 'S', vertex.x, vertex.y, c2.x, c2.y, 'L');\r\n    });\r\n\r\n    d.push(targetPoint.x, targetPoint.y);\r\n\r\n    return d.join(' ');\r\n};\r\n\r\njoint.connectors.smooth = function(sourcePoint, targetPoint, vertices) {\r\n\r\n    var d;\r\n\r\n    if (vertices.length) {\r\n\r\n        d = g.bezier.curveThroughPoints([sourcePoint].concat(vertices).concat([targetPoint]));\r\n\r\n    } else {\r\n        // if we have no vertices use a default cubic bezier curve, cubic bezier requires\r\n        // two control points. The two control points are both defined with X as mid way\r\n        // between the source and target points. SourceControlPoint Y is equal to sourcePoint Y\r\n        // and targetControlPointY being equal to targetPointY.\r\n        var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\r\n\r\n        d = [\r\n            'M', sourcePoint.x, sourcePoint.y,\r\n            'C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y,\r\n            targetPoint.x, targetPoint.y\r\n        ];\r\n    }\r\n\r\n    return d.join(' ');\r\n};\r\n\r\njoint.connectors.jumpover = (function(_, g) {\r\n\r\n    // default size of jump if not specified in options\r\n    var JUMP_SIZE = 5;\r\n\r\n    // available jump types\r\n    var JUMP_TYPES = ['arc', 'gap', 'cubic'];\r\n\r\n    // takes care of math. error for case when jump is too close to end of line\r\n    var CLOSE_PROXIMITY_PADDING = 1;\r\n\r\n    // list of connector types not to jump over.\r\n    var IGNORED_CONNECTORS = ['smooth'];\r\n\r\n    /**\r\n     * Transform start/end and vertices into series of lines\r\n     * @param {g.point} sourcePoint start point\r\n     * @param {g.point} targetPoint end point\r\n     * @param {g.point[]} vertices optional list of vertices\r\n     * @return {g.line[]} [description]\r\n     */\r\n    function createLines(sourcePoint, targetPoint, vertices) {\r\n        // make a flattened array of all points\r\n        var points = [].concat(sourcePoint, vertices, targetPoint);\r\n        return points.reduce(function(resultLines, point, idx) {\r\n            // if there is a next point, make a line with it\r\n            var nextPoint = points[idx + 1];\r\n            if (nextPoint != null) {\r\n                resultLines[idx] = g.line(point, nextPoint);\r\n            }\r\n            return resultLines;\r\n        }, []);\r\n    }\r\n\r\n    function setupUpdating(jumpOverLinkView) {\r\n        var updateList = jumpOverLinkView.paper._jumpOverUpdateList;\r\n\r\n        // first time setup for this paper\r\n        if (updateList == null) {\r\n            updateList = jumpOverLinkView.paper._jumpOverUpdateList = [];\r\n            jumpOverLinkView.paper.on('cell:pointerup', updateJumpOver);\r\n            jumpOverLinkView.paper.model.on('reset', function() {\r\n                updateList = jumpOverLinkView.paper._jumpOverUpdateList = [];\r\n            });\r\n        }\r\n\r\n        // add this link to a list so it can be updated when some other link is updated\r\n        if (updateList.indexOf(jumpOverLinkView) < 0) {\r\n            updateList.push(jumpOverLinkView);\r\n\r\n            // watch for change of connector type or removal of link itself\r\n            // to remove the link from a list of jump over connectors\r\n            jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\r\n                updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handler for a batch:stop event to force\r\n     * update of all registered links with jump over connector\r\n     * @param {object} batchEvent optional object with info about batch\r\n     */\r\n    function updateJumpOver() {\r\n        var updateList = this._jumpOverUpdateList;\r\n        for (var i = 0; i < updateList.length; i++) {\r\n            updateList[i].update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility function to collect all intersection poinst of a single\r\n     * line against group of other lines.\r\n     * @param {g.line} line where to find points\r\n     * @param {g.line[]} crossCheckLines lines to cross\r\n     * @return {g.point[]} list of intersection points\r\n     */\r\n    function findLineIntersections(line, crossCheckLines) {\r\n        return _(crossCheckLines).map(function(crossCheckLine) {\r\n            return line.intersection(crossCheckLine);\r\n        }).compact().value();\r\n    }\r\n\r\n    /**\r\n     * Sorting function for list of points by their distance.\r\n     * @param {g.point} p1 first point\r\n     * @param {g.point} p2 second point\r\n     * @return {number} squared distance between points\r\n     */\r\n    function sortPoints(p1, p2) {\r\n        return g.line(p1, p2).squaredLength();\r\n    }\r\n\r\n    /**\r\n     * Split input line into multiple based on intersection points.\r\n     * @param {g.line} line input line to split\r\n     * @param {g.point[]} intersections poinst where to split the line\r\n     * @param {number} jumpSize the size of jump arc (length empty spot on a line)\r\n     * @return {g.line[]} list of lines being split\r\n     */\r\n    function createJumps(line, intersections, jumpSize) {\r\n        return intersections.reduce(function(resultLines, point, idx) {\r\n            // skipping points that were merged with the previous line\r\n            // to make bigger arc over multiple lines that are close to each other\r\n            if (point.skip === true) {\r\n                return resultLines;\r\n            }\r\n\r\n            // always grab the last line from buffer and modify it\r\n            var lastLine = resultLines.pop() || line;\r\n\r\n            // calculate start and end of jump by moving by a given size of jump\r\n            var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\r\n            var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\r\n\r\n            // now try to look at the next intersection point\r\n            var nextPoint = intersections[idx + 1];\r\n            if (nextPoint != null) {\r\n                var distance = jumpEnd.distance(nextPoint);\r\n                if (distance <= jumpSize) {\r\n                    // next point is close enough, move the jump end by this\r\n                    // difference and mark the next point to be skipped\r\n                    jumpEnd = nextPoint.move(lastLine.start, distance);\r\n                    nextPoint.skip = true;\r\n                }\r\n            } else {\r\n                // this block is inside of `else` as an optimization so the distance is\r\n                // not calculated when we know there are no other intersection points\r\n                var endDistance = jumpStart.distance(lastLine.end);\r\n                // if the end is too close to possible jump, draw remaining line instead of a jump\r\n                if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\r\n                    resultLines.push(lastLine);\r\n                    return resultLines;\r\n                }\r\n            }\r\n\r\n            var startDistance = jumpEnd.distance(lastLine.start);\r\n            if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\r\n                // if the start of line is too close to jump, draw that line instead of a jump\r\n                resultLines.push(lastLine);\r\n                return resultLines;\r\n            }\r\n\r\n            // finally create a jump line\r\n            var jumpLine = g.line(jumpStart, jumpEnd);\r\n            // it's just simple line but with a `isJump` property\r\n            jumpLine.isJump = true;\r\n\r\n            resultLines.push(\r\n                g.line(lastLine.start, jumpStart),\r\n                jumpLine,\r\n                g.line(jumpEnd, lastLine.end)\r\n            );\r\n            return resultLines;\r\n        }, []);\r\n    }\r\n\r\n    /**\r\n     * Assemble `D` attribute of a SVG path by iterating given lines.\r\n     * @param {g.line[]} lines source lines to use\r\n     * @param {number} jumpSize the size of jump arc (length empty spot on a line)\r\n     * @return {string}\r\n     */\r\n    function buildPath(lines, jumpSize, jumpType) {\r\n        // first move to the start of a first line\r\n        var start = ['M', lines[0].start.x, lines[0].start.y];\r\n\r\n        // make a paths from lines\r\n        var paths = _(lines).map(function(line) {\r\n            if (line.isJump) {\r\n                var diff;\r\n                if (jumpType === 'arc') {\r\n                    diff = line.start.difference(line.end);\r\n                    // determine rotation of arc based on difference between points\r\n                    var xAxisRotate = Number(diff.x < 0 && diff.y < 0);\r\n                    // for a jump line we create an arc instead\r\n                    return ['A', jumpSize, jumpSize, 0, 0, xAxisRotate, line.end.x, line.end.y];\r\n                } else if (jumpType === 'gap') {\r\n                    return ['M', line.end.x, line.end.y];\r\n                } else if (jumpType === 'cubic') {\r\n                    diff = line.start.difference(line.end);\r\n                    var angle = line.start.theta(line.end);\r\n                    var xOffset = jumpSize * 0.6;\r\n                    var yOffset = jumpSize * 1.35;\r\n                    // determine rotation of curve based on difference between points\r\n                    if (diff.x < 0 && diff.y < 0) {\r\n                        yOffset *= -1;\r\n                    }\r\n                    var controlStartPoint = g.point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\r\n                    var controlEndPoint = g.point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\r\n                    // create a cubic bezier curve\r\n                    return ['C', controlStartPoint.x, controlStartPoint.y, controlEndPoint.x, controlEndPoint.y, line.end.x, line.end.y];\r\n                }\r\n            }\r\n            return ['L', line.end.x, line.end.y];\r\n        }).flatten().value();\r\n\r\n        return [].concat(start, paths).join(' ');\r\n    }\r\n\r\n    /**\r\n     * Actual connector function that will be run on every update.\r\n     * @param {g.point} sourcePoint start point of this link\r\n     * @param {g.point} targetPoint end point of this link\r\n     * @param {g.point[]} vertices of this link\r\n     * @param {object} opts options\r\n     * @property {number} size optional size of a jump arc\r\n     * @return {string} created `D` attribute of SVG path\r\n     */\r\n    return function(sourcePoint, targetPoint, vertices, opts) { // eslint-disable-line max-params\r\n\r\n        setupUpdating(this);\r\n\r\n        var jumpSize = opts.size || JUMP_SIZE;\r\n        var jumpType = opts.jump && ('' + opts.jump).toLowerCase();\r\n        var ignoreConnectors = opts.ignoreConnectors || IGNORED_CONNECTORS;\r\n\r\n        // grab the first jump type as a default if specified one is invalid\r\n        if (JUMP_TYPES.indexOf(jumpType) === -1) {\r\n            jumpType = JUMP_TYPES[0];\r\n        }\r\n\r\n        var paper = this.paper;\r\n        var graph = paper.model;\r\n        var allLinks = graph.getLinks();\r\n\r\n        // there is just one link, draw it directly\r\n        if (allLinks.length === 1) {\r\n            return buildPath(\r\n                createLines(sourcePoint, targetPoint, vertices),\r\n                jumpSize, jumpType\r\n            );\r\n        }\r\n\r\n        var thisModel = this.model;\r\n        var thisIndex = allLinks.indexOf(thisModel);\r\n        var defaultConnector = paper.options.defaultConnector || {};\r\n\r\n        // not all links are meant to be jumped over.\r\n        var links = allLinks.filter(function(link, idx) {\r\n\r\n            var connector = link.get('connector') || defaultConnector;\r\n\r\n            // avoid jumping over links with connector type listed in `ignored connectors`.\r\n            if (_.contains(ignoreConnectors, connector.name)) {\r\n                return false;\r\n            }\r\n            // filter out links that are above this one and  have the same connector type\r\n            // otherwise there would double hoops for each intersection\r\n            if (idx > thisIndex) {\r\n                return connector.name !== 'jumpover';\r\n            }\r\n            return true;\r\n        });\r\n\r\n        // find views for all links\r\n        var linkViews = links.map(function(link) {\r\n            return paper.findViewByModel(link);\r\n        });\r\n\r\n        // create lines for this link\r\n        var thisLines = createLines(\r\n            sourcePoint,\r\n            targetPoint,\r\n            vertices\r\n        );\r\n\r\n        // create lines for all other links\r\n        var linkLines = linkViews.map(function(linkView) {\r\n            if (linkView == null) {\r\n                return [];\r\n            }\r\n            if (linkView === this) {\r\n                return thisLines;\r\n            }\r\n            return createLines(\r\n                linkView.sourcePoint,\r\n                linkView.targetPoint,\r\n                linkView.route\r\n            );\r\n        }, this);\r\n\r\n        // transform lines for this link by splitting with jump lines at\r\n        // points of intersection with other links\r\n        var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\r\n            // iterate all links and grab the intersections with this line\r\n            // these are then sorted by distance so the line can be split more easily\r\n            var intersections = _(links).map(function(link, i) {\r\n                // don't intersection with itself\r\n                if (link === thisModel) {\r\n                    return null;\r\n                }\r\n                return findLineIntersections(thisLine, linkLines[i]);\r\n            }).flatten().compact().sortBy(_.partial(sortPoints, thisLine.start)).value();\r\n\r\n            if (intersections.length > 0) {\r\n                // split the line based on found intersection points\r\n                resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\r\n            } else {\r\n                // without any intersection the line goes uninterrupted\r\n                resultLines.push(thisLine);\r\n            }\r\n            return resultLines;\r\n        }, []);\r\n\r\n        return buildPath(jumpingLines, jumpSize, jumpType);\r\n    };\r\n}(_, g));\r\n\r\n(function(_, g, joint) {\r\n\r\n    function portTransformAttrs(point, angle, opt) {\r\n\r\n        var trans = point.toJSON();\r\n\r\n        trans.angle = angle || 0;\r\n\r\n        return _.defaults({}, opt, trans);\r\n    }\r\n\r\n    function lineLayout(ports, p1, p2) {\r\n        return _.map(ports, function(port, index, ports) {\r\n            var p = this.pointAt(((index + 0.5) / ports.length));\r\n            // `dx`,`dy` per port offset option\r\n            if (port.dx || port.dy) {\r\n                p.offset(port.dx || 0, port.dy || 0);\r\n            }\r\n\r\n            return portTransformAttrs(p.round(), 0, port);\r\n        }, g.line(p1, p2));\r\n    }\r\n\r\n    function ellipseLayout(ports, elBBox, startAngle, stepFn) {\r\n\r\n        var center = elBBox.center();\r\n        var ratio = elBBox.width / elBBox.height;\r\n        var p1 = elBBox.topMiddle();\r\n\r\n        var ellipse = g.Ellipse.fromRect(elBBox);\r\n\r\n        return _.map(ports, function(port, index, ports) {\r\n\r\n            var angle = startAngle + stepFn(index, ports.length);\r\n            var p2 = p1.clone()\r\n                .rotate(center, -angle)\r\n                .scale(ratio, 1, center);\r\n\r\n            var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\r\n\r\n            // `dx`,`dy` per port offset option\r\n            if (port.dx || port.dy) {\r\n                p2.offset(port.dx || 0, port.dy || 0);\r\n            }\r\n\r\n            // `dr` delta radius option\r\n            if (port.dr) {\r\n                p2.move(center, port.dr);\r\n            }\r\n\r\n            return portTransformAttrs(p2.round(), theta, port);\r\n        });\r\n    }\r\n\r\n    // Creates a point stored in arguments\r\n    function argPoint(bbox, args) {\r\n\r\n        var x = args.x;\r\n        if (_.isString(x)) {\r\n            x = parseFloat(x) / 100 * bbox.width;\r\n        }\r\n\r\n        var y = args.y;\r\n        if (_.isString(y)) {\r\n            y = parseFloat(y) / 100 * bbox.height;\r\n        }\r\n\r\n        return g.point(x || 0, y || 0);\r\n    }\r\n\r\n    joint.layout.Port = {\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        absolute: function(ports, elBBox, opt) {\r\n            //TODO v.talas angle\r\n            return _.map(ports, _.partial(argPoint, elBBox));\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        fn: function(ports, elBBox, opt) {\r\n            return opt.fn(ports, elBBox, opt);\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        line: function(ports, elBBox, opt) {\r\n\r\n            var start = argPoint(elBBox, opt.start || elBBox.origin());\r\n            var end = argPoint(elBBox, opt.end || elBBox.corner());\r\n\r\n            return lineLayout(ports, start, end);\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        left: function(ports, elBBox, opt) {\r\n            return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft());\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        right: function(ports, elBBox, opt) {\r\n            return lineLayout(ports, elBBox.topRight(), elBBox.corner());\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        top: function(ports, elBBox, opt) {\r\n            return lineLayout(ports, elBBox.origin(), elBBox.topRight());\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        bottom: function(ports, elBBox, opt) {\r\n            return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner());\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        ellipseSpread: function(ports, elBBox, opt) {\r\n\r\n            var startAngle = opt.startAngle || 0;\r\n            var stepAngle = opt.step || 360 / ports.length;\r\n\r\n            return ellipseLayout(ports, elBBox, startAngle, function(index) {\r\n                return index * stepAngle;\r\n            });\r\n        },\r\n\r\n        /**\r\n         * @param {Array<Object>} ports\r\n         * @param {g.Rect} elBBox\r\n         * @param {Object=} opt Group options\r\n         * @returns {Array<g.Point>}\r\n         */\r\n        ellipse: function(ports, elBBox, opt) {\r\n\r\n            var startAngle = opt.startAngle || 0;\r\n            var stepAngle = opt.step || 20;\r\n\r\n            return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\r\n                return (index + 0.5 - count / 2) * stepAngle;\r\n            });\r\n        }\r\n    };\r\n\r\n})(_, g, joint);\r\n\r\n(function(_, g, joint) {\r\n\r\n    function labelAttributes(opt1, opt2) {\r\n\r\n        return _.defaultsDeep({}, opt1, opt2, {\r\n            x: 0,\r\n            y: 0,\r\n            angle: 0,\r\n            attrs: {\r\n                '.': {\r\n                    y: '0',\r\n                    'text-anchor': 'start'\r\n                }\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    function outsideLayout(portPosition, elBBox, autoOrient, opt) {\r\n\r\n        opt = _.defaults({}, opt, { offset: 15 });\r\n        var angle = elBBox.center().theta(portPosition);\r\n        var x = getBBoxAngles(elBBox);\r\n\r\n        var tx, ty, y, textAnchor;\r\n        var offset = opt.offset;\r\n        var orientAngle = 0;\r\n\r\n        if (angle < x[1] || angle > x[2]) {\r\n            y = '.3em';\r\n            tx = offset;\r\n            ty = 0;\r\n            textAnchor = 'start';\r\n        } else if (angle < x[0]) {\r\n            y = '0';\r\n            tx = 0;\r\n            ty = -offset;\r\n            if (autoOrient) {\r\n                orientAngle = -90;\r\n                textAnchor = 'start';\r\n            } else {\r\n                textAnchor = 'middle';\r\n            }\r\n        } else if (angle < x[3]) {\r\n            y = '.3em';\r\n            tx = -offset;\r\n            ty = 0;\r\n            textAnchor = 'end';\r\n        } else {\r\n            y = '.6em';\r\n            tx = 0;\r\n            ty = offset;\r\n            if (autoOrient) {\r\n                orientAngle = 90;\r\n                textAnchor = 'start';\r\n            } else {\r\n                textAnchor = 'middle';\r\n            }\r\n        }\r\n\r\n        var round = Math.round;\r\n        return labelAttributes({\r\n            x: round(tx),\r\n            y: round(ty),\r\n            angle: orientAngle,\r\n            attrs: {\r\n                '.': {\r\n                    y: y,\r\n                    'text-anchor': textAnchor\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function getBBoxAngles(elBBox) {\r\n\r\n        var center = elBBox.center();\r\n\r\n        var tl = center.theta(elBBox.origin());\r\n        var bl = center.theta(elBBox.bottomLeft());\r\n        var br = center.theta(elBBox.corner());\r\n        var tr = center.theta(elBBox.topRight());\r\n\r\n        return [tl, tr, br, bl];\r\n    }\r\n\r\n    function insideLayout(portPosition, elBBox, autoOrient, opt) {\r\n\r\n        var angle = elBBox.center().theta(portPosition);\r\n        opt = _.defaults({}, opt, { offset: 15 });\r\n\r\n        var tx, ty, y, textAnchor;\r\n        var offset = opt.offset;\r\n        var orientAngle = 0;\r\n\r\n        var bBoxAngles = getBBoxAngles(elBBox);\r\n\r\n        if (angle < bBoxAngles[1] || angle > bBoxAngles[2]) {\r\n            y = '.3em';\r\n            tx = -offset;\r\n            ty = 0;\r\n            textAnchor = 'end';\r\n        } else if (angle < bBoxAngles[0]) {\r\n            y = '.6em';\r\n            tx = 0;\r\n            ty = offset;\r\n            if (autoOrient) {\r\n                orientAngle = 90;\r\n                textAnchor = 'start';\r\n            } else {\r\n                textAnchor = 'middle';\r\n            }\r\n        } else if (angle < bBoxAngles[3]) {\r\n            y = '.3em';\r\n            tx = offset;\r\n            ty = 0;\r\n            textAnchor = 'start';\r\n        } else {\r\n            y = '0em';\r\n            tx = 0;\r\n            ty = -offset;\r\n            if (autoOrient) {\r\n                orientAngle = -90;\r\n                textAnchor = 'start';\r\n            } else {\r\n                textAnchor = 'middle';\r\n            }\r\n        }\r\n\r\n        var round = Math.round;\r\n        return labelAttributes({\r\n            x: round(tx),\r\n            y: round(ty),\r\n            angle: orientAngle,\r\n            attrs: {\r\n                '.': {\r\n                    y: y,\r\n                    'text-anchor': textAnchor\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function radialLayout(portCenterOffset, autoOrient, opt) {\r\n\r\n        opt = _.defaults({}, opt, { offset: 20 });\r\n\r\n        var origin = g.point(0, 0);\r\n        var angle = -portCenterOffset.theta(origin);\r\n        var orientAngle = angle;\r\n        var offset = portCenterOffset.clone()\r\n            .move(origin, opt.offset)\r\n            .difference(portCenterOffset)\r\n            .round();\r\n\r\n        var y = '.3em';\r\n        var textAnchor;\r\n\r\n        if ((angle + 90) % 180 === 0) {\r\n            textAnchor = autoOrient ? 'end' : 'middle';\r\n            if (!autoOrient && angle === -270) {\r\n                y = '0em';\r\n            }\r\n        } else if (angle > -270 && angle < -90) {\r\n            textAnchor = 'start';\r\n            orientAngle = angle - 180;\r\n        } else {\r\n            textAnchor = 'end';\r\n        }\r\n\r\n        var round = Math.round;\r\n        return labelAttributes({\r\n            x: round(offset.x),\r\n            y: round(offset.y),\r\n            angle: autoOrient ? orientAngle : 0,\r\n            attrs: {\r\n                '.': {\r\n                    y: y,\r\n                    'text-anchor': textAnchor\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    joint.layout.PortLabel = {\r\n\r\n        manual: _.rearg(labelAttributes, 2),\r\n\r\n        left: function(portPosition, elBBox, opt) {\r\n            return labelAttributes(opt, { x: -15, attrs: { '.': { y: '.3em', 'text-anchor': 'end' } } });\r\n        },\r\n\r\n        right: function(portPosition, elBBox, opt) {\r\n            return labelAttributes(opt, { x: 15, attrs: { '.': { y: '.3em', 'text-anchor': 'start' } } });\r\n        },\r\n\r\n        top: function(portPosition, elBBox, opt) {\r\n            return labelAttributes(opt, { y: -15, attrs: { '.': { 'text-anchor': 'middle' } } });\r\n        },\r\n\r\n        bottom: function(portPosition, elBBox, opt) {\r\n            return labelAttributes(opt, { y: 15, attrs: { '.': { y: '.6em', 'text-anchor': 'middle' } } });\r\n        },\r\n\r\n        outsideOriented: function(portPosition, elBBox, opt) {\r\n            return outsideLayout(portPosition, elBBox, true, opt);\r\n        },\r\n\r\n        outside: function(portPosition, elBBox, opt) {\r\n            return outsideLayout(portPosition, elBBox, false, opt);\r\n        },\r\n\r\n        insideOriented: function(portPosition, elBBox, opt) {\r\n            return insideLayout(portPosition, elBBox, true, opt);\r\n        },\r\n\r\n        inside: function(portPosition, elBBox, opt) {\r\n            return insideLayout(portPosition, elBBox, false, opt);\r\n        },\r\n\r\n        radial: function(portPosition, elBBox, opt) {\r\n            return radialLayout(portPosition.difference(elBBox.center()), false, opt);\r\n        },\r\n\r\n        radialOriented: function(portPosition, elBBox, opt) {\r\n            return radialLayout(portPosition.difference(elBBox.center()), true, opt);\r\n        }\r\n    };\r\n\r\n})(_, g, joint);\r\n\r\njoint.highlighters.addClass = {\r\n\r\n    className: joint.util.addClassNamePrefix('highlighted'),\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     * @param {object=} opt\r\n     */\r\n    highlight: function(cellView, magnetEl, opt) {\r\n\r\n        var options = opt || {};\r\n        var className = options.className || this.className;\r\n        V(magnetEl).addClass(className);\r\n    },\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     * @param {object=} opt\r\n     */\r\n    unhighlight: function(cellView, magnetEl, opt) {\r\n\r\n        var options = opt || {};\r\n        var className = options.className || this.className;\r\n        V(magnetEl).removeClass(className);\r\n    }\r\n};\r\n\r\njoint.highlighters.opacity = {\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     */\r\n    highlight: function(cellView, magnetEl) {\r\n\r\n        V(magnetEl).addClass(joint.util.addClassNamePrefix('highlight-opacity'));\r\n    },\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     */\r\n    unhighlight: function(cellView, magnetEl) {\r\n\r\n        V(magnetEl).removeClass(joint.util.addClassNamePrefix('highlight-opacity'));\r\n    }\r\n};\r\n\r\njoint.highlighters.stroke = {\r\n\r\n    defaultOptions: {\r\n        padding: 3,\r\n        rx: 0,\r\n        ry: 0,\r\n        attrs: {\r\n            'stroke-width': 3,\r\n            stroke: '#FEB663'\r\n        }\r\n    },\r\n\r\n    _views: {},\r\n\r\n    getHighlighterId: function(magnetEl, opt) {\r\n\r\n        return magnetEl.id + JSON.stringify(opt);\r\n    },\r\n\r\n    removeHighlighter: function(id) {\r\n        if (this._views[id]) {\r\n            this._views[id].remove();\r\n            this._views[id] = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     * @param {object=} opt\r\n     */\r\n    highlight: function(cellView, magnetEl, opt) {\r\n\r\n        var id = this.getHighlighterId(magnetEl, opt);\r\n\r\n        // Only highlight once.\r\n        if (this._views[id]) return;\r\n\r\n        var options = _.defaults(opt || {}, this.defaultOptions);\r\n\r\n        var magnetVel = V(magnetEl);\r\n        var magnetBBox;\r\n\r\n        try {\r\n\r\n            var pathData = magnetVel.convertToPathData();\r\n\r\n        } catch (error) {\r\n\r\n            // Failed to get path data from magnet element.\r\n            // Draw a rectangle around the entire cell view instead.\r\n            magnetBBox = magnetVel.bbox(true/* without transforms */);\r\n            pathData = V.rectToPath(_.extend({}, options, magnetBBox));\r\n        }\r\n\r\n        var highlightVel = V('path').attr({\r\n            d: pathData,\r\n            'pointer-events': 'none',\r\n            'vector-effect': 'non-scaling-stroke',\r\n            'fill': 'none'\r\n        }).attr(options.attrs);\r\n\r\n        highlightVel.transform(cellView.el.getCTM().inverse());\r\n        highlightVel.transform(magnetEl.getCTM());\r\n\r\n        var padding = options.padding;\r\n        if (padding) {\r\n\r\n            magnetBBox || (magnetBBox = magnetVel.bbox(true));\r\n            // Add padding to the highlight element.\r\n            var cx = magnetBBox.x + (magnetBBox.width / 2);\r\n            var cy = magnetBBox.y + (magnetBBox.height / 2);\r\n            var sx = (magnetBBox.width + padding) / magnetBBox.width;\r\n            var sy = (magnetBBox.height + padding) / magnetBBox.height;\r\n            highlightVel.transform({\r\n                a: sx,\r\n                b: 0,\r\n                c: 0,\r\n                d: sy,\r\n                e: cx - sx * cx,\r\n                f: cy - sy * cy\r\n            });\r\n        }\r\n\r\n        // joint.mvc.View will handle the theme class name and joint class name prefix.\r\n        var highlightView = this._views[id] = new joint.mvc.View({\r\n            svgElement: true,\r\n            className: 'highlight-stroke',\r\n            el: highlightVel.node\r\n        });\r\n\r\n        // Remove the highlight view when the cell is removed from the graph.\r\n        var removeHandler = _.bind(this.removeHighlighter, this, id);\r\n        var cell = cellView.model;\r\n        highlightView.listenTo(cell, 'remove', removeHandler);\r\n        highlightView.listenTo(cell.graph, 'reset', removeHandler);\r\n\r\n        cellView.vel.append(highlightVel);\r\n    },\r\n\r\n    /**\r\n     * @param {joint.dia.CellView} cellView\r\n     * @param {Element} magnetEl\r\n     * @param {object=} opt\r\n     */\r\n    unhighlight: function(cellView, magnetEl, opt) {\r\n\r\n        this.removeHighlighter(this.getHighlighterId(magnetEl, opt));\r\n    }\r\n};\r\n\r\njoint.shapes.erd = {};\r\n\r\njoint.shapes.erd.Entity = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Entity',\r\n        size: { width: 150, height: 60 },\r\n        attrs: {\r\n            '.outer': {\r\n                fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\r\n                points: '100,0 100,60 0,60 0,0'\r\n            },\r\n            '.inner': {\r\n                fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\r\n                points: '95,5 95,55 5,55 5,5',\r\n                display: 'none'\r\n            },\r\n            text: {\r\n                text: 'Entity',\r\n                'font-family': 'Arial', 'font-size': 14,\r\n                'ref-x': .5, 'ref-y': .5,\r\n                'y-alignment': 'middle', 'text-anchor': 'middle'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.WeakEntity = joint.shapes.erd.Entity.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.WeakEntity',\r\n\r\n        attrs: {\r\n            '.inner' : { display: 'auto' },\r\n            text: { text: 'Weak Entity' }\r\n        }\r\n\r\n    }, joint.shapes.erd.Entity.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.Relationship = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Relationship',\r\n        size: { width: 80, height: 80 },\r\n        attrs: {\r\n            '.outer': {\r\n                fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\r\n                points: '40,0 80,40 40,80 0,40'\r\n            },\r\n            '.inner': {\r\n                fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\r\n                points: '40,5 75,40 40,75 5,40',\r\n                display: 'none'\r\n            },\r\n            text: {\r\n                text: 'Relationship',\r\n                'font-family': 'Arial', 'font-size': 12,\r\n                'ref-x': .5, 'ref-y': .5,\r\n                'y-alignment': 'middle', 'text-anchor': 'middle'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.IdentifyingRelationship = joint.shapes.erd.Relationship.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.IdentifyingRelationship',\r\n\r\n        attrs: {\r\n            '.inner': { display: 'auto' },\r\n            text: { text: 'Identifying' }\r\n        }\r\n\r\n    }, joint.shapes.erd.Relationship.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.Attribute = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse class=\"outer\"/><ellipse class=\"inner\"/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Attribute',\r\n        size: { width: 100, height: 50 },\r\n        attrs: {\r\n            'ellipse': {\r\n                transform: 'translate(50, 25)'\r\n            },\r\n            '.outer': {\r\n                stroke: '#D35400', 'stroke-width': 2,\r\n                cx: 0, cy: 0, rx: 50, ry: 25,\r\n                fill: '#E67E22'\r\n            },\r\n            '.inner': {\r\n                stroke: '#D35400', 'stroke-width': 2,\r\n                cx: 0, cy: 0, rx: 45, ry: 20,\r\n                fill: '#E67E22', display: 'none'\r\n            },\r\n            text: {\r\n                'font-family': 'Arial', 'font-size': 14,\r\n                'ref-x': .5, 'ref-y': .5,\r\n                'y-alignment': 'middle', 'text-anchor': 'middle'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.erd.Multivalued = joint.shapes.erd.Attribute.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Multivalued',\r\n\r\n        attrs: {\r\n            '.inner': { display: 'block' },\r\n            text: { text: 'multivalued' }\r\n        }\r\n\r\n    }, joint.shapes.erd.Attribute.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.Derived = joint.shapes.erd.Attribute.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Derived',\r\n\r\n        attrs: {\r\n            '.outer': { 'stroke-dasharray': '3,5' },\r\n            text: { text: 'derived' }\r\n        }\r\n\r\n    }, joint.shapes.erd.Attribute.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.Key = joint.shapes.erd.Attribute.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Key',\r\n\r\n        attrs: {\r\n            ellipse: { 'stroke-width': 4 },\r\n            text: { text: 'key', 'font-weight': '800', 'text-decoration': 'underline' }\r\n        }\r\n\r\n    }, joint.shapes.erd.Attribute.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.Normal = joint.shapes.erd.Attribute.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.Normal',\r\n\r\n        attrs: { text: { text: 'Normal' }}\r\n\r\n    }, joint.shapes.erd.Attribute.prototype.defaults)\r\n});\r\n\r\njoint.shapes.erd.ISA = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'erd.ISA',\r\n        size: { width: 100, height: 50 },\r\n        attrs: {\r\n            polygon: {\r\n                points: '0,0 50,50 100,0',\r\n                fill: '#F1C40F', stroke: '#F39C12', 'stroke-width': 2\r\n            },\r\n            text: {\r\n                text: 'ISA', 'font-size': 18,\r\n                'ref-x': .5, 'ref-y': .3,\r\n                'y-alignment': 'middle', 'text-anchor': 'middle'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.erd.Line = joint.dia.Link.extend({\r\n\r\n    defaults: { type: 'erd.Line' },\r\n\r\n    cardinality: function(value) {\r\n        this.set('labels', [{ position: -20, attrs: { text: { dy: -8, text: value }}}]);\r\n    }\r\n});\r\n\r\njoint.shapes.fsa = {};\r\n\r\njoint.shapes.fsa.State = joint.shapes.basic.Circle.extend({\r\n    defaults: _.defaultsDeep({\r\n        type: 'fsa.State',\r\n        attrs: {\r\n            circle: { 'stroke-width': 3 },\r\n            text: { 'font-weight': '800' }\r\n        }\r\n    }, joint.shapes.basic.Circle.prototype.defaults)\r\n});\r\n\r\njoint.shapes.fsa.StartState = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'fsa.StartState',\r\n        size: { width: 20, height: 20 },\r\n        attrs: {\r\n            circle: {\r\n                transform: 'translate(10, 10)',\r\n                r: 10,\r\n                fill: '#000000'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.fsa.EndState = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'fsa.EndState',\r\n        size: { width: 20, height: 20 },\r\n        attrs: {\r\n            '.outer': {\r\n                transform: 'translate(10, 10)',\r\n                r: 10,\r\n                fill: '#ffffff',\r\n                stroke: '#000000'\r\n            },\r\n\r\n            '.inner': {\r\n                transform: 'translate(10, 10)',\r\n                r: 6,\r\n                fill: '#000000'\r\n            }\r\n        }\r\n\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.fsa.Arrow = joint.dia.Link.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n        type: 'fsa.Arrow',\r\n        attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }},\r\n        smooth: true\r\n    }, joint.dia.Link.prototype.defaults)\r\n});\r\n\r\n\r\njoint.shapes.org = {};\r\n\r\njoint.shapes.org.Member = joint.dia.Element.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"card\"/><image/></g><text class=\"rank\"/><text class=\"name\"/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'org.Member',\r\n        size: { width: 180, height: 70 },\r\n        attrs: {\r\n\r\n            rect: { width: 170, height: 60 },\r\n\r\n            '.card': {\r\n                fill: '#FFFFFF', stroke: '#000000', 'stroke-width': 2,\r\n                'pointer-events': 'visiblePainted', rx: 10, ry: 10\r\n            },\r\n\r\n            image: {\r\n                width: 48, height: 48,\r\n                ref: '.card', 'ref-x': 10, 'ref-y': 5\r\n            },\r\n\r\n            '.rank': {\r\n                'text-decoration': 'underline',\r\n                ref: '.card', 'ref-x': 0.9, 'ref-y': 0.2,\r\n                'font-family': 'Courier New', 'font-size': 14,\r\n                'text-anchor': 'end'\r\n            },\r\n\r\n            '.name': {\r\n                'font-weight': '800',\r\n                ref: '.card', 'ref-x': 0.9, 'ref-y': 0.6,\r\n                'font-family': 'Courier New', 'font-size': 14,\r\n                'text-anchor': 'end'\r\n            }\r\n        }\r\n    }, joint.dia.Element.prototype.defaults)\r\n});\r\n\r\njoint.shapes.org.Arrow = joint.dia.Link.extend({\r\n\r\n    defaults: {\r\n        type: 'org.Arrow',\r\n        source: { selector: '.card' }, target: { selector: '.card' },\r\n        attrs: { '.connection': { stroke: '#585858', 'stroke-width': 3 }},\r\n        z: -1\r\n    }\r\n});\r\n\r\n\r\njoint.shapes.chess = {};\r\n\r\njoint.shapes.chess.KingWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\"><path      d=\"M 22.5,11.63 L 22.5,6\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 20,8 L 25,8\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"      style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 11.5,30 C 17,27 27,27 32.5,30\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,37 C 17,34 27,34 32.5,37\"      style=\"fill:none; stroke:#000000;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.KingWhite',\r\n        size: { width: 42, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.KingBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path       d=\"M 22.5,11.63 L 22.5,6\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\"       id=\"path6570\" />    <path       d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"       style=\"fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path       d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"       style=\"fill:#000000; stroke:#000000;\" />    <path       d=\"M 20,8 L 25,8\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path       d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.KingBlack',\r\n        size: { width: 42, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.QueenWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(-1,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(15.5,-5.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(32,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(7,-4.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(24,-4)\" />    <path      d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11.5,30 C 15,29 30,29 33.5,30\"      style=\"fill:none;\" />    <path      d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\"      style=\"fill:none;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.QueenWhite',\r\n        size: { width: 42, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.QueenBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:none;\">      <circle cx=\"6\"    cy=\"12\" r=\"2.75\" />      <circle cx=\"14\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"22.5\" cy=\"8\"  r=\"2.75\" />      <circle cx=\"31\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"39\"   cy=\"12\" r=\"2.75\" />    </g>    <path       d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"       style=\"stroke-linecap:butt; stroke:#000000;\" />    <path       d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"       style=\"stroke-linecap:butt;\" />    <path       d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"       style=\"fill:none; stroke:#000000; stroke-linecap:butt;\" />    <path       d=\"M 11,29 A 35,35 1 0 1 34,29\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 12.5,31.5 L 32.5,31.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.QueenBlack',\r\n        size: { width: 42, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.RookWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />    <path      d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"      style=\"stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.RookWhite',\r\n        size: { width: 32, height: 34 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.RookBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"      style=\"stroke-linecap:butt;stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,35.5 L 33,35.5 L 33,35.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 13,31.5 L 32,31.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,29.5 L 31,29.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 31,16.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.RookBlack',\r\n        size: { width: 32, height: 34 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.BishopWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path      d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.BishopWhite',\r\n        size: { width: 38, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.BishopBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path       d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"       style=\"fill:none; stroke:#ffffff; stroke-linejoin:miter;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.BishopBlack',\r\n        size: { width: 38, height: 38 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.KnightWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#000000; stroke:#000000;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.KnightWhite',\r\n        size: { width: 38, height: 37 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.KnightBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"      style=\"fill:#ffffff; stroke:none;\" />  </g></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.KnightBlack',\r\n        size: { width: 38, height: 37 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.PawnWhite = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.PawnWhite',\r\n        size: { width: 28, height: 33 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.chess.PawnBlack = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'chess.PawnBlack',\r\n        size: { width: 28, height: 33 }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\n\r\njoint.shapes.pn = {};\r\n\r\njoint.shapes.pn.Place = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"root\"/><g class=\"tokens\" /></g><text class=\"label\"/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'pn.Place',\r\n        size: { width: 50, height: 50 },\r\n        attrs: {\r\n            '.root': {\r\n                r: 25,\r\n                fill: '#ffffff',\r\n                stroke: '#000000',\r\n                transform: 'translate(25, 25)'\r\n            },\r\n            '.label': {\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-y': -20,\r\n                ref: '.root',\r\n                fill: '#000000',\r\n                'font-size': 12\r\n            },\r\n            '.tokens > circle': {\r\n                fill: '#000000',\r\n                r: 5\r\n            },\r\n            '.tokens.one > circle': { transform: 'translate(25, 25)' },\r\n\r\n            '.tokens.two > circle:nth-child(1)': { transform: 'translate(19, 25)' },\r\n            '.tokens.two > circle:nth-child(2)': { transform: 'translate(31, 25)' },\r\n\r\n            '.tokens.three > circle:nth-child(1)': { transform: 'translate(18, 29)' },\r\n            '.tokens.three > circle:nth-child(2)': { transform: 'translate(25, 19)' },\r\n            '.tokens.three > circle:nth-child(3)': { transform: 'translate(32, 29)' },\r\n\r\n            '.tokens.alot > text': {\r\n                transform: 'translate(25, 18)',\r\n                'text-anchor': 'middle',\r\n                fill: '#000000'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\n\r\njoint.shapes.pn.PlaceView = joint.dia.ElementView.extend({\r\n\r\n    initialize: function() {\r\n\r\n        joint.dia.ElementView.prototype.initialize.apply(this, arguments);\r\n\r\n        this.model.on('change:tokens', function() {\r\n\r\n            this.renderTokens();\r\n            this.update();\r\n\r\n        }, this);\r\n    },\r\n\r\n    render: function() {\r\n\r\n        joint.dia.ElementView.prototype.render.apply(this, arguments);\r\n\r\n        this.renderTokens();\r\n        this.update();\r\n    },\r\n\r\n    renderTokens: function() {\r\n\r\n        var $tokens = this.$('.tokens').empty();\r\n        $tokens[0].className.baseVal = 'tokens';\r\n\r\n        var tokens = this.model.get('tokens');\r\n\r\n        if (!tokens) return;\r\n\r\n        switch (tokens) {\r\n\r\n            case 1:\r\n                $tokens[0].className.baseVal += ' one';\r\n                $tokens.append(V('<circle/>').node);\r\n                break;\r\n\r\n            case 2:\r\n                $tokens[0].className.baseVal += ' two';\r\n                $tokens.append(V('<circle/>').node, V('<circle/>').node);\r\n                break;\r\n\r\n            case 3:\r\n                $tokens[0].className.baseVal += ' three';\r\n                $tokens.append(V('<circle/>').node, V('<circle/>').node, V('<circle/>').node);\r\n                break;\r\n\r\n            default:\r\n                $tokens[0].className.baseVal += ' alot';\r\n                $tokens.append(V('<text/>').text(tokens + '' ).node);\r\n                break;\r\n        }\r\n    }\r\n});\r\n\r\njoint.shapes.pn.Transition = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"root\"/></g></g><text class=\"label\"/>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'pn.Transition',\r\n        size: { width: 12, height: 50 },\r\n        attrs: {\r\n            'rect': {\r\n                width: 12,\r\n                height: 50,\r\n                fill: '#000000',\r\n                stroke: '#000000'\r\n            },\r\n            '.label': {\r\n                'text-anchor': 'middle',\r\n                'ref-x': .5,\r\n                'ref-y': -20,\r\n                ref: 'rect',\r\n                fill: '#000000',\r\n                'font-size': 12\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n});\r\n\r\njoint.shapes.pn.Link = joint.dia.Link.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'pn.Link',\r\n        attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }}\r\n\r\n    }, joint.dia.Link.prototype.defaults)\r\n});\r\n\r\njoint.shapes.devs = {};\r\n\r\njoint.shapes.devs.Model = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><rect class=\"body\"/><text class=\"label\"/></g>',\r\n    portMarkup: '<circle class=\"port-body\"/>',\r\n    portLabelMarkup: '<text class=\"port-label\"/>',\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'devs.Model',\r\n        inPorts: [],\r\n        outPorts: [],\r\n        size: {\r\n            width: 80,\r\n            height: 80\r\n        },\r\n        attrs: {\r\n            '.': {\r\n                magnet: false\r\n            },\r\n            '.label': {\r\n                text: 'Model',\r\n                'ref-x': .5,\r\n                'ref-y': 10,\r\n                'font-size': 18,\r\n                'text-anchor': 'middle',\r\n                fill: '#000'\r\n            },\r\n            '.body': {\r\n                'ref-width': '100%',\r\n                'ref-height': '100%',\r\n                stroke: '#000'\r\n            }\r\n        },\r\n        ports: {\r\n            groups: {\r\n                'in': {\r\n                    position: {\r\n                        name: 'left'\r\n                    },\r\n                    attrs: {\r\n                        '.port-label': {\r\n                            fill: '#000'\r\n                        },\r\n                        '.port-body': {\r\n                            fill: '#fff',\r\n                            stroke: '#000',\r\n                            r: 10,\r\n                            magnet: true\r\n                        }\r\n                    },\r\n                    label: {\r\n                        position: {\r\n                            name: 'left',\r\n                            args: {\r\n                                y: 10\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                'out': {\r\n                    position: {\r\n                        name: 'right'\r\n                    },\r\n                    attrs: {\r\n                        '.port-label': {\r\n                            fill: '#000'\r\n                        },\r\n                        '.port-body': {\r\n                            fill: '#fff',\r\n                            stroke: '#000',\r\n                            r: 10,\r\n                            magnet: true\r\n                        }\r\n                    },\r\n                    label: {\r\n                        position: {\r\n                            name: 'right',\r\n                            args: {\r\n                                y: 10\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, joint.shapes.basic.Generic.prototype.defaults),\r\n\r\n    initialize: function() {\r\n\r\n        joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\r\n\r\n        this.on('change:inPorts change:outPorts', this.updatePortItems, this);\r\n        this.updatePortItems();\r\n    },\r\n\r\n    updatePortItems: function(model, changed, opt) {\r\n\r\n        // Make sure all ports are unique.\r\n        var inPorts = _.uniq(this.get('inPorts'));\r\n        var outPorts = _.difference(_.uniq(this.get('outPorts')), inPorts);\r\n\r\n        var inPortItems = this.createPortItems('in', inPorts);\r\n        var outPortItems = this.createPortItems('out', outPorts);\r\n\r\n        this.prop('ports/items', inPortItems.concat(outPortItems), _.extend({ rewrite: true }, opt));\r\n    },\r\n\r\n    createPortItem: function(group, port) {\r\n\r\n        return {\r\n            id: port,\r\n            group: group,\r\n            attrs: {\r\n                '.port-label': {\r\n                    text: port\r\n                }\r\n            }\r\n        };\r\n    },\r\n\r\n    createPortItems: function(group, ports) {\r\n\r\n        return _.map(ports, _.bind(this.createPortItem, this, group));\r\n    },\r\n\r\n    _addGroupPort: function(port, group, opt) {\r\n\r\n        var ports = this.get(group);\r\n        return this.set(group, _.isArray(ports) ? ports.concat(port) : [port], opt);\r\n    },\r\n\r\n    addOutPort: function(port, opt) {\r\n\r\n        return this._addGroupPort(port, 'outPorts', opt);\r\n    },\r\n\r\n    addInPort: function(port, opt) {\r\n\r\n        return this._addGroupPort(port, 'inPorts', opt);\r\n    },\r\n\r\n    _removeGroupPort: function(port, group, opt) {\r\n\r\n        return this.set(group, _.without(this.get(group), port), opt);\r\n    },\r\n\r\n    removeOutPort: function(port, opt) {\r\n\r\n        return this._removeGroupPort(port, 'outPorts', opt);\r\n    },\r\n\r\n    removeInPort: function(port, opt) {\r\n\r\n        return this._removeGroupPort(port, 'inPorts', opt);\r\n    },\r\n\r\n    _changeGroup: function(group, properties, opt) {\r\n        \r\n        return this.prop('ports/groups/' + group, _.isObject(properties) ? properties : {}, opt);\r\n    },\r\n    \r\n    changeInGroup: function(properties, opt) {\r\n\r\n        return this._changeGroup('in', properties, opt);\r\n    },\r\n\r\n    changeOutGroup: function(properties, opt) {\r\n\r\n        return this._changeGroup('out', properties, opt);\r\n    }\r\n});\r\n\r\njoint.shapes.devs.Atomic = joint.shapes.devs.Model.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'devs.Atomic',\r\n        size: {\r\n            width: 80,\r\n            height: 80\r\n        },\r\n        attrs: {\r\n            '.label': {\r\n                text: 'Atomic'\r\n            }\r\n        }\r\n    }, joint.shapes.devs.Model.prototype.defaults)\r\n});\r\n\r\njoint.shapes.devs.Coupled = joint.shapes.devs.Model.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'devs.Coupled',\r\n        size: {\r\n            width: 200,\r\n            height: 300\r\n        },\r\n        attrs: {\r\n            '.label': {\r\n                text: 'Coupled'\r\n            }\r\n        }\r\n    }, joint.shapes.devs.Model.prototype.defaults)\r\n});\r\n\r\njoint.shapes.devs.Link = joint.dia.Link.extend({\r\n\r\n    defaults: {\r\n        type: 'devs.Link',\r\n        attrs: {\r\n            '.connection': {\r\n                'stroke-width': 2\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\njoint.shapes.uml = {};\r\n\r\njoint.shapes.uml.Class = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: [\r\n        '<g class=\"rotatable\">',\r\n        '<g class=\"scalable\">',\r\n        '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>',\r\n        '</g>',\r\n        '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'uml.Class',\r\n\r\n        attrs: {\r\n            rect: { 'width': 200 },\r\n\r\n            '.uml-class-name-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#3498db' },\r\n            '.uml-class-attrs-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\r\n            '.uml-class-methods-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\r\n\r\n            '.uml-class-name-text': {\r\n                'ref': '.uml-class-name-rect', 'ref-y': .5, 'ref-x': .5, 'text-anchor': 'middle', 'y-alignment': 'middle', 'font-weight': 'bold',\r\n                'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\r\n            },\r\n            '.uml-class-attrs-text': {\r\n                'ref': '.uml-class-attrs-rect', 'ref-y': 5, 'ref-x': 5,\r\n                'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\r\n            },\r\n            '.uml-class-methods-text': {\r\n                'ref': '.uml-class-methods-rect', 'ref-y': 5, 'ref-x': 5,\r\n                'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\r\n            }\r\n        },\r\n\r\n        name: [],\r\n        attributes: [],\r\n        methods: []\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults),\r\n\r\n    initialize: function() {\r\n\r\n        this.on('change:name change:attributes change:methods', function() {\r\n            this.updateRectangles();\r\n            this.trigger('uml-update');\r\n        }, this);\r\n\r\n        this.updateRectangles();\r\n\r\n        joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\r\n    },\r\n\r\n    getClassName: function() {\r\n        return this.get('name');\r\n    },\r\n\r\n    updateRectangles: function() {\r\n\r\n        var attrs = this.get('attrs');\r\n\r\n        var rects = [\r\n            { type: 'name', text: this.getClassName() },\r\n            { type: 'attrs', text: this.get('attributes') },\r\n            { type: 'methods', text: this.get('methods') }\r\n        ];\r\n\r\n        var offsetY = 0;\r\n\r\n        _.each(rects, function(rect) {\r\n\r\n            var lines = _.isArray(rect.text) ? rect.text : [rect.text];\r\n            var rectHeight = lines.length * 20 + 20;\r\n\r\n            attrs['.uml-class-' + rect.type + '-text'].text = lines.join('\\n');\r\n            attrs['.uml-class-' + rect.type + '-rect'].height = rectHeight;\r\n            attrs['.uml-class-' + rect.type + '-rect'].transform = 'translate(0,' + offsetY + ')';\r\n\r\n            offsetY += rectHeight;\r\n        });\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.uml.ClassView = joint.dia.ElementView.extend({\r\n\r\n    initialize: function() {\r\n\r\n        joint.dia.ElementView.prototype.initialize.apply(this, arguments);\r\n\r\n        this.listenTo(this.model, 'uml-update', function() {\r\n            this.update();\r\n            this.resize();\r\n        });\r\n    }\r\n});\r\n\r\njoint.shapes.uml.Abstract = joint.shapes.uml.Class.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n        type: 'uml.Abstract',\r\n        attrs: {\r\n            '.uml-class-name-rect': { fill : '#e74c3c' },\r\n            '.uml-class-attrs-rect': { fill : '#c0392b' },\r\n            '.uml-class-methods-rect': { fill : '#c0392b' }\r\n        }\r\n    }, joint.shapes.uml.Class.prototype.defaults),\r\n\r\n    getClassName: function() {\r\n        return ['<<Abstract>>', this.get('name')];\r\n    }\r\n\r\n});\r\njoint.shapes.uml.AbstractView = joint.shapes.uml.ClassView;\r\n\r\njoint.shapes.uml.Interface = joint.shapes.uml.Class.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n        type: 'uml.Interface',\r\n        attrs: {\r\n            '.uml-class-name-rect': { fill : '#f1c40f' },\r\n            '.uml-class-attrs-rect': { fill : '#f39c12' },\r\n            '.uml-class-methods-rect': { fill : '#f39c12' }\r\n        }\r\n    }, joint.shapes.uml.Class.prototype.defaults),\r\n\r\n    getClassName: function() {\r\n        return ['<<Interface>>', this.get('name')];\r\n    }\r\n\r\n});\r\njoint.shapes.uml.InterfaceView = joint.shapes.uml.ClassView;\r\n\r\njoint.shapes.uml.Generalization = joint.dia.Link.extend({\r\n    defaults: {\r\n        type: 'uml.Generalization',\r\n        attrs: { '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' }}\r\n    }\r\n});\r\n\r\njoint.shapes.uml.Implementation = joint.dia.Link.extend({\r\n    defaults: {\r\n        type: 'uml.Implementation',\r\n        attrs: {\r\n            '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' },\r\n            '.connection': { 'stroke-dasharray': '3,3' }\r\n        }\r\n    }\r\n});\r\n\r\njoint.shapes.uml.Aggregation = joint.dia.Link.extend({\r\n    defaults: {\r\n        type: 'uml.Aggregation',\r\n        attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'white' }}\r\n    }\r\n});\r\n\r\njoint.shapes.uml.Composition = joint.dia.Link.extend({\r\n    defaults: {\r\n        type: 'uml.Composition',\r\n        attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'black' }}\r\n    }\r\n});\r\n\r\njoint.shapes.uml.Association = joint.dia.Link.extend({\r\n    defaults: { type: 'uml.Association' }\r\n});\r\n\r\n// Statechart\r\n\r\njoint.shapes.uml.State = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: [\r\n        '<g class=\"rotatable\">',\r\n        '<g class=\"scalable\">',\r\n        '<rect class=\"uml-state-body\"/>',\r\n        '</g>',\r\n        '<path class=\"uml-state-separator\"/>',\r\n        '<text class=\"uml-state-name\"/>',\r\n        '<text class=\"uml-state-events\"/>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'uml.State',\r\n\r\n        attrs: {\r\n            '.uml-state-body': {\r\n                'width': 200, 'height': 200, 'rx': 10, 'ry': 10,\r\n                'fill': '#ecf0f1', 'stroke': '#bdc3c7', 'stroke-width': 3\r\n            },\r\n            '.uml-state-separator': {\r\n                'stroke': '#bdc3c7', 'stroke-width': 2\r\n            },\r\n            '.uml-state-name': {\r\n                'ref': '.uml-state-body', 'ref-x': .5, 'ref-y': 5, 'text-anchor': 'middle',\r\n                'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\r\n            },\r\n            '.uml-state-events': {\r\n                'ref': '.uml-state-separator', 'ref-x': 5, 'ref-y': 5,\r\n                'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\r\n            }\r\n        },\r\n\r\n        name: 'State',\r\n        events: []\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults),\r\n\r\n    initialize: function() {\r\n\r\n        this.on({\r\n            'change:name': this.updateName,\r\n            'change:events': this.updateEvents,\r\n            'change:size': this.updatePath\r\n        }, this);\r\n\r\n        this.updateName();\r\n        this.updateEvents();\r\n        this.updatePath();\r\n\r\n        joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\r\n    },\r\n\r\n    updateName: function() {\r\n\r\n        this.attr('.uml-state-name/text', this.get('name'));\r\n    },\r\n\r\n    updateEvents: function() {\r\n\r\n        this.attr('.uml-state-events/text', this.get('events').join('\\n'));\r\n    },\r\n\r\n    updatePath: function() {\r\n\r\n        var d = 'M 0 20 L ' + this.get('size').width + ' 20';\r\n\r\n        // We are using `silent: true` here because updatePath() is meant to be called\r\n        // on resize and there's no need to to update the element twice (`change:size`\r\n        // triggers also an update).\r\n        this.attr('.uml-state-separator/d', d, { silent: true });\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.uml.StartState = joint.shapes.basic.Circle.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'uml.StartState',\r\n        attrs: { circle: { 'fill': '#34495e', 'stroke': '#2c3e50', 'stroke-width': 2, 'rx': 1 }}\r\n\r\n    }, joint.shapes.basic.Circle.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.uml.EndState = joint.shapes.basic.Generic.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'uml.EndState',\r\n        size: { width: 20, height: 20 },\r\n        attrs: {\r\n            'circle.outer': {\r\n                transform: 'translate(10, 10)',\r\n                r: 10,\r\n                fill: '#ffffff',\r\n                stroke: '#2c3e50'\r\n            },\r\n\r\n            'circle.inner': {\r\n                transform: 'translate(10, 10)',\r\n                r: 6,\r\n                fill: '#34495e'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.uml.Transition = joint.dia.Link.extend({\r\n    defaults: {\r\n        type: 'uml.Transition',\r\n        attrs: {\r\n            '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z', fill: '#34495e', stroke: '#2c3e50' },\r\n            '.connection': { stroke: '#2c3e50' }\r\n        }\r\n    }\r\n});\r\n\r\n\r\njoint.shapes.logic = {};\r\n\r\njoint.shapes.logic.Gate = joint.shapes.basic.Generic.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Gate',\r\n        size: { width: 80, height: 40 },\r\n        attrs: {\r\n            '.': { magnet: false },\r\n            '.body': { width: 100, height: 50 },\r\n            circle: { r: 7, stroke: 'black', fill: 'transparent', 'stroke-width': 2 }\r\n        }\r\n\r\n    }, joint.shapes.basic.Generic.prototype.defaults),\r\n\r\n    operation: function() { return true; }\r\n});\r\n\r\njoint.shapes.logic.IO = joint.shapes.logic.Gate.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"body\"/></g><path class=\"wire\"/><circle/><text/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.IO',\r\n        size: { width: 60, height: 30 },\r\n        attrs: {\r\n            '.body': { fill: 'white', stroke: 'black', 'stroke-width': 2 },\r\n            '.wire': { ref: '.body', 'ref-y': .5, stroke: 'black' },\r\n            text: {\r\n                fill: 'black',\r\n                ref: '.body', 'ref-x': .5, 'ref-y': .5, 'y-alignment': 'middle',\r\n                'text-anchor': 'middle',\r\n                'font-weight': 'bold',\r\n                'font-variant': 'small-caps',\r\n                'text-transform': 'capitalize',\r\n                'font-size': '14px'\r\n            }\r\n        }\r\n\r\n    }, joint.shapes.logic.Gate.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.logic.Input = joint.shapes.logic.IO.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Input',\r\n        attrs: {\r\n            '.wire': { 'ref-dx': 0, d: 'M 0 0 L 23 0' },\r\n            circle: { ref: '.body', 'ref-dx': 30, 'ref-y': 0.5, magnet: true, 'class': 'output', port: 'out' },\r\n            text: { text: 'input' }\r\n        }\r\n\r\n    }, joint.shapes.logic.IO.prototype.defaults)\r\n});\r\n\r\njoint.shapes.logic.Output = joint.shapes.logic.IO.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Output',\r\n        attrs: {\r\n            '.wire': { 'ref-x': 0, d: 'M 0 0 L -23 0' },\r\n            circle: { ref: '.body', 'ref-x': -30, 'ref-y': 0.5, magnet: 'passive', 'class': 'input', port: 'in' },\r\n            text: { text: 'output' }\r\n        }\r\n\r\n    }, joint.shapes.logic.IO.prototype.defaults)\r\n\r\n});\r\n\r\n\r\njoint.shapes.logic.Gate11 = joint.shapes.logic.Gate.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input\"/><circle class=\"output\"/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Gate11',\r\n        attrs: {\r\n            '.input': { ref: '.body', 'ref-x': -2, 'ref-y': 0.5, magnet: 'passive', port: 'in' },\r\n            '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\r\n        }\r\n\r\n    }, joint.shapes.logic.Gate.prototype.defaults)\r\n});\r\n\r\njoint.shapes.logic.Gate21 = joint.shapes.logic.Gate.extend({\r\n\r\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input input1\"/><circle  class=\"input input2\"/><circle class=\"output\"/></g>',\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Gate21',\r\n        attrs: {\r\n            '.input1': { ref: '.body', 'ref-x': -2, 'ref-y': 0.3, magnet: 'passive', port: 'in1' },\r\n            '.input2': { ref: '.body', 'ref-x': -2, 'ref-y': 0.7, magnet: 'passive', port: 'in2' },\r\n            '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\r\n        }\r\n\r\n    }, joint.shapes.logic.Gate.prototype.defaults)\r\n\r\n});\r\n\r\njoint.shapes.logic.Repeater = joint.shapes.logic.Gate11.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Repeater',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=' }}\r\n\r\n    }, joint.shapes.logic.Gate11.prototype.defaults),\r\n\r\n    operation: function(input) {\r\n        return input;\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Not = joint.shapes.logic.Gate11.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Not',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K' }}\r\n\r\n    }, joint.shapes.logic.Gate11.prototype.defaults),\r\n\r\n    operation: function(input) {\r\n        return !input;\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Or = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Or',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return input1 || input2;\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.And = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.And',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return input1 && input2;\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Nor = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Nor',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return !(input1 || input2);\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Nand = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Nand',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return !(input1 && input2);\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Xor = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Xor',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return (!input1 || input2) && (input1 || !input2);\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Xnor = joint.shapes.logic.Gate21.extend({\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Xnor',\r\n        attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\r\n\r\n    }, joint.shapes.logic.Gate21.prototype.defaults),\r\n\r\n    operation: function(input1, input2) {\r\n        return (!input1 || !input2) && (input1 || input2);\r\n    }\r\n\r\n});\r\n\r\njoint.shapes.logic.Wire = joint.dia.Link.extend({\r\n\r\n    arrowheadMarkup: [\r\n        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\r\n        '<circle class=\"marker-arrowhead\" end=\"<%= end %>\" r=\"7\"/>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    vertexMarkup: [\r\n        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\r\n        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\r\n        '<g class=\"marker-vertex-remove-group\">',\r\n        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\r\n        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\r\n        '<title>Remove vertex.</title>',\r\n        '</path>',\r\n        '</g>',\r\n        '</g>'\r\n    ].join(''),\r\n\r\n    defaults: _.defaultsDeep({\r\n\r\n        type: 'logic.Wire',\r\n\r\n        attrs: {\r\n            '.connection': { 'stroke-width': 2 },\r\n            '.marker-vertex': { r: 7 }\r\n        },\r\n\r\n        router: { name: 'orthogonal' },\r\n        connector: { name: 'rounded', args: { radius: 10 }}\r\n\r\n    }, joint.dia.Link.prototype.defaults)\r\n\r\n});\r\n\r\nif (typeof exports === 'object') {\r\n\r\n    var graphlib = require('graphlib');\r\n    var dagre = require('dagre');\r\n}\r\n\r\n// In the browser, these variables are set to undefined because of JavaScript hoisting.\r\n// In that case, should grab them from the window object.\r\ngraphlib = graphlib || (typeof window !== 'undefined' && window.graphlib);\r\ndagre = dagre || (typeof window !== 'undefined' && window.dagre);\r\n\r\njoint.layout.DirectedGraph = {\r\n\r\n    layout: function(graphOrCells, opt) {\r\n\r\n        var graph;\r\n\r\n        if (graphOrCells instanceof joint.dia.Graph) {\r\n            graph = graphOrCells;\r\n        } else {\r\n            // Reset cells in dry mode so the graph reference is not stored on the cells.\r\n            graph = (new joint.dia.Graph()).resetCells(graphOrCells, { dry: true });\r\n        }\r\n\r\n        // This is not needed anymore.\r\n        graphOrCells = null;\r\n\r\n        opt = _.defaults(opt || {}, {\r\n            resizeClusters: true,\r\n            clusterPadding: 10\r\n        });\r\n\r\n        // create a graphlib.Graph that represents the joint.dia.Graph\r\n        var glGraph = graph.toGraphLib({\r\n            directed: true,\r\n            // We are about to use edge naming feature.\r\n            multigraph: true,\r\n            // We are able to layout graphs with embeds.\r\n            compound: true,\r\n            setNodeLabel: function(element) {\r\n                return {\r\n                    width: element.get('size').width,\r\n                    height: element.get('size').height,\r\n                    rank: element.get('rank')\r\n                };\r\n            },\r\n            setEdgeLabel: function(link) {\r\n                return {\r\n                    minLen: link.get('minLen') || 1\r\n                };\r\n            },\r\n            setEdgeName: function(link) {\r\n                // Graphlib edges have no ids. We use edge name property\r\n                // to store and retrieve ids instead.\r\n                return link.id;\r\n            }\r\n        });\r\n\r\n        var glLabel = {};\r\n        var marginX = opt.marginX || 0;\r\n        var marginY = opt.marginY || 0;\r\n\r\n        // Dagre layout accepts options as lower case.\r\n        // Direction for rank nodes. Can be TB, BT, LR, or RL\r\n        if (opt.rankDir) glLabel.rankdir = opt.rankDir;\r\n        // Alignment for rank nodes. Can be UL, UR, DL, or DR\r\n        if (opt.align) glLabel.align = opt.align;\r\n        // Number of pixels that separate nodes horizontally in the layout.\r\n        if (opt.nodeSep) glLabel.nodesep = opt.nodeSep;\r\n        // Number of pixels that separate edges horizontally in the layout.\r\n        if (opt.edgeSep) glLabel.edgesep = opt.edgeSep;\r\n        // Number of pixels between each rank in the layout.\r\n        if (opt.rankSep) glLabel.ranksep = opt.rankSep;\r\n        // Number of pixels to use as a margin around the left and right of the graph.\r\n        if (marginX) glLabel.marginx = marginX;\r\n        // Number of pixels to use as a margin around the top and bottom of the graph.\r\n        if (marginY) glLabel.marginy = marginY;\r\n\r\n        // Set the option object for the graph label.\r\n        glGraph.setGraph(glLabel);\r\n\r\n        // Executes the layout.\r\n        dagre.layout(glGraph, { debugTiming: !!opt.debugTiming });\r\n\r\n        // Wrap all graph changes into a batch.\r\n        graph.startBatch('layout');\r\n\r\n        // Update the graph.\r\n        graph.fromGraphLib(glGraph, {\r\n            importNode: function(v, gl) {\r\n\r\n                var element = this.getCell(v);\r\n                var glNode = gl.node(v);\r\n\r\n                if (opt.setPosition) {\r\n                    opt.setPosition(element, glNode);\r\n                } else {\r\n                    element.set('position', {\r\n                        x: glNode.x - glNode.width / 2,\r\n                        y: glNode.y - glNode.height / 2\r\n                    });\r\n                }\r\n            },\r\n            importEdge: function(edgeObj, gl) {\r\n\r\n                var link = this.getCell(edgeObj.name);\r\n                var glEdge = gl.edge(edgeObj);\r\n                var points = glEdge.points || [];\r\n\r\n                if (opt.setLinkVertices) {\r\n                    if (opt.setVertices) {\r\n                        opt.setVertices(link, points);\r\n                    } else {\r\n                        // Remove the first and last point from points array.\r\n                        // Those are source/target element connection points\r\n                        // ie. they lies on the edge of connected elements.\r\n                        link.set('vertices', points.slice(1, points.length - 1));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (opt.resizeClusters) {\r\n            // Resize and reposition cluster elements (parents of other elements)\r\n            // to fit their children.\r\n            // 1. filter clusters only\r\n            // 2. map id on cells\r\n            // 3. sort cells by their depth (the deepest first)\r\n            // 4. resize cell to fit their direct children only.\r\n            _.chain(glGraph.nodes())\r\n                .filter(function(v) { return glGraph.children(v).length > 0; })\r\n                .map(graph.getCell, graph)\r\n                .sortBy(function(cluster) { return -cluster.getAncestors().length; })\r\n                .invoke('fitEmbeds', { padding: opt.clusterPadding })\r\n                .value();\r\n        }\r\n\r\n        graph.stopBatch('layout');\r\n\r\n        // Width and height of the graph extended by margins.\r\n        var glSize = glGraph.graph();\r\n        // Return the bounding box of the graph after the layout.\r\n        return g.Rect(\r\n            marginX,\r\n            marginY,\r\n            Math.abs(glSize.width - 2 * marginX),\r\n            Math.abs(glSize.height - 2 * marginY)\r\n        );\r\n    },\r\n\r\n    fromGraphLib: function(glGraph, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var importNode = opt.importNode || _.noop;\r\n        var importEdge = opt.importEdge || _.noop;\r\n        var graph = (this instanceof joint.dia.Graph) ? this : new joint.dia.Graph;\r\n\r\n        // Import all nodes.\r\n        glGraph.nodes().forEach(function(node) {\r\n            importNode.call(graph, node, glGraph, graph, opt);\r\n        });\r\n\r\n        // Import all edges.\r\n        glGraph.edges().forEach(function(edge) {\r\n            importEdge.call(graph, edge, glGraph, graph, opt);\r\n        });\r\n\r\n        return graph;\r\n    },\r\n\r\n    // Create new graphlib graph from existing JointJS graph.\r\n    toGraphLib: function(graph, opt) {\r\n\r\n        opt = opt || {};\r\n\r\n        var glGraphType = _.pick(opt, 'directed', 'compound', 'multigraph');\r\n        var glGraph = new graphlib.Graph(glGraphType);\r\n        var setNodeLabel = opt.setNodeLabel || _.noop;\r\n        var setEdgeLabel = opt.setEdgeLabel || _.noop;\r\n        var setEdgeName = opt.setEdgeName || _.noop;\r\n\r\n        graph.get('cells').each(function(cell) {\r\n\r\n            if (cell.isLink()) {\r\n\r\n                var source = cell.get('source');\r\n                var target = cell.get('target');\r\n\r\n                // Links that end at a point are ignored.\r\n                if (!source.id || !target.id) return;\r\n\r\n                // Note that if we are creating a multigraph we can name the edges. If\r\n                // we try to name edges on a non-multigraph an exception is thrown.\r\n                glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\r\n\r\n            } else {\r\n\r\n                glGraph.setNode(cell.id, setNodeLabel(cell));\r\n\r\n                // For the compound graphs we have to take embeds into account.\r\n                if (glGraph.isCompound() && cell.has('parent')) {\r\n                    glGraph.setParent(cell.id, cell.get('parent'));\r\n                }\r\n            }\r\n        });\r\n\r\n        return glGraph;\r\n    }\r\n};\r\n\r\njoint.dia.Graph.prototype.toGraphLib = function(opt) {\r\n\r\n    return joint.layout.DirectedGraph.toGraphLib(this, opt);\r\n};\r\n\r\njoint.dia.Graph.prototype.fromGraphLib = function(glGraph, opt) {\r\n\r\n    return joint.layout.DirectedGraph.fromGraphLib.call(this, glGraph, opt);\r\n};\r\n\r\n\r\n    joint.g = g;\r\n    joint.V = joint.Vectorizer = V;\r\n\r\n    return joint;\r\n\r\n}));\r\n"

/***/ }),

/***/ 255:
/***/ (function(module, exports) {

module.exports = "/*!\r\n * jQuery JavaScript Library v3.2.1\r\n * https://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * https://sizzlejs.com/\r\n *\r\n * Copyright JS Foundation and other contributors\r\n * Released under the MIT license\r\n * https://jquery.org/license\r\n *\r\n * Date: 2017-03-20T18:59Z\r\n */\r\n( function( global, factory ) {\r\n\r\n\t\"use strict\";\r\n\r\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\r\n\r\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\r\n\t\t// is present, execute the factory and get jQuery.\r\n\t\t// For environments that do not have a `window` with a `document`\r\n\t\t// (such as Node.js), expose a factory as module.exports.\r\n\t\t// This accentuates the need for the creation of a real `window`.\r\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\r\n\t\t// See ticket #14549 for more info.\r\n\t\tmodule.exports = global.document ?\r\n\t\t\tfactory( global, true ) :\r\n\t\t\tfunction( w ) {\r\n\t\t\t\tif ( !w.document ) {\r\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\r\n\t\t\t\t}\r\n\t\t\t\treturn factory( w );\r\n\t\t\t};\r\n\t} else {\r\n\t\tfactory( global );\r\n\t}\r\n\r\n// Pass this if window is not defined yet\r\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\r\n\r\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\r\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\r\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\r\n// enough that all such attempts are guarded in a try block.\r\n\"use strict\";\r\n\r\nvar arr = [];\r\n\r\nvar document = window.document;\r\n\r\nvar getProto = Object.getPrototypeOf;\r\n\r\nvar slice = arr.slice;\r\n\r\nvar concat = arr.concat;\r\n\r\nvar push = arr.push;\r\n\r\nvar indexOf = arr.indexOf;\r\n\r\nvar class2type = {};\r\n\r\nvar toString = class2type.toString;\r\n\r\nvar hasOwn = class2type.hasOwnProperty;\r\n\r\nvar fnToString = hasOwn.toString;\r\n\r\nvar ObjectFunctionString = fnToString.call( Object );\r\n\r\nvar support = {};\r\n\r\n\r\n\r\n\tfunction DOMEval( code, doc ) {\r\n\t\tdoc = doc || document;\r\n\r\n\t\tvar script = doc.createElement( \"script\" );\r\n\r\n\t\tscript.text = code;\r\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\r\n\t}\r\n/* global Symbol */\r\n// Defining this global in .eslintrc.json would create a danger of using the global\r\n// unguarded in another place, it seems safer to define global only for this module\r\n\r\n\r\n\r\nvar\r\n\tversion = \"3.2.1\",\r\n\r\n\t// Define a local copy of jQuery\r\n\tjQuery = function( selector, context ) {\r\n\r\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\r\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\r\n\t\treturn new jQuery.fn.init( selector, context );\r\n\t},\r\n\r\n\t// Support: Android <=4.0 only\r\n\t// Make sure we trim BOM and NBSP\r\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\r\n\r\n\t// Matches dashed string for camelizing\r\n\trmsPrefix = /^-ms-/,\r\n\trdashAlpha = /-([a-z])/g,\r\n\r\n\t// Used by jQuery.camelCase as callback to replace()\r\n\tfcamelCase = function( all, letter ) {\r\n\t\treturn letter.toUpperCase();\r\n\t};\r\n\r\njQuery.fn = jQuery.prototype = {\r\n\r\n\t// The current version of jQuery being used\r\n\tjquery: version,\r\n\r\n\tconstructor: jQuery,\r\n\r\n\t// The default length of a jQuery object is 0\r\n\tlength: 0,\r\n\r\n\ttoArray: function() {\r\n\t\treturn slice.call( this );\r\n\t},\r\n\r\n\t// Get the Nth element in the matched element set OR\r\n\t// Get the whole matched element set as a clean array\r\n\tget: function( num ) {\r\n\r\n\t\t// Return all the elements in a clean array\r\n\t\tif ( num == null ) {\r\n\t\t\treturn slice.call( this );\r\n\t\t}\r\n\r\n\t\t// Return just the one element from the set\r\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\r\n\t},\r\n\r\n\t// Take an array of elements and push it onto the stack\r\n\t// (returning the new matched element set)\r\n\tpushStack: function( elems ) {\r\n\r\n\t\t// Build a new jQuery matched element set\r\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\r\n\r\n\t\t// Add the old object onto the stack (as a reference)\r\n\t\tret.prevObject = this;\r\n\r\n\t\t// Return the newly-formed element set\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// Execute a callback for every element in the matched set.\r\n\teach: function( callback ) {\r\n\t\treturn jQuery.each( this, callback );\r\n\t},\r\n\r\n\tmap: function( callback ) {\r\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\r\n\t\t\treturn callback.call( elem, i, elem );\r\n\t\t} ) );\r\n\t},\r\n\r\n\tslice: function() {\r\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\r\n\t},\r\n\r\n\tfirst: function() {\r\n\t\treturn this.eq( 0 );\r\n\t},\r\n\r\n\tlast: function() {\r\n\t\treturn this.eq( -1 );\r\n\t},\r\n\r\n\teq: function( i ) {\r\n\t\tvar len = this.length,\r\n\t\t\tj = +i + ( i < 0 ? len : 0 );\r\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\r\n\t},\r\n\r\n\tend: function() {\r\n\t\treturn this.prevObject || this.constructor();\r\n\t},\r\n\r\n\t// For internal use only.\r\n\t// Behaves like an Array's method, not like a jQuery method.\r\n\tpush: push,\r\n\tsort: arr.sort,\r\n\tsplice: arr.splice\r\n};\r\n\r\njQuery.extend = jQuery.fn.extend = function() {\r\n\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\ttarget = arguments[ 0 ] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\r\n\t// Handle a deep copy situation\r\n\tif ( typeof target === \"boolean\" ) {\r\n\t\tdeep = target;\r\n\r\n\t\t// Skip the boolean and the target\r\n\t\ttarget = arguments[ i ] || {};\r\n\t\ti++;\r\n\t}\r\n\r\n\t// Handle case when target is a string or something (possible in deep copy)\r\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\r\n\t\ttarget = {};\r\n\t}\r\n\r\n\t// Extend jQuery itself if only one argument is passed\r\n\tif ( i === length ) {\r\n\t\ttarget = this;\r\n\t\ti--;\r\n\t}\r\n\r\n\tfor ( ; i < length; i++ ) {\r\n\r\n\t\t// Only deal with non-null/undefined values\r\n\t\tif ( ( options = arguments[ i ] ) != null ) {\r\n\r\n\t\t\t// Extend the base object\r\n\t\t\tfor ( name in options ) {\r\n\t\t\t\tsrc = target[ name ];\r\n\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\r\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\r\n\r\n\t\t\t\t\tif ( copyIsArray ) {\r\n\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\r\n\r\n\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the modified object\r\n\treturn target;\r\n};\r\n\r\njQuery.extend( {\r\n\r\n\t// Unique for each copy of jQuery on the page\r\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\r\n\r\n\t// Assume jQuery is ready without the ready module\r\n\tisReady: true,\r\n\r\n\terror: function( msg ) {\r\n\t\tthrow new Error( msg );\r\n\t},\r\n\r\n\tnoop: function() {},\r\n\r\n\tisFunction: function( obj ) {\r\n\t\treturn jQuery.type( obj ) === \"function\";\r\n\t},\r\n\r\n\tisWindow: function( obj ) {\r\n\t\treturn obj != null && obj === obj.window;\r\n\t},\r\n\r\n\tisNumeric: function( obj ) {\r\n\r\n\t\t// As of jQuery 3.0, isNumeric is limited to\r\n\t\t// strings and numbers (primitives or objects)\r\n\t\t// that can be coerced to finite numbers (gh-2662)\r\n\t\tvar type = jQuery.type( obj );\r\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\r\n\r\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\r\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\r\n\t\t\t// subtraction forces infinities to NaN\r\n\t\t\t!isNaN( obj - parseFloat( obj ) );\r\n\t},\r\n\r\n\tisPlainObject: function( obj ) {\r\n\t\tvar proto, Ctor;\r\n\r\n\t\t// Detect obvious negatives\r\n\t\t// Use toString instead of jQuery.type to catch host objects\r\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tproto = getProto( obj );\r\n\r\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\r\n\t\tif ( !proto ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\r\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\r\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\r\n\t},\r\n\r\n\tisEmptyObject: function( obj ) {\r\n\r\n\t\t/* eslint-disable no-unused-vars */\r\n\t\t// See https://github.com/eslint/eslint/issues/6125\r\n\t\tvar name;\r\n\r\n\t\tfor ( name in obj ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\ttype: function( obj ) {\r\n\t\tif ( obj == null ) {\r\n\t\t\treturn obj + \"\";\r\n\t\t}\r\n\r\n\t\t// Support: Android <=2.3 only (functionish RegExp)\r\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\r\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\r\n\t\t\ttypeof obj;\r\n\t},\r\n\r\n\t// Evaluates a script in a global context\r\n\tglobalEval: function( code ) {\r\n\t\tDOMEval( code );\r\n\t},\r\n\r\n\t// Convert dashed to camelCase; used by the css and data modules\r\n\t// Support: IE <=9 - 11, Edge 12 - 13\r\n\t// Microsoft forgot to hump their vendor prefix (#9572)\r\n\tcamelCase: function( string ) {\r\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\r\n\t},\r\n\r\n\teach: function( obj, callback ) {\r\n\t\tvar length, i = 0;\r\n\r\n\t\tif ( isArrayLike( obj ) ) {\r\n\t\t\tlength = obj.length;\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor ( i in obj ) {\r\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t},\r\n\r\n\t// Support: Android <=4.0 only\r\n\ttrim: function( text ) {\r\n\t\treturn text == null ?\r\n\t\t\t\"\" :\r\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\r\n\t},\r\n\r\n\t// results is for internal usage only\r\n\tmakeArray: function( arr, results ) {\r\n\t\tvar ret = results || [];\r\n\r\n\t\tif ( arr != null ) {\r\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\r\n\t\t\t\tjQuery.merge( ret,\r\n\t\t\t\t\ttypeof arr === \"string\" ?\r\n\t\t\t\t\t[ arr ] : arr\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tpush.call( ret, arr );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t},\r\n\r\n\tinArray: function( elem, arr, i ) {\r\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\r\n\t},\r\n\r\n\t// Support: Android <=4.0 only, PhantomJS 1 only\r\n\t// push.apply(_, arraylike) throws on ancient WebKit\r\n\tmerge: function( first, second ) {\r\n\t\tvar len = +second.length,\r\n\t\t\tj = 0,\r\n\t\t\ti = first.length;\r\n\r\n\t\tfor ( ; j < len; j++ ) {\r\n\t\t\tfirst[ i++ ] = second[ j ];\r\n\t\t}\r\n\r\n\t\tfirst.length = i;\r\n\r\n\t\treturn first;\r\n\t},\r\n\r\n\tgrep: function( elems, callback, invert ) {\r\n\t\tvar callbackInverse,\r\n\t\t\tmatches = [],\r\n\t\t\ti = 0,\r\n\t\t\tlength = elems.length,\r\n\t\t\tcallbackExpect = !invert;\r\n\r\n\t\t// Go through the array, only saving the items\r\n\t\t// that pass the validator function\r\n\t\tfor ( ; i < length; i++ ) {\r\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\r\n\t\t\tif ( callbackInverse !== callbackExpect ) {\r\n\t\t\t\tmatches.push( elems[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn matches;\r\n\t},\r\n\r\n\t// arg is for internal usage only\r\n\tmap: function( elems, callback, arg ) {\r\n\t\tvar length, value,\r\n\t\t\ti = 0,\r\n\t\t\tret = [];\r\n\r\n\t\t// Go through the array, translating each of the items to their new values\r\n\t\tif ( isArrayLike( elems ) ) {\r\n\t\t\tlength = elems.length;\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret.push( value );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Go through every key on the object,\r\n\t\t} else {\r\n\t\t\tfor ( i in elems ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret.push( value );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Flatten any nested arrays\r\n\t\treturn concat.apply( [], ret );\r\n\t},\r\n\r\n\t// A global GUID counter for objects\r\n\tguid: 1,\r\n\r\n\t// Bind a function to a context, optionally partially applying any\r\n\t// arguments.\r\n\tproxy: function( fn, context ) {\r\n\t\tvar tmp, args, proxy;\r\n\r\n\t\tif ( typeof context === \"string\" ) {\r\n\t\t\ttmp = fn[ context ];\r\n\t\t\tcontext = fn;\r\n\t\t\tfn = tmp;\r\n\t\t}\r\n\r\n\t\t// Quick check to determine if target is callable, in the spec\r\n\t\t// this throws a TypeError, but we will just return undefined.\r\n\t\tif ( !jQuery.isFunction( fn ) ) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Simulated bind\r\n\t\targs = slice.call( arguments, 2 );\r\n\t\tproxy = function() {\r\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\r\n\t\t};\r\n\r\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\r\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\r\n\r\n\t\treturn proxy;\r\n\t},\r\n\r\n\tnow: Date.now,\r\n\r\n\t// jQuery.support is not used in Core but other projects attach their\r\n\t// properties to it so it needs to exist.\r\n\tsupport: support\r\n} );\r\n\r\nif ( typeof Symbol === \"function\" ) {\r\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\r\n}\r\n\r\n// Populate the class2type map\r\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\r\nfunction( i, name ) {\r\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\r\n} );\r\n\r\nfunction isArrayLike( obj ) {\r\n\r\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\r\n\t// `in` check used to prevent JIT error (gh-2145)\r\n\t// hasOwn isn't used here due to false negatives\r\n\t// regarding Nodelist length in IE\r\n\tvar length = !!obj && \"length\" in obj && obj.length,\r\n\t\ttype = jQuery.type( obj );\r\n\r\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn type === \"array\" || length === 0 ||\r\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\r\n}\r\nvar Sizzle =\r\n/*!\r\n * Sizzle CSS Selector Engine v2.3.3\r\n * https://sizzlejs.com/\r\n *\r\n * Copyright jQuery Foundation and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2016-08-08\r\n */\r\n(function( window ) {\r\n\r\nvar i,\r\n\tsupport,\r\n\tExpr,\r\n\tgetText,\r\n\tisXML,\r\n\ttokenize,\r\n\tcompile,\r\n\tselect,\r\n\toutermostContext,\r\n\tsortInput,\r\n\thasDuplicate,\r\n\r\n\t// Local document vars\r\n\tsetDocument,\r\n\tdocument,\r\n\tdocElem,\r\n\tdocumentIsHTML,\r\n\trbuggyQSA,\r\n\trbuggyMatches,\r\n\tmatches,\r\n\tcontains,\r\n\r\n\t// Instance-specific data\r\n\texpando = \"sizzle\" + 1 * new Date(),\r\n\tpreferredDoc = window.document,\r\n\tdirruns = 0,\r\n\tdone = 0,\r\n\tclassCache = createCache(),\r\n\ttokenCache = createCache(),\r\n\tcompilerCache = createCache(),\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn 0;\r\n\t},\r\n\r\n\t// Instance methods\r\n\thasOwn = ({}).hasOwnProperty,\r\n\tarr = [],\r\n\tpop = arr.pop,\r\n\tpush_native = arr.push,\r\n\tpush = arr.push,\r\n\tslice = arr.slice,\r\n\t// Use a stripped-down indexOf as it's faster than native\r\n\t// https://jsperf.com/thor-indexof-vs-for/5\r\n\tindexOf = function( list, elem ) {\r\n\t\tvar i = 0,\r\n\t\t\tlen = list.length;\r\n\t\tfor ( ; i < len; i++ ) {\r\n\t\t\tif ( list[i] === elem ) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\r\n\r\n\t// Regular expressions\r\n\r\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\r\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\r\n\r\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\r\n\r\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\r\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\r\n\t\t// Operator (capture 2)\r\n\t\t\"*([*^$|!~]?=)\" + whitespace +\r\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\r\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\r\n\t\t\"*\\\\]\",\r\n\r\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\r\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\r\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\r\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\r\n\t\t// 2. simple (capture 6)\r\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\r\n\t\t// 3. anything else (capture 2)\r\n\t\t\".*\" +\r\n\t\t\")\\\\)|)\",\r\n\r\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\r\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\r\n\r\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\r\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\r\n\r\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\r\n\r\n\trpseudo = new RegExp( pseudos ),\r\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\r\n\r\n\tmatchExpr = {\r\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\r\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\r\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\r\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\r\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\r\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\r\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\r\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\r\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\r\n\t\t// For use in libraries implementing .is()\r\n\t\t// We use this for POS matching in `select`\r\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\r\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\r\n\t},\r\n\r\n\trinputs = /^(?:input|select|textarea|button)$/i,\r\n\trheader = /^h\\d$/i,\r\n\r\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\r\n\r\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\r\n\r\n\trsibling = /[+~]/,\r\n\r\n\t// CSS escapes\r\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\r\n\tfunescape = function( _, escaped, escapedWhitespace ) {\r\n\t\tvar high = \"0x\" + escaped - 0x10000;\r\n\t\t// NaN means non-codepoint\r\n\t\t// Support: Firefox<24\r\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\r\n\t\treturn high !== high || escapedWhitespace ?\r\n\t\t\tescaped :\r\n\t\t\thigh < 0 ?\r\n\t\t\t\t// BMP codepoint\r\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\r\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\r\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\r\n\t},\r\n\r\n\t// CSS string/identifier serialization\r\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\r\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\r\n\tfcssescape = function( ch, asCodePoint ) {\r\n\t\tif ( asCodePoint ) {\r\n\r\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\r\n\t\t\tif ( ch === \"\\0\" ) {\r\n\t\t\t\treturn \"\\uFFFD\";\r\n\t\t\t}\r\n\r\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\r\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\r\n\t\t}\r\n\r\n\t\t// Other potentially-special ASCII characters get backslash-escaped\r\n\t\treturn \"\\\\\" + ch;\r\n\t},\r\n\r\n\t// Used for iframes\r\n\t// See setDocument()\r\n\t// Removing the function wrapper causes a \"Permission Denied\"\r\n\t// error in IE\r\n\tunloadHandler = function() {\r\n\t\tsetDocument();\r\n\t},\r\n\r\n\tdisabledAncestor = addCombinator(\r\n\t\tfunction( elem ) {\r\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\r\n\t\t},\r\n\t\t{ dir: \"parentNode\", next: \"legend\" }\r\n\t);\r\n\r\n// Optimize for push.apply( _, NodeList )\r\ntry {\r\n\tpush.apply(\r\n\t\t(arr = slice.call( preferredDoc.childNodes )),\r\n\t\tpreferredDoc.childNodes\r\n\t);\r\n\t// Support: Android<4.0\r\n\t// Detect silently failing push.apply\r\n\tarr[ preferredDoc.childNodes.length ].nodeType;\r\n} catch ( e ) {\r\n\tpush = { apply: arr.length ?\r\n\r\n\t\t// Leverage slice if possible\r\n\t\tfunction( target, els ) {\r\n\t\t\tpush_native.apply( target, slice.call(els) );\r\n\t\t} :\r\n\r\n\t\t// Support: IE<9\r\n\t\t// Otherwise append directly\r\n\t\tfunction( target, els ) {\r\n\t\t\tvar j = target.length,\r\n\t\t\t\ti = 0;\r\n\t\t\t// Can't trust NodeList.length\r\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\r\n\t\t\ttarget.length = j - 1;\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction Sizzle( selector, context, results, seed ) {\r\n\tvar m, i, elem, nid, match, groups, newSelector,\r\n\t\tnewContext = context && context.ownerDocument,\r\n\r\n\t\t// nodeType defaults to 9, since context defaults to document\r\n\t\tnodeType = context ? context.nodeType : 9;\r\n\r\n\tresults = results || [];\r\n\r\n\t// Return early from calls with invalid selector or context\r\n\tif ( typeof selector !== \"string\" || !selector ||\r\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\r\n\r\n\t\treturn results;\r\n\t}\r\n\r\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\r\n\tif ( !seed ) {\r\n\r\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\r\n\t\t\tsetDocument( context );\r\n\t\t}\r\n\t\tcontext = context || document;\r\n\r\n\t\tif ( documentIsHTML ) {\r\n\r\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\r\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\r\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\r\n\r\n\t\t\t\t// ID selector\r\n\t\t\t\tif ( (m = match[1]) ) {\r\n\r\n\t\t\t\t\t// Document context\r\n\t\t\t\t\tif ( nodeType === 9 ) {\r\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\r\n\r\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\r\n\t\t\t\t\t\t\t// TODO: identify versions\r\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\r\n\t\t\t\t\t\t\tif ( elem.id === m ) {\r\n\t\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Element context\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\r\n\t\t\t\t\t\t// TODO: identify versions\r\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\r\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\r\n\t\t\t\t\t\t\tcontains( context, elem ) &&\r\n\t\t\t\t\t\t\telem.id === m ) {\r\n\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// Type selector\r\n\t\t\t\t} else if ( match[2] ) {\r\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\r\n\t\t\t\t\treturn results;\r\n\r\n\t\t\t\t// Class selector\r\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\r\n\t\t\t\t\tcontext.getElementsByClassName ) {\r\n\r\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Take advantage of querySelectorAll\r\n\t\t\tif ( support.qsa &&\r\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\r\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\r\n\r\n\t\t\t\tif ( nodeType !== 1 ) {\r\n\t\t\t\t\tnewContext = context;\r\n\t\t\t\t\tnewSelector = selector;\r\n\r\n\t\t\t\t// qSA looks outside Element context, which is not what we want\r\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\r\n\t\t\t\t// Support: IE <=8\r\n\t\t\t\t// Exclude object elements\r\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\r\n\r\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\r\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\r\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Prefix every selector in the list\r\n\t\t\t\t\tgroups = tokenize( selector );\r\n\t\t\t\t\ti = groups.length;\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewSelector = groups.join( \",\" );\r\n\r\n\t\t\t\t\t// Expand context for sibling selectors\r\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\r\n\t\t\t\t\t\tcontext;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( newSelector ) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tpush.apply( results,\r\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t} catch ( qsaError ) {\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tif ( nid === expando ) {\r\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// All others\r\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\r\n}\r\n\r\n/**\r\n * Create key-value caches of limited size\r\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\r\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n *\tdeleting the oldest entry\r\n */\r\nfunction createCache() {\r\n\tvar keys = [];\r\n\r\n\tfunction cache( key, value ) {\r\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\r\n\t\t\t// Only keep the most recent entries\r\n\t\t\tdelete cache[ keys.shift() ];\r\n\t\t}\r\n\t\treturn (cache[ key + \" \" ] = value);\r\n\t}\r\n\treturn cache;\r\n}\r\n\r\n/**\r\n * Mark a function for special use by Sizzle\r\n * @param {Function} fn The function to mark\r\n */\r\nfunction markFunction( fn ) {\r\n\tfn[ expando ] = true;\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * Support testing using an element\r\n * @param {Function} fn Passed the created element and returns a boolean result\r\n */\r\nfunction assert( fn ) {\r\n\tvar el = document.createElement(\"fieldset\");\r\n\r\n\ttry {\r\n\t\treturn !!fn( el );\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t} finally {\r\n\t\t// Remove from its parent by default\r\n\t\tif ( el.parentNode ) {\r\n\t\t\tel.parentNode.removeChild( el );\r\n\t\t}\r\n\t\t// release memory in IE\r\n\t\tel = null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Adds the same handler for all of the specified attrs\r\n * @param {String} attrs Pipe-separated list of attributes\r\n * @param {Function} handler The method that will be applied\r\n */\r\nfunction addHandle( attrs, handler ) {\r\n\tvar arr = attrs.split(\"|\"),\r\n\t\ti = arr.length;\r\n\r\n\twhile ( i-- ) {\r\n\t\tExpr.attrHandle[ arr[i] ] = handler;\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks document order of two siblings\r\n * @param {Element} a\r\n * @param {Element} b\r\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\r\n */\r\nfunction siblingCheck( a, b ) {\r\n\tvar cur = b && a,\r\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\r\n\t\t\ta.sourceIndex - b.sourceIndex;\r\n\r\n\t// Use IE sourceIndex if available on both nodes\r\n\tif ( diff ) {\r\n\t\treturn diff;\r\n\t}\r\n\r\n\t// Check if b follows a\r\n\tif ( cur ) {\r\n\t\twhile ( (cur = cur.nextSibling) ) {\r\n\t\t\tif ( cur === b ) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn a ? 1 : -1;\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for input types\r\n * @param {String} type\r\n */\r\nfunction createInputPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn name === \"input\" && elem.type === type;\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for buttons\r\n * @param {String} type\r\n */\r\nfunction createButtonPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for :enabled/:disabled\r\n * @param {Boolean} disabled true for :disabled; false for :enabled\r\n */\r\nfunction createDisabledPseudo( disabled ) {\r\n\r\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\r\n\treturn function( elem ) {\r\n\r\n\t\t// Only certain elements can match :enabled or :disabled\r\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\r\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\r\n\t\tif ( \"form\" in elem ) {\r\n\r\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\r\n\t\t\t// * listed form-associated elements in a disabled fieldset\r\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\r\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\r\n\t\t\t// * option elements in a disabled optgroup\r\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\r\n\t\t\t// All such elements have a \"form\" property.\r\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\r\n\r\n\t\t\t\t// Option elements defer to a parent optgroup if present\r\n\t\t\t\tif ( \"label\" in elem ) {\r\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\r\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn elem.disabled === disabled;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Support: IE 6 - 11\r\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\r\n\t\t\t\treturn elem.isDisabled === disabled ||\r\n\r\n\t\t\t\t\t// Where there is no isDisabled, check manually\r\n\t\t\t\t\t/* jshint -W018 */\r\n\t\t\t\t\telem.isDisabled !== !disabled &&\r\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\r\n\t\t\t}\r\n\r\n\t\t\treturn elem.disabled === disabled;\r\n\r\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\r\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\r\n\t\t// even exist on them, let alone have a boolean value.\r\n\t\t} else if ( \"label\" in elem ) {\r\n\t\t\treturn elem.disabled === disabled;\r\n\t\t}\r\n\r\n\t\t// Remaining elements are neither :enabled nor :disabled\r\n\t\treturn false;\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a function to use in pseudos for positionals\r\n * @param {Function} fn\r\n */\r\nfunction createPositionalPseudo( fn ) {\r\n\treturn markFunction(function( argument ) {\r\n\t\targument = +argument;\r\n\t\treturn markFunction(function( seed, matches ) {\r\n\t\t\tvar j,\r\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\r\n\t\t\t\ti = matchIndexes.length;\r\n\r\n\t\t\t// Match elements found at the specified indexes\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\r\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Checks a node for validity as a Sizzle context\r\n * @param {Element|Object=} context\r\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\r\n */\r\nfunction testContext( context ) {\r\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\r\n}\r\n\r\n// Expose support vars for convenience\r\nsupport = Sizzle.support = {};\r\n\r\n/**\r\n * Detects XML nodes\r\n * @param {Element|Object} elem An element or a document\r\n * @returns {Boolean} True iff elem is a non-HTML XML node\r\n */\r\nisXML = Sizzle.isXML = function( elem ) {\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833)\r\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\n/**\r\n * Sets document-related variables once based on the current document\r\n * @param {Element|Object} [doc] An element or document object to use to set the document\r\n * @returns {Object} Returns the current document\r\n */\r\nsetDocument = Sizzle.setDocument = function( node ) {\r\n\tvar hasCompare, subWindow,\r\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\r\n\r\n\t// Return early if doc is invalid or already selected\r\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\r\n\t\treturn document;\r\n\t}\r\n\r\n\t// Update global variables\r\n\tdocument = doc;\r\n\tdocElem = document.documentElement;\r\n\tdocumentIsHTML = !isXML( document );\r\n\r\n\t// Support: IE 9-11, Edge\r\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\r\n\tif ( preferredDoc !== document &&\r\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\r\n\r\n\t\t// Support: IE 11, Edge\r\n\t\tif ( subWindow.addEventListener ) {\r\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\r\n\r\n\t\t// Support: IE 9 - 10 only\r\n\t\t} else if ( subWindow.attachEvent ) {\r\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\r\n\t\t}\r\n\t}\r\n\r\n\t/* Attributes\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Support: IE<8\r\n\t// Verify that getAttribute really returns attributes and not properties\r\n\t// (excepting IE8 booleans)\r\n\tsupport.attributes = assert(function( el ) {\r\n\t\tel.className = \"i\";\r\n\t\treturn !el.getAttribute(\"className\");\r\n\t});\r\n\r\n\t/* getElement(s)By*\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Check if getElementsByTagName(\"*\") returns only elements\r\n\tsupport.getElementsByTagName = assert(function( el ) {\r\n\t\tel.appendChild( document.createComment(\"\") );\r\n\t\treturn !el.getElementsByTagName(\"*\").length;\r\n\t});\r\n\r\n\t// Support: IE<9\r\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\r\n\r\n\t// Support: IE<10\r\n\t// Check if getElementById returns elements by name\r\n\t// The broken getElementById methods don't pick up programmatically-set names,\r\n\t// so use a roundabout getElementsByName test\r\n\tsupport.getById = assert(function( el ) {\r\n\t\tdocElem.appendChild( el ).id = expando;\r\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\r\n\t});\r\n\r\n\t// ID filter and find\r\n\tif ( support.getById ) {\r\n\t\tExpr.filter[\"ID\"] = function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\t\tExpr.find[\"ID\"] = function( id, context ) {\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\r\n\t\t\t\tvar elem = context.getElementById( id );\r\n\t\t\t\treturn elem ? [ elem ] : [];\r\n\t\t\t}\r\n\t\t};\r\n\t} else {\r\n\t\tExpr.filter[\"ID\"] =  function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\r\n\t\t\t\t\telem.getAttributeNode(\"id\");\r\n\t\t\t\treturn node && node.value === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\t// Support: IE 6 - 7 only\r\n\t\t// getElementById is not reliable as a find shortcut\r\n\t\tExpr.find[\"ID\"] = function( id, context ) {\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\r\n\t\t\t\tvar node, i, elems,\r\n\t\t\t\t\telem = context.getElementById( id );\r\n\r\n\t\t\t\tif ( elem ) {\r\n\r\n\t\t\t\t\t// Verify the id attribute\r\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\r\n\t\t\t\t\tif ( node && node.value === id ) {\r\n\t\t\t\t\t\treturn [ elem ];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Fall back on getElementsByName\r\n\t\t\t\t\telems = context.getElementsByName( id );\r\n\t\t\t\t\ti = 0;\r\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\r\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\r\n\t\t\t\t\t\tif ( node && node.value === id ) {\r\n\t\t\t\t\t\t\treturn [ elem ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// Tag\r\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\r\n\t\tfunction( tag, context ) {\r\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\r\n\t\t\t\treturn context.getElementsByTagName( tag );\r\n\r\n\t\t\t// DocumentFragment nodes don't have gEBTN\r\n\t\t\t} else if ( support.qsa ) {\r\n\t\t\t\treturn context.querySelectorAll( tag );\r\n\t\t\t}\r\n\t\t} :\r\n\r\n\t\tfunction( tag, context ) {\r\n\t\t\tvar elem,\r\n\t\t\t\ttmp = [],\r\n\t\t\t\ti = 0,\r\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\r\n\t\t\t\tresults = context.getElementsByTagName( tag );\r\n\r\n\t\t\t// Filter out possible comments\r\n\t\t\tif ( tag === \"*\" ) {\r\n\t\t\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\ttmp.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tmp;\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t};\r\n\r\n\t// Class\r\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\r\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\r\n\t\t\treturn context.getElementsByClassName( className );\r\n\t\t}\r\n\t};\r\n\r\n\t/* QSA/matchesSelector\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// QSA and matchesSelector support\r\n\r\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n\trbuggyMatches = [];\r\n\r\n\t// qSa(:focus) reports false when true (Chrome 21)\r\n\t// We allow this because of a bug in IE8/9 that throws an error\r\n\t// whenever `document.activeElement` is accessed on an iframe\r\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n\t// See https://bugs.jquery.com/ticket/13378\r\n\trbuggyQSA = [];\r\n\r\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\r\n\t\t// Build QSA regex\r\n\t\t// Regex strategy adopted from Diego Perini\r\n\t\tassert(function( el ) {\r\n\t\t\t// Select is set to empty string on purpose\r\n\t\t\t// This is to test IE's treatment of not explicitly\r\n\t\t\t// setting a boolean content attribute,\r\n\t\t\t// since its presence should be enough\r\n\t\t\t// https://bugs.jquery.com/ticket/12359\r\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\r\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\r\n\t\t\t\t\"<option selected=''></option></select>\";\r\n\r\n\t\t\t// Support: IE8, Opera 11-12.16\r\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\r\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\r\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\r\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Support: IE8\r\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\r\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\r\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\r\n\t\t\t\trbuggyQSA.push(\"~=\");\r\n\t\t\t}\r\n\r\n\t\t\t// Webkit/Opera - :checked should return selected option elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\r\n\t\t\t\trbuggyQSA.push(\":checked\");\r\n\t\t\t}\r\n\r\n\t\t\t// Support: Safari 8+, iOS 8+\r\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\r\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\r\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\r\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tassert(function( el ) {\r\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\r\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\r\n\r\n\t\t\t// Support: Windows 8 Native Apps\r\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\r\n\t\t\tvar input = document.createElement(\"input\");\r\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\r\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\r\n\r\n\t\t\t// Support: IE8\r\n\t\t\t// Enforce case-sensitivity of name attribute\r\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\r\n\t\t\t}\r\n\r\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\r\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Support: IE9-11+\r\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\r\n\t\t\tdocElem.appendChild( el ).disabled = true;\r\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\r\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\r\n\t\t\tel.querySelectorAll(\"*,:x\");\r\n\t\t\trbuggyQSA.push(\",.*:\");\r\n\t\t});\r\n\t}\r\n\r\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\r\n\t\tdocElem.webkitMatchesSelector ||\r\n\t\tdocElem.mozMatchesSelector ||\r\n\t\tdocElem.oMatchesSelector ||\r\n\t\tdocElem.msMatchesSelector) )) ) {\r\n\r\n\t\tassert(function( el ) {\r\n\t\t\t// Check to see if it's possible to do matchesSelector\r\n\t\t\t// on a disconnected node (IE 9)\r\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\r\n\r\n\t\t\t// This should fail with an exception\r\n\t\t\t// Gecko does not error, returns false instead\r\n\t\t\tmatches.call( el, \"[s!='']:x\" );\r\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\r\n\t\t});\r\n\t}\r\n\r\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\r\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\r\n\r\n\t/* Contains\r\n\t---------------------------------------------------------------------- */\r\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\r\n\r\n\t// Element contains another\r\n\t// Purposefully self-exclusive\r\n\t// As in, an element does not contain itself\r\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\r\n\t\tfunction( a, b ) {\r\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\r\n\t\t\t\tbup = b && b.parentNode;\r\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\r\n\t\t\t\tadown.contains ?\r\n\t\t\t\t\tadown.contains( bup ) :\r\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\r\n\t\t\t));\r\n\t\t} :\r\n\t\tfunction( a, b ) {\r\n\t\t\tif ( b ) {\r\n\t\t\t\twhile ( (b = b.parentNode) ) {\r\n\t\t\t\t\tif ( b === a ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t/* Sorting\r\n\t---------------------------------------------------------------------- */\r\n\r\n\t// Document order sorting\r\n\tsortOrder = hasCompare ?\r\n\tfunction( a, b ) {\r\n\r\n\t\t// Flag for duplicate removal\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Sort on method existence if only one input has compareDocumentPosition\r\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\r\n\t\tif ( compare ) {\r\n\t\t\treturn compare;\r\n\t\t}\r\n\r\n\t\t// Calculate position if both inputs belong to the same document\r\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\r\n\t\t\ta.compareDocumentPosition( b ) :\r\n\r\n\t\t\t// Otherwise we know they are disconnected\r\n\t\t\t1;\r\n\r\n\t\t// Disconnected nodes\r\n\t\tif ( compare & 1 ||\r\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\r\n\r\n\t\t\t// Choose the first element that is related to our preferred document\r\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\r\n\t\t\t// Maintain original order\r\n\t\t\treturn sortInput ?\r\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\r\n\t\t\t\t0;\r\n\t\t}\r\n\r\n\t\treturn compare & 4 ? -1 : 1;\r\n\t} :\r\n\tfunction( a, b ) {\r\n\t\t// Exit early if the nodes are identical\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\taup = a.parentNode,\r\n\t\t\tbup = b.parentNode,\r\n\t\t\tap = [ a ],\r\n\t\t\tbp = [ b ];\r\n\r\n\t\t// Parentless nodes are either documents or disconnected\r\n\t\tif ( !aup || !bup ) {\r\n\t\t\treturn a === document ? -1 :\r\n\t\t\t\tb === document ? 1 :\r\n\t\t\t\taup ? -1 :\r\n\t\t\t\tbup ? 1 :\r\n\t\t\t\tsortInput ?\r\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\r\n\t\t\t\t0;\r\n\r\n\t\t// If the nodes are siblings, we can do a quick check\r\n\t\t} else if ( aup === bup ) {\r\n\t\t\treturn siblingCheck( a, b );\r\n\t\t}\r\n\r\n\t\t// Otherwise we need full lists of their ancestors for comparison\r\n\t\tcur = a;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tap.unshift( cur );\r\n\t\t}\r\n\t\tcur = b;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tbp.unshift( cur );\r\n\t\t}\r\n\r\n\t\t// Walk down the tree looking for a discrepancy\r\n\t\twhile ( ap[i] === bp[i] ) {\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn i ?\r\n\t\t\t// Do a sibling check if the nodes have a common ancestor\r\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\r\n\r\n\t\t\t// Otherwise nodes in our document sort first\r\n\t\t\tap[i] === preferredDoc ? -1 :\r\n\t\t\tbp[i] === preferredDoc ? 1 :\r\n\t\t\t0;\r\n\t};\r\n\r\n\treturn document;\r\n};\r\n\r\nSizzle.matches = function( expr, elements ) {\r\n\treturn Sizzle( expr, null, null, elements );\r\n};\r\n\r\nSizzle.matchesSelector = function( elem, expr ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\t// Make sure that attribute selectors are quoted\r\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\r\n\r\n\tif ( support.matchesSelector && documentIsHTML &&\r\n\t\t!compilerCache[ expr + \" \" ] &&\r\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\r\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\r\n\r\n\t\ttry {\r\n\t\t\tvar ret = matches.call( elem, expr );\r\n\r\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\r\n\t\t\tif ( ret || support.disconnectedMatch ||\r\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\r\n\t\t\t\t\t// fragment in IE 9\r\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t} catch (e) {}\r\n\t}\r\n\r\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\r\n};\r\n\r\nSizzle.contains = function( context, elem ) {\r\n\t// Set document vars if needed\r\n\tif ( ( context.ownerDocument || context ) !== document ) {\r\n\t\tsetDocument( context );\r\n\t}\r\n\treturn contains( context, elem );\r\n};\r\n\r\nSizzle.attr = function( elem, name ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\r\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\r\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\r\n\t\t\tfn( elem, name, !documentIsHTML ) :\r\n\t\t\tundefined;\r\n\r\n\treturn val !== undefined ?\r\n\t\tval :\r\n\t\tsupport.attributes || !documentIsHTML ?\r\n\t\t\telem.getAttribute( name ) :\r\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\r\n\t\t\t\tval.value :\r\n\t\t\t\tnull;\r\n};\r\n\r\nSizzle.escape = function( sel ) {\r\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\r\n};\r\n\r\n/**\r\n * Document sorting and removing duplicates\r\n * @param {ArrayLike} results\r\n */\r\nSizzle.uniqueSort = function( results ) {\r\n\tvar elem,\r\n\t\tduplicates = [],\r\n\t\tj = 0,\r\n\t\ti = 0;\r\n\r\n\t// Unless we *know* we can detect duplicates, assume their presence\r\n\thasDuplicate = !support.detectDuplicates;\r\n\tsortInput = !support.sortStable && results.slice( 0 );\r\n\tresults.sort( sortOrder );\r\n\r\n\tif ( hasDuplicate ) {\r\n\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\tif ( elem === results[ i ] ) {\r\n\t\t\t\tj = duplicates.push( i );\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile ( j-- ) {\r\n\t\t\tresults.splice( duplicates[ j ], 1 );\r\n\t\t}\r\n\t}\r\n\r\n\t// Clear input after sorting to release objects\r\n\t// See https://github.com/jquery/sizzle/pull/225\r\n\tsortInput = null;\r\n\r\n\treturn results;\r\n};\r\n\r\n/**\r\n * Utility function for retrieving the text value of an array of DOM nodes\r\n * @param {Array|Element} elem\r\n */\r\ngetText = Sizzle.getText = function( elem ) {\r\n\tvar node,\r\n\t\tret = \"\",\r\n\t\ti = 0,\r\n\t\tnodeType = elem.nodeType;\r\n\r\n\tif ( !nodeType ) {\r\n\t\t// If no nodeType, this is expected to be an array\r\n\t\twhile ( (node = elem[i++]) ) {\r\n\t\t\t// Do not traverse comment nodes\r\n\t\t\tret += getText( node );\r\n\t\t}\r\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\r\n\t\t// Use textContent for elements\r\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\r\n\t\tif ( typeof elem.textContent === \"string\" ) {\r\n\t\t\treturn elem.textContent;\r\n\t\t} else {\r\n\t\t\t// Traverse its children\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tret += getText( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\r\n\t\treturn elem.nodeValue;\r\n\t}\r\n\t// Do not include comment or processing instruction nodes\r\n\r\n\treturn ret;\r\n};\r\n\r\nExpr = Sizzle.selectors = {\r\n\r\n\t// Can be adjusted by the user\r\n\tcacheLength: 50,\r\n\r\n\tcreatePseudo: markFunction,\r\n\r\n\tmatch: matchExpr,\r\n\r\n\tattrHandle: {},\r\n\r\n\tfind: {},\r\n\r\n\trelative: {\r\n\t\t\">\": { dir: \"parentNode\", first: true },\r\n\t\t\" \": { dir: \"parentNode\" },\r\n\t\t\"+\": { dir: \"previousSibling\", first: true },\r\n\t\t\"~\": { dir: \"previousSibling\" }\r\n\t},\r\n\r\n\tpreFilter: {\r\n\t\t\"ATTR\": function( match ) {\r\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\r\n\r\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\r\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match.slice( 0, 4 );\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( match ) {\r\n\t\t\t/* matches from matchExpr[\"CHILD\"]\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 what (child|of-type)\r\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t5 sign of xn-component\r\n\t\t\t\t6 x of xn-component\r\n\t\t\t\t7 sign of y-component\r\n\t\t\t\t8 y of y-component\r\n\t\t\t*/\r\n\t\t\tmatch[1] = match[1].toLowerCase();\r\n\r\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\r\n\t\t\t\t// nth-* requires argument\r\n\t\t\t\tif ( !match[3] ) {\r\n\t\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\r\n\t\t\t\t// remember that false/true cast respectively to 0/1\r\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\r\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\r\n\r\n\t\t\t// other types prohibit arguments\r\n\t\t\t} else if ( match[3] ) {\r\n\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( match ) {\r\n\t\t\tvar excess,\r\n\t\t\t\tunquoted = !match[6] && match[2];\r\n\r\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// Accept quoted arguments as-is\r\n\t\t\tif ( match[3] ) {\r\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\r\n\r\n\t\t\t// Strip excess characters from unquoted arguments\r\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\r\n\t\t\t\t// Get excess from tokenize (recursively)\r\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\r\n\t\t\t\t// advance to the next closing parenthesis\r\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\r\n\r\n\t\t\t\t// excess is a negative index\r\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\r\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\r\n\t\t\t}\r\n\r\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\r\n\t\t\treturn match.slice( 0, 3 );\r\n\t\t}\r\n\t},\r\n\r\n\tfilter: {\r\n\r\n\t\t\"TAG\": function( nodeNameSelector ) {\r\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn nodeNameSelector === \"*\" ?\r\n\t\t\t\tfunction() { return true; } :\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CLASS\": function( className ) {\r\n\t\t\tvar pattern = classCache[ className + \" \" ];\r\n\r\n\t\t\treturn pattern ||\r\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\r\n\t\t\t\tclassCache( className, function( elem ) {\r\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\r\n\t\t\t\t});\r\n\t\t},\r\n\r\n\t\t\"ATTR\": function( name, operator, check ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar result = Sizzle.attr( elem, name );\r\n\r\n\t\t\t\tif ( result == null ) {\r\n\t\t\t\t\treturn operator === \"!=\";\r\n\t\t\t\t}\r\n\t\t\t\tif ( !operator ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += \"\";\r\n\r\n\t\t\t\treturn operator === \"=\" ? result === check :\r\n\t\t\t\t\toperator === \"!=\" ? result !== check :\r\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\r\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\r\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\r\n\t\t\t\t\tfalse;\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\r\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\r\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\r\n\t\t\t\tofType = what === \"of-type\";\r\n\r\n\t\t\treturn first === 1 && last === 0 ?\r\n\r\n\t\t\t\t// Shortcut for :nth-*(n)\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn !!elem.parentNode;\r\n\t\t\t\t} :\r\n\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\r\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\r\n\t\t\t\t\t\tparent = elem.parentNode,\r\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\r\n\t\t\t\t\t\tuseCache = !xml && !ofType,\r\n\t\t\t\t\t\tdiff = false;\r\n\r\n\t\t\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\r\n\t\t\t\t\t\tif ( simple ) {\r\n\t\t\t\t\t\t\twhile ( dir ) {\r\n\t\t\t\t\t\t\t\tnode = elem;\r\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\r\n\t\t\t\t\t\t\t\t\tif ( ofType ?\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\r\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\r\n\r\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\r\n\t\t\t\t\t\tif ( forward && useCache ) {\r\n\r\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\r\n\r\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\r\n\t\t\t\t\t\t\tnode = parent;\r\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\r\n\r\n\t\t\t\t\t\t\t// Support: IE <9 only\r\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\r\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\r\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\r\n\r\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\r\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\r\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\r\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\r\n\r\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\r\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\r\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\r\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\r\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Use previously-cached element index if available\r\n\t\t\t\t\t\t\tif ( useCache ) {\r\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\r\n\t\t\t\t\t\t\t\tnode = elem;\r\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\r\n\r\n\t\t\t\t\t\t\t\t// Support: IE <9 only\r\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\r\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\r\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\r\n\r\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\r\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\r\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// xml :nth-child(...)\r\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n\t\t\t\t\t\t\tif ( diff === false ) {\r\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\r\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\r\n\t\t\t\t\t\t\t\t\t\t++diff ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\r\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\r\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\r\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\r\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\r\n\t\t\t\t\t\tdiff -= last;\r\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( pseudo, argument ) {\r\n\t\t\t// pseudo-class names are case-insensitive\r\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\r\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n\t\t\t// Remember that setFilters inherits from pseudos\r\n\t\t\tvar args,\r\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\r\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\r\n\r\n\t\t\t// The user may use createPseudo to indicate that\r\n\t\t\t// arguments are needed to create the filter function\r\n\t\t\t// just as Sizzle does\r\n\t\t\tif ( fn[ expando ] ) {\r\n\t\t\t\treturn fn( argument );\r\n\t\t\t}\r\n\r\n\t\t\t// But maintain support for old signatures\r\n\t\t\tif ( fn.length > 1 ) {\r\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\r\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\r\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\r\n\t\t\t\t\t\tvar idx,\r\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\r\n\t\t\t\t\t\t\ti = matched.length;\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\r\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\t\treturn fn( elem, 0, args );\r\n\t\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn fn;\r\n\t\t}\r\n\t},\r\n\r\n\tpseudos: {\r\n\t\t// Potentially complex pseudos\r\n\t\t\"not\": markFunction(function( selector ) {\r\n\t\t\t// Trim the selector passed to compile\r\n\t\t\t// to avoid treating leading and trailing\r\n\t\t\t// spaces as combinators\r\n\t\t\tvar input = [],\r\n\t\t\t\tresults = [],\r\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\r\n\r\n\t\t\treturn matcher[ expando ] ?\r\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\r\n\t\t\t\t\tvar elem,\r\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\r\n\t\t\t\t\t\ti = seed.length;\r\n\r\n\t\t\t\t\t// Match elements unmatched by `matcher`\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}) :\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tinput[0] = elem;\r\n\t\t\t\t\tmatcher( input, null, xml, results );\r\n\t\t\t\t\t// Don't keep the element (issue #299)\r\n\t\t\t\t\tinput[0] = null;\r\n\t\t\t\t\treturn !results.pop();\r\n\t\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"has\": markFunction(function( selector ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"contains\": markFunction(function( text ) {\r\n\t\t\ttext = text.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// \"Whether an element is represented by a :lang() selector\r\n\t\t// is based solely on the element's language value\r\n\t\t// being equal to the identifier C,\r\n\t\t// or beginning with the identifier C immediately followed by \"-\".\r\n\t\t// The matching of C against the element's language value is performed case-insensitively.\r\n\t\t// The identifier C does not have to be a valid language name.\"\r\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\r\n\t\t\"lang\": markFunction( function( lang ) {\r\n\t\t\t// lang value must be a valid identifier\r\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\r\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\r\n\t\t\t}\r\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar elemLang;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\r\n\t\t\t\t\t\telem.lang :\r\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\r\n\r\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\r\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// Miscellaneous\r\n\t\t\"target\": function( elem ) {\r\n\t\t\tvar hash = window.location && window.location.hash;\r\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\r\n\t\t},\r\n\r\n\t\t\"root\": function( elem ) {\r\n\t\t\treturn elem === docElem;\r\n\t\t},\r\n\r\n\t\t\"focus\": function( elem ) {\r\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\r\n\t\t},\r\n\r\n\t\t// Boolean properties\r\n\t\t\"enabled\": createDisabledPseudo( false ),\r\n\t\t\"disabled\": createDisabledPseudo( true ),\r\n\r\n\t\t\"checked\": function( elem ) {\r\n\t\t\t// In CSS3, :checked should return both checked and selected elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\r\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\r\n\t\t},\r\n\r\n\t\t\"selected\": function( elem ) {\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\telem.parentNode.selectedIndex;\r\n\t\t\t}\r\n\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\r\n\t\t// Contents\r\n\t\t\"empty\": function( elem ) {\r\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\r\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\r\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\r\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tif ( elem.nodeType < 6 ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\"parent\": function( elem ) {\r\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\r\n\t\t},\r\n\r\n\t\t// Element/input types\r\n\t\t\"header\": function( elem ) {\r\n\t\t\treturn rheader.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"input\": function( elem ) {\r\n\t\t\treturn rinputs.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"button\": function( elem ) {\r\n\t\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n\t\t},\r\n\r\n\t\t\"text\": function( elem ) {\r\n\t\t\tvar attr;\r\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\r\n\t\t\t\telem.type === \"text\" &&\r\n\r\n\t\t\t\t// Support: IE<8\r\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\r\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\r\n\t\t},\r\n\r\n\t\t// Position-in-collection\r\n\t\t\"first\": createPositionalPseudo(function() {\r\n\t\t\treturn [ 0 ];\r\n\t\t}),\r\n\r\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\treturn [ length - 1 ];\r\n\t\t}),\r\n\r\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\r\n\t\t}),\r\n\r\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 1;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; --i >= 0; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; ++i < length; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t})\r\n\t}\r\n};\r\n\r\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\r\n\r\n// Add button/input type pseudos\r\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\r\n\tExpr.pseudos[ i ] = createInputPseudo( i );\r\n}\r\nfor ( i in { submit: true, reset: true } ) {\r\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\r\n}\r\n\r\n// Easy API for creating new setFilters\r\nfunction setFilters() {}\r\nsetFilters.prototype = Expr.filters = Expr.pseudos;\r\nExpr.setFilters = new setFilters();\r\n\r\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\r\n\tvar matched, match, tokens, type,\r\n\t\tsoFar, groups, preFilters,\r\n\t\tcached = tokenCache[ selector + \" \" ];\r\n\r\n\tif ( cached ) {\r\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\r\n\t}\r\n\r\n\tsoFar = selector;\r\n\tgroups = [];\r\n\tpreFilters = Expr.preFilter;\r\n\r\n\twhile ( soFar ) {\r\n\r\n\t\t// Comma and first run\r\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\r\n\t\t\tif ( match ) {\r\n\t\t\t\t// Don't consume trailing commas as valid\r\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\r\n\t\t\t}\r\n\t\t\tgroups.push( (tokens = []) );\r\n\t\t}\r\n\r\n\t\tmatched = false;\r\n\r\n\t\t// Combinators\r\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\r\n\t\t\tmatched = match.shift();\r\n\t\t\ttokens.push({\r\n\t\t\t\tvalue: matched,\r\n\t\t\t\t// Cast descendant combinators to space\r\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\r\n\t\t\t});\r\n\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t}\r\n\r\n\t\t// Filters\r\n\t\tfor ( type in Expr.filter ) {\r\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\r\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\r\n\t\t\t\tmatched = match.shift();\r\n\t\t\t\ttokens.push({\r\n\t\t\t\t\tvalue: matched,\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tmatches: match\r\n\t\t\t\t});\r\n\t\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !matched ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the length of the invalid excess\r\n\t// if we're just parsing\r\n\t// Otherwise, throw an error or return tokens\r\n\treturn parseOnly ?\r\n\t\tsoFar.length :\r\n\t\tsoFar ?\r\n\t\t\tSizzle.error( selector ) :\r\n\t\t\t// Cache the tokens\r\n\t\t\ttokenCache( selector, groups ).slice( 0 );\r\n};\r\n\r\nfunction toSelector( tokens ) {\r\n\tvar i = 0,\r\n\t\tlen = tokens.length,\r\n\t\tselector = \"\";\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tselector += tokens[i].value;\r\n\t}\r\n\treturn selector;\r\n}\r\n\r\nfunction addCombinator( matcher, combinator, base ) {\r\n\tvar dir = combinator.dir,\r\n\t\tskip = combinator.next,\r\n\t\tkey = skip || dir,\r\n\t\tcheckNonElements = base && key === \"parentNode\",\r\n\t\tdoneName = done++;\r\n\r\n\treturn combinator.first ?\r\n\t\t// Check against closest ancestor/preceding element\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\treturn matcher( elem, context, xml );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t} :\r\n\r\n\t\t// Check against all ancestor/preceding elements\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar oldCache, uniqueCache, outerCache,\r\n\t\t\t\tnewCache = [ dirruns, doneName ];\r\n\r\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\r\n\t\t\tif ( xml ) {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\r\n\r\n\t\t\t\t\t\t// Support: IE <9 only\r\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\r\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\r\n\r\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\r\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\r\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\r\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\r\n\r\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\r\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\r\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\r\n\r\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\r\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n}\r\n\r\nfunction elementMatcher( matchers ) {\r\n\treturn matchers.length > 1 ?\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar i = matchers.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} :\r\n\t\tmatchers[0];\r\n}\r\n\r\nfunction multipleContexts( selector, contexts, results ) {\r\n\tvar i = 0,\r\n\t\tlen = contexts.length;\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tSizzle( selector, contexts[i], results );\r\n\t}\r\n\treturn results;\r\n}\r\n\r\nfunction condense( unmatched, map, filter, context, xml ) {\r\n\tvar elem,\r\n\t\tnewUnmatched = [],\r\n\t\ti = 0,\r\n\t\tlen = unmatched.length,\r\n\t\tmapped = map != null;\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\r\n\t\t\t\tnewUnmatched.push( elem );\r\n\t\t\t\tif ( mapped ) {\r\n\t\t\t\t\tmap.push( i );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn newUnmatched;\r\n}\r\n\r\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\r\n\tif ( postFilter && !postFilter[ expando ] ) {\r\n\t\tpostFilter = setMatcher( postFilter );\r\n\t}\r\n\tif ( postFinder && !postFinder[ expando ] ) {\r\n\t\tpostFinder = setMatcher( postFinder, postSelector );\r\n\t}\r\n\treturn markFunction(function( seed, results, context, xml ) {\r\n\t\tvar temp, i, elem,\r\n\t\t\tpreMap = [],\r\n\t\t\tpostMap = [],\r\n\t\t\tpreexisting = results.length,\r\n\r\n\t\t\t// Get initial elements from seed or context\r\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\r\n\r\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\r\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\r\n\t\t\t\telems,\r\n\r\n\t\t\tmatcherOut = matcher ?\r\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\r\n\r\n\t\t\t\t\t// ...intermediate processing is necessary\r\n\t\t\t\t\t[] :\r\n\r\n\t\t\t\t\t// ...otherwise use results directly\r\n\t\t\t\t\tresults :\r\n\t\t\t\tmatcherIn;\r\n\r\n\t\t// Find primary matches\r\n\t\tif ( matcher ) {\r\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\r\n\t\t}\r\n\r\n\t\t// Apply postFilter\r\n\t\tif ( postFilter ) {\r\n\t\t\ttemp = condense( matcherOut, postMap );\r\n\t\t\tpostFilter( temp, [], context, xml );\r\n\r\n\t\t\t// Un-match failing elements by moving them back to matcherIn\r\n\t\t\ti = temp.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( (elem = temp[i]) ) {\r\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( seed ) {\r\n\t\t\tif ( postFinder || preFilter ) {\r\n\t\t\t\tif ( postFinder ) {\r\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n\t\t\t\t\ttemp = [];\r\n\t\t\t\t\ti = matcherOut.length;\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\r\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\r\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\r\n\t\t\t\ti = matcherOut.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\r\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\r\n\r\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Add elements to results, through postFinder if defined\r\n\t\t} else {\r\n\t\t\tmatcherOut = condense(\r\n\t\t\t\tmatcherOut === results ?\r\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\r\n\t\t\t\t\tmatcherOut\r\n\t\t\t);\r\n\t\t\tif ( postFinder ) {\r\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\r\n\t\t\t} else {\r\n\t\t\t\tpush.apply( results, matcherOut );\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction matcherFromTokens( tokens ) {\r\n\tvar checkContext, matcher, j,\r\n\t\tlen = tokens.length,\r\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\r\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\r\n\t\ti = leadingRelative ? 1 : 0,\r\n\r\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\r\n\t\tmatchContext = addCombinator( function( elem ) {\r\n\t\t\treturn elem === checkContext;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchAnyContext = addCombinator( function( elem ) {\r\n\t\t\treturn indexOf( checkContext, elem ) > -1;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchers = [ function( elem, context, xml ) {\r\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\r\n\t\t\t\t(checkContext = context).nodeType ?\r\n\t\t\t\t\tmatchContext( elem, context, xml ) :\r\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\r\n\t\t\t// Avoid hanging onto element (issue #299)\r\n\t\t\tcheckContext = null;\r\n\t\t\treturn ret;\r\n\t\t} ];\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\r\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\r\n\t\t} else {\r\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\r\n\r\n\t\t\t// Return special upon seeing a positional matcher\r\n\t\t\tif ( matcher[ expando ] ) {\r\n\t\t\t\t// Find the next relative operator (if any) for proper handling\r\n\t\t\t\tj = ++i;\r\n\t\t\t\tfor ( ; j < len; j++ ) {\r\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn setMatcher(\r\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\r\n\t\t\t\t\ti > 1 && toSelector(\r\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\r\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\r\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\r\n\t\t\t\t\tmatcher,\r\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\r\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\r\n\t\t\t\t\tj < len && toSelector( tokens )\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tmatchers.push( matcher );\r\n\t\t}\r\n\t}\r\n\r\n\treturn elementMatcher( matchers );\r\n}\r\n\r\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\r\n\tvar bySet = setMatchers.length > 0,\r\n\t\tbyElement = elementMatchers.length > 0,\r\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\r\n\t\t\tvar elem, j, matcher,\r\n\t\t\t\tmatchedCount = 0,\r\n\t\t\t\ti = \"0\",\r\n\t\t\t\tunmatched = seed && [],\r\n\t\t\t\tsetMatched = [],\r\n\t\t\t\tcontextBackup = outermostContext,\r\n\t\t\t\t// We must always have either seed elements or outermost context\r\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\r\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\r\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\r\n\t\t\t\tlen = elems.length;\r\n\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\toutermostContext = context === document || context || outermost;\r\n\t\t\t}\r\n\r\n\t\t\t// Add elements passing elementMatchers directly to results\r\n\t\t\t// Support: IE<9, Safari\r\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\r\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\r\n\t\t\t\tif ( byElement && elem ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\r\n\t\t\t\t\t\tsetDocument( elem );\r\n\t\t\t\t\t\txml = !documentIsHTML;\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( outermost ) {\r\n\t\t\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Track unmatched elements for set filters\r\n\t\t\t\tif ( bySet ) {\r\n\t\t\t\t\t// They will have gone through all possible matchers\r\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\r\n\t\t\t\t\t\tmatchedCount--;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Lengthen the array for every element, matched or not\r\n\t\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t\tunmatched.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\r\n\t\t\t// makes the latter nonnegative.\r\n\t\t\tmatchedCount += i;\r\n\r\n\t\t\t// Apply set filters to unmatched elements\r\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\r\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\r\n\t\t\t// no element matchers and no seed.\r\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\r\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\r\n\t\t\t// numerically zero.\r\n\t\t\tif ( bySet && i !== matchedCount ) {\r\n\t\t\t\tj = 0;\r\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\r\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\r\n\t\t\t\t\tif ( matchedCount > 0 ) {\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\r\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\r\n\t\t\t\t\tsetMatched = condense( setMatched );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add matches to results\r\n\t\t\t\tpush.apply( results, setMatched );\r\n\r\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\r\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\r\n\r\n\t\t\t\t\tSizzle.uniqueSort( results );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Override manipulation of globals by nested matchers\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\toutermostContext = contextBackup;\r\n\t\t\t}\r\n\r\n\t\t\treturn unmatched;\r\n\t\t};\r\n\r\n\treturn bySet ?\r\n\t\tmarkFunction( superMatcher ) :\r\n\t\tsuperMatcher;\r\n}\r\n\r\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\r\n\tvar i,\r\n\t\tsetMatchers = [],\r\n\t\telementMatchers = [],\r\n\t\tcached = compilerCache[ selector + \" \" ];\r\n\r\n\tif ( !cached ) {\r\n\t\t// Generate a function of recursive functions that can be used to check each element\r\n\t\tif ( !match ) {\r\n\t\t\tmatch = tokenize( selector );\r\n\t\t}\r\n\t\ti = match.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tcached = matcherFromTokens( match[i] );\r\n\t\t\tif ( cached[ expando ] ) {\r\n\t\t\t\tsetMatchers.push( cached );\r\n\t\t\t} else {\r\n\t\t\t\telementMatchers.push( cached );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Cache the compiled function\r\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\r\n\r\n\t\t// Save selector and tokenization\r\n\t\tcached.selector = selector;\r\n\t}\r\n\treturn cached;\r\n};\r\n\r\n/**\r\n * A low-level selection function that works with Sizzle's compiled\r\n *  selector functions\r\n * @param {String|Function} selector A selector or a pre-compiled\r\n *  selector function built with Sizzle.compile\r\n * @param {Element} context\r\n * @param {Array} [results]\r\n * @param {Array} [seed] A set of elements to match against\r\n */\r\nselect = Sizzle.select = function( selector, context, results, seed ) {\r\n\tvar i, tokens, token, type, find,\r\n\t\tcompiled = typeof selector === \"function\" && selector,\r\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\r\n\r\n\tresults = results || [];\r\n\r\n\t// Try to minimize operations if there is only one selector in the list and no seed\r\n\t// (the latter of which guarantees us context)\r\n\tif ( match.length === 1 ) {\r\n\r\n\t\t// Reduce context if the leading compound selector is an ID\r\n\t\ttokens = match[0] = match[0].slice( 0 );\r\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\r\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\r\n\r\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\r\n\t\t\tif ( !context ) {\r\n\t\t\t\treturn results;\r\n\r\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\r\n\t\t\t} else if ( compiled ) {\r\n\t\t\t\tcontext = context.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tselector = selector.slice( tokens.shift().value.length );\r\n\t\t}\r\n\r\n\t\t// Fetch a seed set for right-to-left matching\r\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\ttoken = tokens[i];\r\n\r\n\t\t\t// Abort if we hit a combinator\r\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif ( (find = Expr.find[ type ]) ) {\r\n\t\t\t\t// Search, expanding context for leading sibling combinators\r\n\t\t\t\tif ( (seed = find(\r\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\r\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\r\n\t\t\t\t)) ) {\r\n\r\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\r\n\t\t\t\t\ttokens.splice( i, 1 );\r\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\r\n\t\t\t\t\tif ( !selector ) {\r\n\t\t\t\t\t\tpush.apply( results, seed );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Compile and execute a filtering function if one is not provided\r\n\t// Provide `match` to avoid retokenization if we modified the selector above\r\n\t( compiled || compile( selector, match ) )(\r\n\t\tseed,\r\n\t\tcontext,\r\n\t\t!documentIsHTML,\r\n\t\tresults,\r\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\r\n\t);\r\n\treturn results;\r\n};\r\n\r\n// One-time assignments\r\n\r\n// Sort stability\r\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\r\n\r\n// Support: Chrome 14-35+\r\n// Always assume duplicates if they aren't passed to the comparison function\r\nsupport.detectDuplicates = !!hasDuplicate;\r\n\r\n// Initialize against the default document\r\nsetDocument();\r\n\r\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n// Detached nodes confoundingly follow *each other*\r\nsupport.sortDetached = assert(function( el ) {\r\n\t// Should return 1, but returns 4 (following)\r\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\r\n});\r\n\r\n// Support: IE<8\r\n// Prevent attribute/property \"interpolation\"\r\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\nif ( !assert(function( el ) {\r\n\tel.innerHTML = \"<a href='#'></a>\";\r\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\r\n}) ) {\r\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\r\n\t\tif ( !isXML ) {\r\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// Support: IE<9\r\n// Use defaultValue in place of getAttribute(\"value\")\r\nif ( !support.attributes || !assert(function( el ) {\r\n\tel.innerHTML = \"<input/>\";\r\n\tel.firstChild.setAttribute( \"value\", \"\" );\r\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\r\n}) ) {\r\n\taddHandle( \"value\", function( elem, name, isXML ) {\r\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\r\n\t\t\treturn elem.defaultValue;\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// Support: IE<9\r\n// Use getAttributeNode to fetch booleans when getAttribute lies\r\nif ( !assert(function( el ) {\r\n\treturn el.getAttribute(\"disabled\") == null;\r\n}) ) {\r\n\taddHandle( booleans, function( elem, name, isXML ) {\r\n\t\tvar val;\r\n\t\tif ( !isXML ) {\r\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\r\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\r\n\t\t\t\t\tval.value :\r\n\t\t\t\tnull;\r\n\t\t}\r\n\t});\r\n}\r\n\r\nreturn Sizzle;\r\n\r\n})( window );\r\n\r\n\r\n\r\njQuery.find = Sizzle;\r\njQuery.expr = Sizzle.selectors;\r\n\r\n// Deprecated\r\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\r\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\r\njQuery.text = Sizzle.getText;\r\njQuery.isXMLDoc = Sizzle.isXML;\r\njQuery.contains = Sizzle.contains;\r\njQuery.escapeSelector = Sizzle.escape;\r\n\r\n\r\n\r\n\r\nvar dir = function( elem, dir, until ) {\r\n\tvar matched = [],\r\n\t\ttruncate = until !== undefined;\r\n\r\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\r\n\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tmatched.push( elem );\r\n\t\t}\r\n\t}\r\n\treturn matched;\r\n};\r\n\r\n\r\nvar siblings = function( n, elem ) {\r\n\tvar matched = [];\r\n\r\n\tfor ( ; n; n = n.nextSibling ) {\r\n\t\tif ( n.nodeType === 1 && n !== elem ) {\r\n\t\t\tmatched.push( n );\r\n\t\t}\r\n\t}\r\n\r\n\treturn matched;\r\n};\r\n\r\n\r\nvar rneedsContext = jQuery.expr.match.needsContext;\r\n\r\n\r\n\r\nfunction nodeName( elem, name ) {\r\n\r\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\r\n\r\n};\r\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\r\n\r\n\r\n\r\nvar risSimple = /^.[^:#\\[\\.,]*$/;\r\n\r\n// Implement the identical functionality for filter and not\r\nfunction winnow( elements, qualifier, not ) {\r\n\tif ( jQuery.isFunction( qualifier ) ) {\r\n\t\treturn jQuery.grep( elements, function( elem, i ) {\r\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\r\n\t\t} );\r\n\t}\r\n\r\n\t// Single element\r\n\tif ( qualifier.nodeType ) {\r\n\t\treturn jQuery.grep( elements, function( elem ) {\r\n\t\t\treturn ( elem === qualifier ) !== not;\r\n\t\t} );\r\n\t}\r\n\r\n\t// Arraylike of elements (jQuery, arguments, Array)\r\n\tif ( typeof qualifier !== \"string\" ) {\r\n\t\treturn jQuery.grep( elements, function( elem ) {\r\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\r\n\t\t} );\r\n\t}\r\n\r\n\t// Simple selector that can be filtered directly, removing non-Elements\r\n\tif ( risSimple.test( qualifier ) ) {\r\n\t\treturn jQuery.filter( qualifier, elements, not );\r\n\t}\r\n\r\n\t// Complex selector, compare the two sets, removing non-Elements\r\n\tqualifier = jQuery.filter( qualifier, elements );\r\n\treturn jQuery.grep( elements, function( elem ) {\r\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\r\n\t} );\r\n}\r\n\r\njQuery.filter = function( expr, elems, not ) {\r\n\tvar elem = elems[ 0 ];\r\n\r\n\tif ( not ) {\r\n\t\texpr = \":not(\" + expr + \")\";\r\n\t}\r\n\r\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\r\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\r\n\t}\r\n\r\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\r\n\t\treturn elem.nodeType === 1;\r\n\t} ) );\r\n};\r\n\r\njQuery.fn.extend( {\r\n\tfind: function( selector ) {\r\n\t\tvar i, ret,\r\n\t\t\tlen = this.length,\r\n\t\t\tself = this;\r\n\r\n\t\tif ( typeof selector !== \"string\" ) {\r\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\r\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\r\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} ) );\r\n\t\t}\r\n\r\n\t\tret = this.pushStack( [] );\r\n\r\n\t\tfor ( i = 0; i < len; i++ ) {\r\n\t\t\tjQuery.find( selector, self[ i ], ret );\r\n\t\t}\r\n\r\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\r\n\t},\r\n\tfilter: function( selector ) {\r\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\r\n\t},\r\n\tnot: function( selector ) {\r\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\r\n\t},\r\n\tis: function( selector ) {\r\n\t\treturn !!winnow(\r\n\t\t\tthis,\r\n\r\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\r\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\r\n\t\t\t\tjQuery( selector ) :\r\n\t\t\t\tselector || [],\r\n\t\t\tfalse\r\n\t\t).length;\r\n\t}\r\n} );\r\n\r\n\r\n// Initialize a jQuery object\r\n\r\n\r\n// A central reference to the root jQuery(document)\r\nvar rootjQuery,\r\n\r\n\t// A simple way to check for HTML strings\r\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\r\n\t// Strict HTML recognition (#11290: must start with <)\r\n\t// Shortcut simple #id case for speed\r\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\r\n\r\n\tinit = jQuery.fn.init = function( selector, context, root ) {\r\n\t\tvar match, elem;\r\n\r\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n\t\tif ( !selector ) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// Method init() accepts an alternate rootjQuery\r\n\t\t// so migrate can support jQuery.sub (gh-2101)\r\n\t\troot = root || rootjQuery;\r\n\r\n\t\t// Handle HTML strings\r\n\t\tif ( typeof selector === \"string\" ) {\r\n\t\t\tif ( selector[ 0 ] === \"<\" &&\r\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\r\n\t\t\t\tselector.length >= 3 ) {\r\n\r\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\r\n\t\t\t\tmatch = [ null, selector, null ];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tmatch = rquickExpr.exec( selector );\r\n\t\t\t}\r\n\r\n\t\t\t// Match html or make sure no context is specified for #id\r\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\r\n\r\n\t\t\t\t// HANDLE: $(html) -> $(array)\r\n\t\t\t\tif ( match[ 1 ] ) {\r\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\r\n\r\n\t\t\t\t\t// Option to run scripts is true for back-compat\r\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\r\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\r\n\t\t\t\t\t\tmatch[ 1 ],\r\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t) );\r\n\r\n\t\t\t\t\t// HANDLE: $(html, props)\r\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\r\n\t\t\t\t\t\tfor ( match in context ) {\r\n\r\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\r\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\r\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\r\n\r\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t// HANDLE: $(#id)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\r\n\r\n\t\t\t\t\tif ( elem ) {\r\n\r\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\r\n\t\t\t\t\t\tthis[ 0 ] = elem;\r\n\t\t\t\t\t\tthis.length = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\r\n\t\t\t// HANDLE: $(expr, $(...))\r\n\t\t\t} else if ( !context || context.jquery ) {\r\n\t\t\t\treturn ( context || root ).find( selector );\r\n\r\n\t\t\t// HANDLE: $(expr, context)\r\n\t\t\t// (which is just equivalent to: $(context).find(expr)\r\n\t\t\t} else {\r\n\t\t\t\treturn this.constructor( context ).find( selector );\r\n\t\t\t}\r\n\r\n\t\t// HANDLE: $(DOMElement)\r\n\t\t} else if ( selector.nodeType ) {\r\n\t\t\tthis[ 0 ] = selector;\r\n\t\t\tthis.length = 1;\r\n\t\t\treturn this;\r\n\r\n\t\t// HANDLE: $(function)\r\n\t\t// Shortcut for document ready\r\n\t\t} else if ( jQuery.isFunction( selector ) ) {\r\n\t\t\treturn root.ready !== undefined ?\r\n\t\t\t\troot.ready( selector ) :\r\n\r\n\t\t\t\t// Execute immediately if ready is not present\r\n\t\t\t\tselector( jQuery );\r\n\t\t}\r\n\r\n\t\treturn jQuery.makeArray( selector, this );\r\n\t};\r\n\r\n// Give the init function the jQuery prototype for later instantiation\r\ninit.prototype = jQuery.fn;\r\n\r\n// Initialize central reference\r\nrootjQuery = jQuery( document );\r\n\r\n\r\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\r\n\r\n\t// Methods guaranteed to produce a unique set when starting from a unique set\r\n\tguaranteedUnique = {\r\n\t\tchildren: true,\r\n\t\tcontents: true,\r\n\t\tnext: true,\r\n\t\tprev: true\r\n\t};\r\n\r\njQuery.fn.extend( {\r\n\thas: function( target ) {\r\n\t\tvar targets = jQuery( target, this ),\r\n\t\t\tl = targets.length;\r\n\r\n\t\treturn this.filter( function() {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tclosest: function( selectors, context ) {\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length,\r\n\t\t\tmatched = [],\r\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\r\n\r\n\t\t// Positional selectors never match, since there's no _selection_ context\r\n\t\tif ( !rneedsContext.test( selectors ) ) {\r\n\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\r\n\r\n\t\t\t\t\t// Always skip document fragments\r\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\r\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\r\n\r\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\r\n\t\t\t\t\t\tcur.nodeType === 1 &&\r\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\r\n\r\n\t\t\t\t\t\tmatched.push( cur );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\r\n\t},\r\n\r\n\t// Determine the position of an element within the set\r\n\tindex: function( elem ) {\r\n\r\n\t\t// No argument, return index in parent\r\n\t\tif ( !elem ) {\r\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\r\n\t\t}\r\n\r\n\t\t// Index in selector\r\n\t\tif ( typeof elem === \"string\" ) {\r\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\r\n\t\t}\r\n\r\n\t\t// Locate the position of the desired element\r\n\t\treturn indexOf.call( this,\r\n\r\n\t\t\t// If it receives a jQuery object, the first element is used\r\n\t\t\telem.jquery ? elem[ 0 ] : elem\r\n\t\t);\r\n\t},\r\n\r\n\tadd: function( selector, context ) {\r\n\t\treturn this.pushStack(\r\n\t\t\tjQuery.uniqueSort(\r\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\r\n\t\t\t)\r\n\t\t);\r\n\t},\r\n\r\n\taddBack: function( selector ) {\r\n\t\treturn this.add( selector == null ?\r\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\r\n\t\t);\r\n\t}\r\n} );\r\n\r\nfunction sibling( cur, dir ) {\r\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\r\n\treturn cur;\r\n}\r\n\r\njQuery.each( {\r\n\tparent: function( elem ) {\r\n\t\tvar parent = elem.parentNode;\r\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\r\n\t},\r\n\tparents: function( elem ) {\r\n\t\treturn dir( elem, \"parentNode\" );\r\n\t},\r\n\tparentsUntil: function( elem, i, until ) {\r\n\t\treturn dir( elem, \"parentNode\", until );\r\n\t},\r\n\tnext: function( elem ) {\r\n\t\treturn sibling( elem, \"nextSibling\" );\r\n\t},\r\n\tprev: function( elem ) {\r\n\t\treturn sibling( elem, \"previousSibling\" );\r\n\t},\r\n\tnextAll: function( elem ) {\r\n\t\treturn dir( elem, \"nextSibling\" );\r\n\t},\r\n\tprevAll: function( elem ) {\r\n\t\treturn dir( elem, \"previousSibling\" );\r\n\t},\r\n\tnextUntil: function( elem, i, until ) {\r\n\t\treturn dir( elem, \"nextSibling\", until );\r\n\t},\r\n\tprevUntil: function( elem, i, until ) {\r\n\t\treturn dir( elem, \"previousSibling\", until );\r\n\t},\r\n\tsiblings: function( elem ) {\r\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\r\n\t},\r\n\tchildren: function( elem ) {\r\n\t\treturn siblings( elem.firstChild );\r\n\t},\r\n\tcontents: function( elem ) {\r\n        if ( nodeName( elem, \"iframe\" ) ) {\r\n            return elem.contentDocument;\r\n        }\r\n\r\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\r\n        // Treat the template element as a regular one in browsers that\r\n        // don't support it.\r\n        if ( nodeName( elem, \"template\" ) ) {\r\n            elem = elem.content || elem;\r\n        }\r\n\r\n        return jQuery.merge( [], elem.childNodes );\r\n\t}\r\n}, function( name, fn ) {\r\n\tjQuery.fn[ name ] = function( until, selector ) {\r\n\t\tvar matched = jQuery.map( this, fn, until );\r\n\r\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\r\n\t\t\tselector = until;\r\n\t\t}\r\n\r\n\t\tif ( selector && typeof selector === \"string\" ) {\r\n\t\t\tmatched = jQuery.filter( selector, matched );\r\n\t\t}\r\n\r\n\t\tif ( this.length > 1 ) {\r\n\r\n\t\t\t// Remove duplicates\r\n\t\t\tif ( !guaranteedUnique[ name ] ) {\r\n\t\t\t\tjQuery.uniqueSort( matched );\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse order for parents* and prev-derivatives\r\n\t\t\tif ( rparentsprev.test( name ) ) {\r\n\t\t\t\tmatched.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched );\r\n\t};\r\n} );\r\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\r\n\r\n\r\n\r\n// Convert String-formatted options into Object-formatted ones\r\nfunction createOptions( options ) {\r\n\tvar object = {};\r\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\r\n\t\tobject[ flag ] = true;\r\n\t} );\r\n\treturn object;\r\n}\r\n\r\n/*\r\n * Create a callback list using the following parameters:\r\n *\r\n *\toptions: an optional list of space-separated options that will change how\r\n *\t\t\tthe callback list behaves or a more traditional option object\r\n *\r\n * By default a callback list will act like an event callback list and can be\r\n * \"fired\" multiple times.\r\n *\r\n * Possible options:\r\n *\r\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n *\r\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n *\t\t\t\t\tvalues (like a Deferred)\r\n *\r\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n *\r\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n *\r\n */\r\njQuery.Callbacks = function( options ) {\r\n\r\n\t// Convert options from String-formatted to Object-formatted if needed\r\n\t// (we check in cache first)\r\n\toptions = typeof options === \"string\" ?\r\n\t\tcreateOptions( options ) :\r\n\t\tjQuery.extend( {}, options );\r\n\r\n\tvar // Flag to know if list is currently firing\r\n\t\tfiring,\r\n\r\n\t\t// Last fire value for non-forgettable lists\r\n\t\tmemory,\r\n\r\n\t\t// Flag to know if list was already fired\r\n\t\tfired,\r\n\r\n\t\t// Flag to prevent firing\r\n\t\tlocked,\r\n\r\n\t\t// Actual callback list\r\n\t\tlist = [],\r\n\r\n\t\t// Queue of execution data for repeatable lists\r\n\t\tqueue = [],\r\n\r\n\t\t// Index of currently firing callback (modified by add/remove as needed)\r\n\t\tfiringIndex = -1,\r\n\r\n\t\t// Fire callbacks\r\n\t\tfire = function() {\r\n\r\n\t\t\t// Enforce single-firing\r\n\t\t\tlocked = locked || options.once;\r\n\r\n\t\t\t// Execute callbacks for all pending executions,\r\n\t\t\t// respecting firingIndex overrides and runtime changes\r\n\t\t\tfired = firing = true;\r\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\r\n\t\t\t\tmemory = queue.shift();\r\n\t\t\t\twhile ( ++firingIndex < list.length ) {\r\n\r\n\t\t\t\t\t// Run callback and check for early termination\r\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\r\n\t\t\t\t\t\toptions.stopOnFalse ) {\r\n\r\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\r\n\t\t\t\t\t\tfiringIndex = list.length;\r\n\t\t\t\t\t\tmemory = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Forget the data if we're done with it\r\n\t\t\tif ( !options.memory ) {\r\n\t\t\t\tmemory = false;\r\n\t\t\t}\r\n\r\n\t\t\tfiring = false;\r\n\r\n\t\t\t// Clean up if we're done firing for good\r\n\t\t\tif ( locked ) {\r\n\r\n\t\t\t\t// Keep an empty list if we have data for future add calls\r\n\t\t\t\tif ( memory ) {\r\n\t\t\t\t\tlist = [];\r\n\r\n\t\t\t\t// Otherwise, this object is spent\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlist = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Actual Callbacks object\r\n\t\tself = {\r\n\r\n\t\t\t// Add a callback or a collection of callbacks to the list\r\n\t\t\tadd: function() {\r\n\t\t\t\tif ( list ) {\r\n\r\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\r\n\t\t\t\t\tif ( memory && !firing ) {\r\n\t\t\t\t\t\tfiringIndex = list.length - 1;\r\n\t\t\t\t\t\tqueue.push( memory );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t( function add( args ) {\r\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\r\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\r\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\r\n\t\t\t\t\t\t\t\t\tlist.push( arg );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\r\n\r\n\t\t\t\t\t\t\t\t// Inspect recursively\r\n\t\t\t\t\t\t\t\tadd( arg );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t} )( arguments );\r\n\r\n\t\t\t\t\tif ( memory && !firing ) {\r\n\t\t\t\t\t\tfire();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Remove a callback from the list\r\n\t\t\tremove: function() {\r\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\r\n\t\t\t\t\tvar index;\r\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\r\n\t\t\t\t\t\tlist.splice( index, 1 );\r\n\r\n\t\t\t\t\t\t// Handle firing indexes\r\n\t\t\t\t\t\tif ( index <= firingIndex ) {\r\n\t\t\t\t\t\t\tfiringIndex--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Check if a given callback is in the list.\r\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\r\n\t\t\thas: function( fn ) {\r\n\t\t\t\treturn fn ?\r\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\r\n\t\t\t\t\tlist.length > 0;\r\n\t\t\t},\r\n\r\n\t\t\t// Remove all callbacks from the list\r\n\t\t\tempty: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\tlist = [];\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Disable .fire and .add\r\n\t\t\t// Abort any current/pending executions\r\n\t\t\t// Clear all callbacks and values\r\n\t\t\tdisable: function() {\r\n\t\t\t\tlocked = queue = [];\r\n\t\t\t\tlist = memory = \"\";\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tdisabled: function() {\r\n\t\t\t\treturn !list;\r\n\t\t\t},\r\n\r\n\t\t\t// Disable .fire\r\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\r\n\t\t\t// Abort any pending executions\r\n\t\t\tlock: function() {\r\n\t\t\t\tlocked = queue = [];\r\n\t\t\t\tif ( !memory && !firing ) {\r\n\t\t\t\t\tlist = memory = \"\";\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tlocked: function() {\r\n\t\t\t\treturn !!locked;\r\n\t\t\t},\r\n\r\n\t\t\t// Call all callbacks with the given context and arguments\r\n\t\t\tfireWith: function( context, args ) {\r\n\t\t\t\tif ( !locked ) {\r\n\t\t\t\t\targs = args || [];\r\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\r\n\t\t\t\t\tqueue.push( args );\r\n\t\t\t\t\tif ( !firing ) {\r\n\t\t\t\t\t\tfire();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Call all the callbacks with the given arguments\r\n\t\t\tfire: function() {\r\n\t\t\t\tself.fireWith( this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// To know if the callbacks have already been called at least once\r\n\t\t\tfired: function() {\r\n\t\t\t\treturn !!fired;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\treturn self;\r\n};\r\n\r\n\r\nfunction Identity( v ) {\r\n\treturn v;\r\n}\r\nfunction Thrower( ex ) {\r\n\tthrow ex;\r\n}\r\n\r\nfunction adoptValue( value, resolve, reject, noValue ) {\r\n\tvar method;\r\n\r\n\ttry {\r\n\r\n\t\t// Check for promise aspect first to privilege synchronous behavior\r\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\r\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\r\n\r\n\t\t// Other thenables\r\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\r\n\t\t\tmethod.call( value, resolve, reject );\r\n\r\n\t\t// Other non-thenables\r\n\t\t} else {\r\n\r\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\r\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\r\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\r\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\r\n\t\t}\r\n\r\n\t// For Promises/A+, convert exceptions into rejections\r\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\r\n\t// Deferred#then to conditionally suppress rejection.\r\n\t} catch ( value ) {\r\n\r\n\t\t// Support: Android 4.0 only\r\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\r\n\t\treject.apply( undefined, [ value ] );\r\n\t}\r\n}\r\n\r\njQuery.extend( {\r\n\r\n\tDeferred: function( func ) {\r\n\t\tvar tuples = [\r\n\r\n\t\t\t\t// action, add listener, callbacks,\r\n\t\t\t\t// ... .then handlers, argument index, [final state]\r\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\r\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\r\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\r\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\r\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\r\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\r\n\t\t\t],\r\n\t\t\tstate = \"pending\",\r\n\t\t\tpromise = {\r\n\t\t\t\tstate: function() {\r\n\t\t\t\t\treturn state;\r\n\t\t\t\t},\r\n\t\t\t\talways: function() {\r\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\t\t\t\t\"catch\": function( fn ) {\r\n\t\t\t\t\treturn promise.then( null, fn );\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Keep pipe for back-compat\r\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\r\n\t\t\t\t\tvar fns = arguments;\r\n\r\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\r\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\r\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\r\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\r\n\r\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\r\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\r\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\r\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\r\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\r\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\r\n\t\t\t\t\t\t\t\t\treturned.promise()\r\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\r\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\r\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\r\n\t\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\tfns = null;\r\n\t\t\t\t\t} ).promise();\r\n\t\t\t\t},\r\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\r\n\t\t\t\t\tvar maxDepth = 0;\r\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\r\n\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\tvar that = this,\r\n\t\t\t\t\t\t\t\targs = arguments,\r\n\t\t\t\t\t\t\t\tmightThrow = function() {\r\n\t\t\t\t\t\t\t\t\tvar returned, then;\r\n\r\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\r\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\r\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\r\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\r\n\r\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\r\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\r\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\r\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\r\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\r\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\r\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\r\n\t\t\t\t\t\t\t\t\tthen = returned &&\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\r\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\r\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\r\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\r\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\r\n\t\t\t\t\t\t\t\t\t\treturned.then;\r\n\r\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\r\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\r\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\r\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\r\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\r\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\r\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\r\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\r\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\r\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\r\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\r\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\r\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\r\n\t\t\t\t\t\t\t\tprocess = special ?\r\n\t\t\t\t\t\t\t\t\tmightThrow :\r\n\t\t\t\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\r\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\r\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\r\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\r\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\r\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\r\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\r\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\r\n\t\t\t\t\t\t\t// subsequent errors\r\n\t\t\t\t\t\t\tif ( depth ) {\r\n\t\t\t\t\t\t\t\tprocess();\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\r\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\r\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\r\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\r\n\r\n\t\t\t\t\t\t// progress_handlers.add( ... )\r\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\r\n\t\t\t\t\t\t\tresolve(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\tnewDefer,\r\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\r\n\t\t\t\t\t\t\t\t\tonProgress :\r\n\t\t\t\t\t\t\t\t\tIdentity,\r\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\r\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\r\n\t\t\t\t\t\t\tresolve(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\tnewDefer,\r\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\r\n\t\t\t\t\t\t\t\t\tonFulfilled :\r\n\t\t\t\t\t\t\t\t\tIdentity\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t// rejected_handlers.add( ... )\r\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\r\n\t\t\t\t\t\t\tresolve(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\tnewDefer,\r\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\r\n\t\t\t\t\t\t\t\t\tonRejected :\r\n\t\t\t\t\t\t\t\t\tThrower\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} ).promise();\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Get a promise for this deferred\r\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\r\n\t\t\t\tpromise: function( obj ) {\r\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdeferred = {};\r\n\r\n\t\t// Add list-specific methods\r\n\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\t\t\tvar list = tuple[ 2 ],\r\n\t\t\t\tstateString = tuple[ 5 ];\r\n\r\n\t\t\t// promise.progress = list.add\r\n\t\t\t// promise.done = list.add\r\n\t\t\t// promise.fail = list.add\r\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\r\n\r\n\t\t\t// Handle state\r\n\t\t\tif ( stateString ) {\r\n\t\t\t\tlist.add(\r\n\t\t\t\t\tfunction() {\r\n\r\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\r\n\t\t\t\t\t\t// state = \"rejected\"\r\n\t\t\t\t\t\tstate = stateString;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t// rejected_callbacks.disable\r\n\t\t\t\t\t// fulfilled_callbacks.disable\r\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\r\n\r\n\t\t\t\t\t// progress_callbacks.lock\r\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// progress_handlers.fire\r\n\t\t\t// fulfilled_handlers.fire\r\n\t\t\t// rejected_handlers.fire\r\n\t\t\tlist.add( tuple[ 3 ].fire );\r\n\r\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\r\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\r\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\r\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\r\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\r\n\t\t\t// deferred.notifyWith = list.fireWith\r\n\t\t\t// deferred.resolveWith = list.fireWith\r\n\t\t\t// deferred.rejectWith = list.fireWith\r\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\r\n\t\t} );\r\n\r\n\t\t// Make the deferred a promise\r\n\t\tpromise.promise( deferred );\r\n\r\n\t\t// Call given func if any\r\n\t\tif ( func ) {\r\n\t\t\tfunc.call( deferred, deferred );\r\n\t\t}\r\n\r\n\t\t// All done!\r\n\t\treturn deferred;\r\n\t},\r\n\r\n\t// Deferred helper\r\n\twhen: function( singleValue ) {\r\n\t\tvar\r\n\r\n\t\t\t// count of uncompleted subordinates\r\n\t\t\tremaining = arguments.length,\r\n\r\n\t\t\t// count of unprocessed arguments\r\n\t\t\ti = remaining,\r\n\r\n\t\t\t// subordinate fulfillment data\r\n\t\t\tresolveContexts = Array( i ),\r\n\t\t\tresolveValues = slice.call( arguments ),\r\n\r\n\t\t\t// the master Deferred\r\n\t\t\tmaster = jQuery.Deferred(),\r\n\r\n\t\t\t// subordinate callback factory\r\n\t\t\tupdateFunc = function( i ) {\r\n\t\t\t\treturn function( value ) {\r\n\t\t\t\t\tresolveContexts[ i ] = this;\r\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\r\n\t\t\t\t\tif ( !( --remaining ) ) {\r\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t// Single- and empty arguments are adopted like Promise.resolve\r\n\t\tif ( remaining <= 1 ) {\r\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\r\n\t\t\t\t!remaining );\r\n\r\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\r\n\t\t\tif ( master.state() === \"pending\" ||\r\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\r\n\r\n\t\t\t\treturn master.then();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Multiple arguments are aggregated like Promise.all array elements\r\n\t\twhile ( i-- ) {\r\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\r\n\t\t}\r\n\r\n\t\treturn master.promise();\r\n\t}\r\n} );\r\n\r\n\r\n// These usually indicate a programmer mistake during development,\r\n// warn about them ASAP rather than swallowing them by default.\r\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\r\n\r\njQuery.Deferred.exceptionHook = function( error, stack ) {\r\n\r\n\t// Support: IE 8 - 9 only\r\n\t// Console exists when dev tools are open, which can happen at any time\r\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\r\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\njQuery.readyException = function( error ) {\r\n\twindow.setTimeout( function() {\r\n\t\tthrow error;\r\n\t} );\r\n};\r\n\r\n\r\n\r\n\r\n// The deferred used on DOM ready\r\nvar readyList = jQuery.Deferred();\r\n\r\njQuery.fn.ready = function( fn ) {\r\n\r\n\treadyList\r\n\t\t.then( fn )\r\n\r\n\t\t// Wrap jQuery.readyException in a function so that the lookup\r\n\t\t// happens at the time of error handling instead of callback\r\n\t\t// registration.\r\n\t\t.catch( function( error ) {\r\n\t\t\tjQuery.readyException( error );\r\n\t\t} );\r\n\r\n\treturn this;\r\n};\r\n\r\njQuery.extend( {\r\n\r\n\t// Is the DOM ready to be used? Set to true once it occurs.\r\n\tisReady: false,\r\n\r\n\t// A counter to track how many items to wait for before\r\n\t// the ready event fires. See #6781\r\n\treadyWait: 1,\r\n\r\n\t// Handle when the DOM is ready\r\n\tready: function( wait ) {\r\n\r\n\t\t// Abort if there are pending holds or we're already ready\r\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remember that the DOM is ready\r\n\t\tjQuery.isReady = true;\r\n\r\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\r\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If there are functions bound, to execute\r\n\t\treadyList.resolveWith( document, [ jQuery ] );\r\n\t}\r\n} );\r\n\r\njQuery.ready.then = readyList.then;\r\n\r\n// The ready event handler and self cleanup method\r\nfunction completed() {\r\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\r\n\twindow.removeEventListener( \"load\", completed );\r\n\tjQuery.ready();\r\n}\r\n\r\n// Catch cases where $(document).ready() is called\r\n// after the browser event has already occurred.\r\n// Support: IE <=9 - 10 only\r\n// Older IE sometimes signals \"interactive\" too soon\r\nif ( document.readyState === \"complete\" ||\r\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\r\n\r\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\r\n\twindow.setTimeout( jQuery.ready );\r\n\r\n} else {\r\n\r\n\t// Use the handy event callback\r\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\r\n\r\n\t// A fallback to window.onload, that will always work\r\n\twindow.addEventListener( \"load\", completed );\r\n}\r\n\r\n\r\n\r\n\r\n// Multifunctional method to get and set values of a collection\r\n// The value/s can optionally be executed if it's a function\r\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\r\n\tvar i = 0,\r\n\t\tlen = elems.length,\r\n\t\tbulk = key == null;\r\n\r\n\t// Sets many values\r\n\tif ( jQuery.type( key ) === \"object\" ) {\r\n\t\tchainable = true;\r\n\t\tfor ( i in key ) {\r\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\r\n\t\t}\r\n\r\n\t// Sets one value\r\n\t} else if ( value !== undefined ) {\r\n\t\tchainable = true;\r\n\r\n\t\tif ( !jQuery.isFunction( value ) ) {\r\n\t\t\traw = true;\r\n\t\t}\r\n\r\n\t\tif ( bulk ) {\r\n\r\n\t\t\t// Bulk operations run against the entire set\r\n\t\t\tif ( raw ) {\r\n\t\t\t\tfn.call( elems, value );\r\n\t\t\t\tfn = null;\r\n\r\n\t\t\t// ...except when executing function values\r\n\t\t\t} else {\r\n\t\t\t\tbulk = fn;\r\n\t\t\t\tfn = function( elem, key, value ) {\r\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( fn ) {\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\tfn(\r\n\t\t\t\t\telems[ i ], key, raw ?\r\n\t\t\t\t\tvalue :\r\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( chainable ) {\r\n\t\treturn elems;\r\n\t}\r\n\r\n\t// Gets\r\n\tif ( bulk ) {\r\n\t\treturn fn.call( elems );\r\n\t}\r\n\r\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\r\n};\r\nvar acceptData = function( owner ) {\r\n\r\n\t// Accepts only:\r\n\t//  - Node\r\n\t//    - Node.ELEMENT_NODE\r\n\t//    - Node.DOCUMENT_NODE\r\n\t//  - Object\r\n\t//    - Any\r\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\r\n};\r\n\r\n\r\n\r\n\r\nfunction Data() {\r\n\tthis.expando = jQuery.expando + Data.uid++;\r\n}\r\n\r\nData.uid = 1;\r\n\r\nData.prototype = {\r\n\r\n\tcache: function( owner ) {\r\n\r\n\t\t// Check if the owner object already has a cache\r\n\t\tvar value = owner[ this.expando ];\r\n\r\n\t\t// If not, create one\r\n\t\tif ( !value ) {\r\n\t\t\tvalue = {};\r\n\r\n\t\t\t// We can accept data for non-element nodes in modern browsers,\r\n\t\t\t// but we should not, see #8335.\r\n\t\t\t// Always return an empty object.\r\n\t\t\tif ( acceptData( owner ) ) {\r\n\r\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\r\n\t\t\t\t// use plain assignment\r\n\t\t\t\tif ( owner.nodeType ) {\r\n\t\t\t\t\towner[ this.expando ] = value;\r\n\r\n\t\t\t\t// Otherwise secure it in a non-enumerable property\r\n\t\t\t\t// configurable must be true to allow the property to be\r\n\t\t\t\t// deleted when data is removed\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\tset: function( owner, data, value ) {\r\n\t\tvar prop,\r\n\t\t\tcache = this.cache( owner );\r\n\r\n\t\t// Handle: [ owner, key, value ] args\r\n\t\t// Always use camelCase key (gh-2257)\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\r\n\r\n\t\t// Handle: [ owner, { properties } ] args\r\n\t\t} else {\r\n\r\n\t\t\t// Copy the properties one-by-one to the cache object\r\n\t\t\tfor ( prop in data ) {\r\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cache;\r\n\t},\r\n\tget: function( owner, key ) {\r\n\t\treturn key === undefined ?\r\n\t\t\tthis.cache( owner ) :\r\n\r\n\t\t\t// Always use camelCase key (gh-2257)\r\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\r\n\t},\r\n\taccess: function( owner, key, value ) {\r\n\r\n\t\t// In cases where either:\r\n\t\t//\r\n\t\t//   1. No key was specified\r\n\t\t//   2. A string key was specified, but no value provided\r\n\t\t//\r\n\t\t// Take the \"read\" path and allow the get method to determine\r\n\t\t// which value to return, respectively either:\r\n\t\t//\r\n\t\t//   1. The entire cache object\r\n\t\t//   2. The data stored at the key\r\n\t\t//\r\n\t\tif ( key === undefined ||\r\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\r\n\r\n\t\t\treturn this.get( owner, key );\r\n\t\t}\r\n\r\n\t\t// When the key is not a string, or both a key and value\r\n\t\t// are specified, set or extend (existing objects) with either:\r\n\t\t//\r\n\t\t//   1. An object of properties\r\n\t\t//   2. A key and value\r\n\t\t//\r\n\t\tthis.set( owner, key, value );\r\n\r\n\t\t// Since the \"set\" path can have two possible entry points\r\n\t\t// return the expected data based on which path was taken[*]\r\n\t\treturn value !== undefined ? value : key;\r\n\t},\r\n\tremove: function( owner, key ) {\r\n\t\tvar i,\r\n\t\t\tcache = owner[ this.expando ];\r\n\r\n\t\tif ( cache === undefined ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( key !== undefined ) {\r\n\r\n\t\t\t// Support array or space separated string of keys\r\n\t\t\tif ( Array.isArray( key ) ) {\r\n\r\n\t\t\t\t// If key is an array of keys...\r\n\t\t\t\t// We always set camelCase keys, so remove that.\r\n\t\t\t\tkey = key.map( jQuery.camelCase );\r\n\t\t\t} else {\r\n\t\t\t\tkey = jQuery.camelCase( key );\r\n\r\n\t\t\t\t// If a key with the spaces exists, use it.\r\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\r\n\t\t\t\tkey = key in cache ?\r\n\t\t\t\t\t[ key ] :\r\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\r\n\t\t\t}\r\n\r\n\t\t\ti = key.length;\r\n\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tdelete cache[ key[ i ] ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove the expando if there's no more data\r\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\r\n\r\n\t\t\t// Support: Chrome <=35 - 45\r\n\t\t\t// Webkit & Blink performance suffers when deleting properties\r\n\t\t\t// from DOM nodes, so set to undefined instead\r\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\r\n\t\t\tif ( owner.nodeType ) {\r\n\t\t\t\towner[ this.expando ] = undefined;\r\n\t\t\t} else {\r\n\t\t\t\tdelete owner[ this.expando ];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\thasData: function( owner ) {\r\n\t\tvar cache = owner[ this.expando ];\r\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\r\n\t}\r\n};\r\nvar dataPriv = new Data();\r\n\r\nvar dataUser = new Data();\r\n\r\n\r\n\r\n//\tImplementation Summary\r\n//\r\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n//\t2. Improve the module's maintainability by reducing the storage\r\n//\t\tpaths to a single mechanism.\r\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n\r\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\r\n\trmultiDash = /[A-Z]/g;\r\n\r\nfunction getData( data ) {\r\n\tif ( data === \"true\" ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif ( data === \"false\" ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( data === \"null\" ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Only convert to a number if it doesn't change the string\r\n\tif ( data === +data + \"\" ) {\r\n\t\treturn +data;\r\n\t}\r\n\r\n\tif ( rbrace.test( data ) ) {\r\n\t\treturn JSON.parse( data );\r\n\t}\r\n\r\n\treturn data;\r\n}\r\n\r\nfunction dataAttr( elem, key, data ) {\r\n\tvar name;\r\n\r\n\t// If nothing was found internally, try to fetch any\r\n\t// data from the HTML5 data-* attribute\r\n\tif ( data === undefined && elem.nodeType === 1 ) {\r\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\r\n\t\tdata = elem.getAttribute( name );\r\n\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\ttry {\r\n\t\t\t\tdata = getData( data );\r\n\t\t\t} catch ( e ) {}\r\n\r\n\t\t\t// Make sure we set the data so it isn't changed later\r\n\t\t\tdataUser.set( elem, key, data );\r\n\t\t} else {\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\t}\r\n\treturn data;\r\n}\r\n\r\njQuery.extend( {\r\n\thasData: function( elem ) {\r\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\r\n\t},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\treturn dataUser.access( elem, name, data );\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\tdataUser.remove( elem, name );\r\n\t},\r\n\r\n\t// TODO: Now that all calls to _data and _removeData have been replaced\r\n\t// with direct calls to dataPriv methods, these can be deprecated.\r\n\t_data: function( elem, name, data ) {\r\n\t\treturn dataPriv.access( elem, name, data );\r\n\t},\r\n\r\n\t_removeData: function( elem, name ) {\r\n\t\tdataPriv.remove( elem, name );\r\n\t}\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\tdata: function( key, value ) {\r\n\t\tvar i, name, data,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\tattrs = elem && elem.attributes;\r\n\r\n\t\t// Gets all values\r\n\t\tif ( key === undefined ) {\r\n\t\t\tif ( this.length ) {\r\n\t\t\t\tdata = dataUser.get( elem );\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\r\n\t\t\t\t\ti = attrs.length;\r\n\t\t\t\t\twhile ( i-- ) {\r\n\r\n\t\t\t\t\t\t// Support: IE 11 only\r\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\r\n\t\t\t\t\t\tif ( attrs[ i ] ) {\r\n\t\t\t\t\t\t\tname = attrs[ i ].name;\r\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\r\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\r\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\t// Sets multiple values\r\n\t\tif ( typeof key === \"object\" ) {\r\n\t\t\treturn this.each( function() {\r\n\t\t\t\tdataUser.set( this, key );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\treturn access( this, function( value ) {\r\n\t\t\tvar data;\r\n\r\n\t\t\t// The calling jQuery object (element matches) is not empty\r\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\r\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\r\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\r\n\t\t\t// throw an exception if an attempt to read a data cache is made.\r\n\t\t\tif ( elem && value === undefined ) {\r\n\r\n\t\t\t\t// Attempt to get data from the cache\r\n\t\t\t\t// The key will always be camelCased in Data\r\n\t\t\t\tdata = dataUser.get( elem, key );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Attempt to \"discover\" the data in\r\n\t\t\t\t// HTML5 custom data-* attrs\r\n\t\t\t\tdata = dataAttr( elem, key );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We tried really hard, but the data doesn't exist.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Set the data...\r\n\t\t\tthis.each( function() {\r\n\r\n\t\t\t\t// We always store the camelCased key\r\n\t\t\t\tdataUser.set( this, key, value );\r\n\t\t\t} );\r\n\t\t}, null, value, arguments.length > 1, null, true );\r\n\t},\r\n\r\n\tremoveData: function( key ) {\r\n\t\treturn this.each( function() {\r\n\t\t\tdataUser.remove( this, key );\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\n\r\njQuery.extend( {\r\n\tqueue: function( elem, type, data ) {\r\n\t\tvar queue;\r\n\r\n\t\tif ( elem ) {\r\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\r\n\t\t\tqueue = dataPriv.get( elem, type );\r\n\r\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\r\n\t\t\tif ( data ) {\r\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\r\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqueue.push( data );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn queue || [];\r\n\t\t}\r\n\t},\r\n\r\n\tdequeue: function( elem, type ) {\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tstartLength = queue.length,\r\n\t\t\tfn = queue.shift(),\r\n\t\t\thooks = jQuery._queueHooks( elem, type ),\r\n\t\t\tnext = function() {\r\n\t\t\t\tjQuery.dequeue( elem, type );\r\n\t\t\t};\r\n\r\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\r\n\t\tif ( fn === \"inprogress\" ) {\r\n\t\t\tfn = queue.shift();\r\n\t\t\tstartLength--;\r\n\t\t}\r\n\r\n\t\tif ( fn ) {\r\n\r\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\r\n\t\t\t// automatically dequeued\r\n\t\t\tif ( type === \"fx\" ) {\r\n\t\t\t\tqueue.unshift( \"inprogress\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Clear up the last queue stop function\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tfn.call( elem, next, hooks );\r\n\t\t}\r\n\r\n\t\tif ( !startLength && hooks ) {\r\n\t\t\thooks.empty.fire();\r\n\t\t}\r\n\t},\r\n\r\n\t// Not public - generate a queueHooks object, or return the current one\r\n\t_queueHooks: function( elem, type ) {\r\n\t\tvar key = type + \"queueHooks\";\r\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\r\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\r\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\r\n\t\t\t} )\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\tqueue: function( type, data ) {\r\n\t\tvar setter = 2;\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tdata = type;\r\n\t\t\ttype = \"fx\";\r\n\t\t\tsetter--;\r\n\t\t}\r\n\r\n\t\tif ( arguments.length < setter ) {\r\n\t\t\treturn jQuery.queue( this[ 0 ], type );\r\n\t\t}\r\n\r\n\t\treturn data === undefined ?\r\n\t\t\tthis :\r\n\t\t\tthis.each( function() {\r\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\r\n\r\n\t\t\t\t// Ensure a hooks for this queue\r\n\t\t\t\tjQuery._queueHooks( this, type );\r\n\r\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\r\n\t\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t},\r\n\tdequeue: function( type ) {\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.dequeue( this, type );\r\n\t\t} );\r\n\t},\r\n\tclearQueue: function( type ) {\r\n\t\treturn this.queue( type || \"fx\", [] );\r\n\t},\r\n\r\n\t// Get a promise resolved when queues of a certain type\r\n\t// are emptied (fx is the type by default)\r\n\tpromise: function( type, obj ) {\r\n\t\tvar tmp,\r\n\t\t\tcount = 1,\r\n\t\t\tdefer = jQuery.Deferred(),\r\n\t\t\telements = this,\r\n\t\t\ti = this.length,\r\n\t\t\tresolve = function() {\r\n\t\t\t\tif ( !( --count ) ) {\r\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tobj = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\twhile ( i-- ) {\r\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\r\n\t\t\tif ( tmp && tmp.empty ) {\r\n\t\t\t\tcount++;\r\n\t\t\t\ttmp.empty.add( resolve );\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve();\r\n\t\treturn defer.promise( obj );\r\n\t}\r\n} );\r\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\r\n\r\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\r\n\r\n\r\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\r\n\r\nvar isHiddenWithinTree = function( elem, el ) {\r\n\r\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\r\n\t\t// in that case, element will be second argument\r\n\t\telem = el || elem;\r\n\r\n\t\t// Inline style trumps all\r\n\t\treturn elem.style.display === \"none\" ||\r\n\t\t\telem.style.display === \"\" &&\r\n\r\n\t\t\t// Otherwise, check computed style\r\n\t\t\t// Support: Firefox <=43 - 45\r\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\r\n\t\t\t// in the document.\r\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\r\n\r\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\r\n\t};\r\n\r\nvar swap = function( elem, options, callback, args ) {\r\n\tvar ret, name,\r\n\t\told = {};\r\n\r\n\t// Remember the old values, and insert the new ones\r\n\tfor ( name in options ) {\r\n\t\told[ name ] = elem.style[ name ];\r\n\t\telem.style[ name ] = options[ name ];\r\n\t}\r\n\r\n\tret = callback.apply( elem, args || [] );\r\n\r\n\t// Revert the old values\r\n\tfor ( name in options ) {\r\n\t\telem.style[ name ] = old[ name ];\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\n\r\n\r\n\r\nfunction adjustCSS( elem, prop, valueParts, tween ) {\r\n\tvar adjusted,\r\n\t\tscale = 1,\r\n\t\tmaxIterations = 20,\r\n\t\tcurrentValue = tween ?\r\n\t\t\tfunction() {\r\n\t\t\t\treturn tween.cur();\r\n\t\t\t} :\r\n\t\t\tfunction() {\r\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\r\n\t\t\t},\r\n\t\tinitial = currentValue(),\r\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\r\n\r\n\t\t// Starting value computation is required for potential unit mismatches\r\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\r\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\r\n\r\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\r\n\r\n\t\t// Trust units reported by jQuery.css\r\n\t\tunit = unit || initialInUnit[ 3 ];\r\n\r\n\t\t// Make sure we update the tween properties later on\r\n\t\tvalueParts = valueParts || [];\r\n\r\n\t\t// Iteratively approximate from a nonzero starting point\r\n\t\tinitialInUnit = +initial || 1;\r\n\r\n\t\tdo {\r\n\r\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\r\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\r\n\t\t\tscale = scale || \".5\";\r\n\r\n\t\t\t// Adjust and apply\r\n\t\t\tinitialInUnit = initialInUnit / scale;\r\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\r\n\r\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\r\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\r\n\t\t} while (\r\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\r\n\t\t);\r\n\t}\r\n\r\n\tif ( valueParts ) {\r\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\r\n\r\n\t\t// Apply relative offset (+=/-=) if specified\r\n\t\tadjusted = valueParts[ 1 ] ?\r\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\r\n\t\t\t+valueParts[ 2 ];\r\n\t\tif ( tween ) {\r\n\t\t\ttween.unit = unit;\r\n\t\t\ttween.start = initialInUnit;\r\n\t\t\ttween.end = adjusted;\r\n\t\t}\r\n\t}\r\n\treturn adjusted;\r\n}\r\n\r\n\r\nvar defaultDisplayMap = {};\r\n\r\nfunction getDefaultDisplay( elem ) {\r\n\tvar temp,\r\n\t\tdoc = elem.ownerDocument,\r\n\t\tnodeName = elem.nodeName,\r\n\t\tdisplay = defaultDisplayMap[ nodeName ];\r\n\r\n\tif ( display ) {\r\n\t\treturn display;\r\n\t}\r\n\r\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\r\n\tdisplay = jQuery.css( temp, \"display\" );\r\n\r\n\ttemp.parentNode.removeChild( temp );\r\n\r\n\tif ( display === \"none\" ) {\r\n\t\tdisplay = \"block\";\r\n\t}\r\n\tdefaultDisplayMap[ nodeName ] = display;\r\n\r\n\treturn display;\r\n}\r\n\r\nfunction showHide( elements, show ) {\r\n\tvar display, elem,\r\n\t\tvalues = [],\r\n\t\tindex = 0,\r\n\t\tlength = elements.length;\r\n\r\n\t// Determine new display value for elements that need to change\r\n\tfor ( ; index < length; index++ ) {\r\n\t\telem = elements[ index ];\r\n\t\tif ( !elem.style ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tdisplay = elem.style.display;\r\n\t\tif ( show ) {\r\n\r\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\r\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\r\n\t\t\t// inline or about-to-be-restored)\r\n\t\t\tif ( display === \"none\" ) {\r\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\r\n\t\t\t\tif ( !values[ index ] ) {\r\n\t\t\t\t\telem.style.display = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\r\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif ( display !== \"none\" ) {\r\n\t\t\t\tvalues[ index ] = \"none\";\r\n\r\n\t\t\t\t// Remember what we're overwriting\r\n\t\t\t\tdataPriv.set( elem, \"display\", display );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the display of the elements in a second loop to avoid constant reflow\r\n\tfor ( index = 0; index < length; index++ ) {\r\n\t\tif ( values[ index ] != null ) {\r\n\t\t\telements[ index ].style.display = values[ index ];\r\n\t\t}\r\n\t}\r\n\r\n\treturn elements;\r\n}\r\n\r\njQuery.fn.extend( {\r\n\tshow: function() {\r\n\t\treturn showHide( this, true );\r\n\t},\r\n\thide: function() {\r\n\t\treturn showHide( this );\r\n\t},\r\n\ttoggle: function( state ) {\r\n\t\tif ( typeof state === \"boolean\" ) {\r\n\t\t\treturn state ? this.show() : this.hide();\r\n\t\t}\r\n\r\n\t\treturn this.each( function() {\r\n\t\t\tif ( isHiddenWithinTree( this ) ) {\r\n\t\t\t\tjQuery( this ).show();\r\n\t\t\t} else {\r\n\t\t\t\tjQuery( this ).hide();\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n} );\r\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\r\n\r\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\r\n\r\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\r\n\r\n\r\n\r\n// We have to close these tags to support XHTML (#13200)\r\nvar wrapMap = {\r\n\r\n\t// Support: IE <=9 only\r\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\r\n\r\n\t// XHTML parsers do not magically insert elements in the\r\n\t// same way that tag soup parsers do. So we cannot shorten\r\n\t// this by omitting <tbody> or other required elements.\r\n\tthead: [ 1, \"<table>\", \"</table>\" ],\r\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\r\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\r\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\r\n\r\n\t_default: [ 0, \"\", \"\" ]\r\n};\r\n\r\n// Support: IE <=9 only\r\nwrapMap.optgroup = wrapMap.option;\r\n\r\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\nwrapMap.th = wrapMap.td;\r\n\r\n\r\nfunction getAll( context, tag ) {\r\n\r\n\t// Support: IE <=9 - 11 only\r\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\r\n\tvar ret;\r\n\r\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\r\n\t\tret = context.getElementsByTagName( tag || \"*\" );\r\n\r\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\r\n\t\tret = context.querySelectorAll( tag || \"*\" );\r\n\r\n\t} else {\r\n\t\tret = [];\r\n\t}\r\n\r\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\r\n\t\treturn jQuery.merge( [ context ], ret );\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\n\r\n// Mark scripts as having already been evaluated\r\nfunction setGlobalEval( elems, refElements ) {\r\n\tvar i = 0,\r\n\t\tl = elems.length;\r\n\r\n\tfor ( ; i < l; i++ ) {\r\n\t\tdataPriv.set(\r\n\t\t\telems[ i ],\r\n\t\t\t\"globalEval\",\r\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\r\n\t\t);\r\n\t}\r\n}\r\n\r\n\r\nvar rhtml = /<|&#?\\w+;/;\r\n\r\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\r\n\tvar elem, tmp, tag, wrap, contains, j,\r\n\t\tfragment = context.createDocumentFragment(),\r\n\t\tnodes = [],\r\n\t\ti = 0,\r\n\t\tl = elems.length;\r\n\r\n\tfor ( ; i < l; i++ ) {\r\n\t\telem = elems[ i ];\r\n\r\n\t\tif ( elem || elem === 0 ) {\r\n\r\n\t\t\t// Add nodes directly\r\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\r\n\r\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\r\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\r\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\r\n\r\n\t\t\t// Convert non-html into a text node\r\n\t\t\t} else if ( !rhtml.test( elem ) ) {\r\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\r\n\r\n\t\t\t// Convert html into DOM nodes\r\n\t\t\t} else {\r\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\r\n\r\n\t\t\t\t// Deserialize a standard representation\r\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\r\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\r\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\r\n\r\n\t\t\t\t// Descend through wrappers to the right content\r\n\t\t\t\tj = wrap[ 0 ];\r\n\t\t\t\twhile ( j-- ) {\r\n\t\t\t\t\ttmp = tmp.lastChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\r\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\r\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\r\n\r\n\t\t\t\t// Remember the top-level container\r\n\t\t\t\ttmp = fragment.firstChild;\r\n\r\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\r\n\t\t\t\ttmp.textContent = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove wrapper from fragment\r\n\tfragment.textContent = \"\";\r\n\r\n\ti = 0;\r\n\twhile ( ( elem = nodes[ i++ ] ) ) {\r\n\r\n\t\t// Skip elements already in the context collection (trac-4087)\r\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\r\n\t\t\tif ( ignored ) {\r\n\t\t\t\tignored.push( elem );\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t// Append to fragment\r\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\r\n\r\n\t\t// Preserve script evaluation history\r\n\t\tif ( contains ) {\r\n\t\t\tsetGlobalEval( tmp );\r\n\t\t}\r\n\r\n\t\t// Capture executables\r\n\t\tif ( scripts ) {\r\n\t\t\tj = 0;\r\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\r\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\r\n\t\t\t\t\tscripts.push( elem );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn fragment;\r\n}\r\n\r\n\r\n( function() {\r\n\tvar fragment = document.createDocumentFragment(),\r\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\r\n\t\tinput = document.createElement( \"input\" );\r\n\r\n\t// Support: Android 4.0 - 4.3 only\r\n\t// Check state lost if the name is set (#11217)\r\n\t// Support: Windows Web Apps (WWA)\r\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\r\n\tinput.setAttribute( \"type\", \"radio\" );\r\n\tinput.setAttribute( \"checked\", \"checked\" );\r\n\tinput.setAttribute( \"name\", \"t\" );\r\n\r\n\tdiv.appendChild( input );\r\n\r\n\t// Support: Android <=4.1 only\r\n\t// Older WebKit doesn't clone checked state correctly in fragments\r\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\r\n\r\n\t// Support: IE <=11 only\r\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\r\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\r\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\r\n} )();\r\nvar documentElement = document.documentElement;\r\n\r\n\r\n\r\nvar\r\n\trkeyEvent = /^key/,\r\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\r\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\r\n\r\nfunction returnTrue() {\r\n\treturn true;\r\n}\r\n\r\nfunction returnFalse() {\r\n\treturn false;\r\n}\r\n\r\n// Support: IE <=9 only\r\n// See #13393 for more info\r\nfunction safeActiveElement() {\r\n\ttry {\r\n\t\treturn document.activeElement;\r\n\t} catch ( err ) { }\r\n}\r\n\r\nfunction on( elem, types, selector, data, fn, one ) {\r\n\tvar origFn, type;\r\n\r\n\t// Types can be a map of types/handlers\r\n\tif ( typeof types === \"object\" ) {\r\n\r\n\t\t// ( types-Object, selector, data )\r\n\t\tif ( typeof selector !== \"string\" ) {\r\n\r\n\t\t\t// ( types-Object, data )\r\n\t\t\tdata = data || selector;\r\n\t\t\tselector = undefined;\r\n\t\t}\r\n\t\tfor ( type in types ) {\r\n\t\t\ton( elem, type, selector, data, types[ type ], one );\r\n\t\t}\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tif ( data == null && fn == null ) {\r\n\r\n\t\t// ( types, fn )\r\n\t\tfn = selector;\r\n\t\tdata = selector = undefined;\r\n\t} else if ( fn == null ) {\r\n\t\tif ( typeof selector === \"string\" ) {\r\n\r\n\t\t\t// ( types, selector, fn )\r\n\t\t\tfn = data;\r\n\t\t\tdata = undefined;\r\n\t\t} else {\r\n\r\n\t\t\t// ( types, data, fn )\r\n\t\t\tfn = data;\r\n\t\t\tdata = selector;\r\n\t\t\tselector = undefined;\r\n\t\t}\r\n\t}\r\n\tif ( fn === false ) {\r\n\t\tfn = returnFalse;\r\n\t} else if ( !fn ) {\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tif ( one === 1 ) {\r\n\t\torigFn = fn;\r\n\t\tfn = function( event ) {\r\n\r\n\t\t\t// Can use an empty set, since event contains the info\r\n\t\t\tjQuery().off( event );\r\n\t\t\treturn origFn.apply( this, arguments );\r\n\t\t};\r\n\r\n\t\t// Use same guid so caller can remove using origFn\r\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\r\n\t}\r\n\treturn elem.each( function() {\r\n\t\tjQuery.event.add( this, types, fn, data, selector );\r\n\t} );\r\n}\r\n\r\n/*\r\n * Helper functions for managing events -- not part of the public interface.\r\n * Props to Dean Edwards' addEvent library for many of the ideas.\r\n */\r\njQuery.event = {\r\n\r\n\tglobal: {},\r\n\r\n\tadd: function( elem, types, handler, data, selector ) {\r\n\r\n\t\tvar handleObjIn, eventHandle, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = dataPriv.get( elem );\r\n\r\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\r\n\t\tif ( !elemData ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Caller can pass in an object of custom data in lieu of the handler\r\n\t\tif ( handler.handler ) {\r\n\t\t\thandleObjIn = handler;\r\n\t\t\thandler = handleObjIn.handler;\r\n\t\t\tselector = handleObjIn.selector;\r\n\t\t}\r\n\r\n\t\t// Ensure that invalid selectors throw exceptions at attach time\r\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\r\n\t\tif ( selector ) {\r\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\r\n\t\t}\r\n\r\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\r\n\t\tif ( !handler.guid ) {\r\n\t\t\thandler.guid = jQuery.guid++;\r\n\t\t}\r\n\r\n\t\t// Init the element's event structure and main handler, if this is the first\r\n\t\tif ( !( events = elemData.events ) ) {\r\n\t\t\tevents = elemData.events = {};\r\n\t\t}\r\n\t\tif ( !( eventHandle = elemData.handle ) ) {\r\n\t\t\teventHandle = elemData.handle = function( e ) {\r\n\r\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\r\n\t\t\t\t// when an event is called after a page has unloaded\r\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\r\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle multiple events separated by a space\r\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\r\n\t\t\ttype = origType = tmp[ 1 ];\r\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// If event changes its type, use the special event handlers for the changed type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// If selector defined, determine special event api type, otherwise given type\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\r\n\t\t\t// Update special based on newly reset type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// handleObj is passed to all event handlers\r\n\t\t\thandleObj = jQuery.extend( {\r\n\t\t\t\ttype: type,\r\n\t\t\t\torigType: origType,\r\n\t\t\t\tdata: data,\r\n\t\t\t\thandler: handler,\r\n\t\t\t\tguid: handler.guid,\r\n\t\t\t\tselector: selector,\r\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\r\n\t\t\t\tnamespace: namespaces.join( \".\" )\r\n\t\t\t}, handleObjIn );\r\n\r\n\t\t\t// Init the event handler queue if we're the first\r\n\t\t\tif ( !( handlers = events[ type ] ) ) {\r\n\t\t\t\thandlers = events[ type ] = [];\r\n\t\t\t\thandlers.delegateCount = 0;\r\n\r\n\t\t\t\t// Only use addEventListener if the special events handler returns false\r\n\t\t\t\tif ( !special.setup ||\r\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\r\n\r\n\t\t\t\t\tif ( elem.addEventListener ) {\r\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( special.add ) {\r\n\t\t\t\tspecial.add.call( elem, handleObj );\r\n\r\n\t\t\t\tif ( !handleObj.handler.guid ) {\r\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Add to the element's handler list, delegates in front\r\n\t\t\tif ( selector ) {\r\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\r\n\t\t\t} else {\r\n\t\t\t\thandlers.push( handleObj );\r\n\t\t\t}\r\n\r\n\t\t\t// Keep track of which events have ever been used, for event optimization\r\n\t\t\tjQuery.event.global[ type ] = true;\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Detach an event or set of events from an element\r\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\r\n\r\n\t\tvar j, origCount, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\r\n\r\n\t\tif ( !elemData || !( events = elemData.events ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Once for each type.namespace in types; type may be omitted\r\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\r\n\t\t\ttype = origType = tmp[ 1 ];\r\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tfor ( type in events ) {\r\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\t\t\thandlers = events[ type ] || [];\r\n\t\t\ttmp = tmp[ 2 ] &&\r\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\r\n\r\n\t\t\t// Remove matching events\r\n\t\t\torigCount = j = handlers.length;\r\n\t\t\twhile ( j-- ) {\r\n\t\t\t\thandleObj = handlers[ j ];\r\n\r\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\r\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\r\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\r\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\r\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\r\n\t\t\t\t\thandlers.splice( j, 1 );\r\n\r\n\t\t\t\t\tif ( handleObj.selector ) {\r\n\t\t\t\t\t\thandlers.delegateCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( special.remove ) {\r\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\r\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\r\n\t\t\tif ( origCount && !handlers.length ) {\r\n\t\t\t\tif ( !special.teardown ||\r\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\r\n\r\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete events[ type ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove data and the expando if it's no longer used\r\n\t\tif ( jQuery.isEmptyObject( events ) ) {\r\n\t\t\tdataPriv.remove( elem, \"handle events\" );\r\n\t\t}\r\n\t},\r\n\r\n\tdispatch: function( nativeEvent ) {\r\n\r\n\t\t// Make a writable jQuery.Event from the native event object\r\n\t\tvar event = jQuery.event.fix( nativeEvent );\r\n\r\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\r\n\t\t\targs = new Array( arguments.length ),\r\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\r\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\r\n\r\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n\t\targs[ 0 ] = event;\r\n\r\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\r\n\t\t\targs[ i ] = arguments[ i ];\r\n\t\t}\r\n\r\n\t\tevent.delegateTarget = this;\r\n\r\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\r\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine handlers\r\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\r\n\r\n\t\t// Run delegates first; they may want to stop propagation beneath us\r\n\t\ti = 0;\r\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\r\n\t\t\tevent.currentTarget = matched.elem;\r\n\r\n\t\t\tj = 0;\r\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\r\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\r\n\r\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\r\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\r\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\r\n\r\n\t\t\t\t\tevent.handleObj = handleObj;\r\n\t\t\t\t\tevent.data = handleObj.data;\r\n\r\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\r\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\r\n\r\n\t\t\t\t\tif ( ret !== undefined ) {\r\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Call the postDispatch hook for the mapped type\r\n\t\tif ( special.postDispatch ) {\r\n\t\t\tspecial.postDispatch.call( this, event );\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\thandlers: function( event, handlers ) {\r\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\r\n\t\t\thandlerQueue = [],\r\n\t\t\tdelegateCount = handlers.delegateCount,\r\n\t\t\tcur = event.target;\r\n\r\n\t\t// Find delegate handlers\r\n\t\tif ( delegateCount &&\r\n\r\n\t\t\t// Support: IE <=9\r\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\r\n\t\t\tcur.nodeType &&\r\n\r\n\t\t\t// Support: Firefox <=42\r\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\r\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\r\n\t\t\t// Support: IE 11 only\r\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\r\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\r\n\r\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\r\n\r\n\t\t\t\t// Don't check non-elements (#13208)\r\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\r\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\r\n\t\t\t\t\tmatchedHandlers = [];\r\n\t\t\t\t\tmatchedSelectors = {};\r\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\r\n\t\t\t\t\t\thandleObj = handlers[ i ];\r\n\r\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\r\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\r\n\r\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\r\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\r\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\r\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\r\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( matchedHandlers.length ) {\r\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add the remaining (directly-bound) handlers\r\n\t\tcur = this;\r\n\t\tif ( delegateCount < handlers.length ) {\r\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\r\n\t\t}\r\n\r\n\t\treturn handlerQueue;\r\n\t},\r\n\r\n\taddProp: function( name, hook ) {\r\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: true,\r\n\r\n\t\t\tget: jQuery.isFunction( hook ) ?\r\n\t\t\t\tfunction() {\r\n\t\t\t\t\tif ( this.originalEvent ) {\r\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\r\n\t\t\t\t\t}\r\n\t\t\t\t} :\r\n\t\t\t\tfunction() {\r\n\t\t\t\t\tif ( this.originalEvent ) {\r\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\tset: function( value ) {\r\n\t\t\t\tObject.defineProperty( this, name, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: value\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tfix: function( originalEvent ) {\r\n\t\treturn originalEvent[ jQuery.expando ] ?\r\n\t\t\toriginalEvent :\r\n\t\t\tnew jQuery.Event( originalEvent );\r\n\t},\r\n\r\n\tspecial: {\r\n\t\tload: {\r\n\r\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\r\n\t\t\tnoBubble: true\r\n\t\t},\r\n\t\tfocus: {\r\n\r\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\r\n\t\t\t\t\tthis.focus();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusin\"\r\n\t\t},\r\n\t\tblur: {\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\r\n\t\t\t\t\tthis.blur();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusout\"\r\n\t\t},\r\n\t\tclick: {\r\n\r\n\t\t\t// For checkbox, fire native event so checked state will be right\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\r\n\t\t\t\t\tthis.click();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\r\n\t\t\t_default: function( event ) {\r\n\t\t\t\treturn nodeName( event.target, \"a\" );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbeforeunload: {\r\n\t\t\tpostDispatch: function( event ) {\r\n\r\n\t\t\t\t// Support: Firefox 20+\r\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\r\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\r\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.removeEvent = function( elem, type, handle ) {\r\n\r\n\t// This \"if\" is needed for plain objects\r\n\tif ( elem.removeEventListener ) {\r\n\t\telem.removeEventListener( type, handle );\r\n\t}\r\n};\r\n\r\njQuery.Event = function( src, props ) {\r\n\r\n\t// Allow instantiation without the 'new' keyword\r\n\tif ( !( this instanceof jQuery.Event ) ) {\r\n\t\treturn new jQuery.Event( src, props );\r\n\t}\r\n\r\n\t// Event object\r\n\tif ( src && src.type ) {\r\n\t\tthis.originalEvent = src;\r\n\t\tthis.type = src.type;\r\n\r\n\t\t// Events bubbling up the document may have been marked as prevented\r\n\t\t// by a handler lower down the tree; reflect the correct value.\r\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\r\n\t\t\t\tsrc.defaultPrevented === undefined &&\r\n\r\n\t\t\t\t// Support: Android <=2.3 only\r\n\t\t\t\tsrc.returnValue === false ?\r\n\t\t\treturnTrue :\r\n\t\t\treturnFalse;\r\n\r\n\t\t// Create target properties\r\n\t\t// Support: Safari <=6 - 7 only\r\n\t\t// Target should not be a text node (#504, #13143)\r\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\r\n\t\t\tsrc.target.parentNode :\r\n\t\t\tsrc.target;\r\n\r\n\t\tthis.currentTarget = src.currentTarget;\r\n\t\tthis.relatedTarget = src.relatedTarget;\r\n\r\n\t// Event type\r\n\t} else {\r\n\t\tthis.type = src;\r\n\t}\r\n\r\n\t// Put explicitly provided properties onto the event object\r\n\tif ( props ) {\r\n\t\tjQuery.extend( this, props );\r\n\t}\r\n\r\n\t// Create a timestamp if incoming event doesn't have one\r\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\r\n\r\n\t// Mark it as fixed\r\n\tthis[ jQuery.expando ] = true;\r\n};\r\n\r\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\njQuery.Event.prototype = {\r\n\tconstructor: jQuery.Event,\r\n\tisDefaultPrevented: returnFalse,\r\n\tisPropagationStopped: returnFalse,\r\n\tisImmediatePropagationStopped: returnFalse,\r\n\tisSimulated: false,\r\n\r\n\tpreventDefault: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isDefaultPrevented = returnTrue;\r\n\r\n\t\tif ( e && !this.isSimulated ) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t},\r\n\tstopPropagation: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isPropagationStopped = returnTrue;\r\n\r\n\t\tif ( e && !this.isSimulated ) {\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\t},\r\n\tstopImmediatePropagation: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isImmediatePropagationStopped = returnTrue;\r\n\r\n\t\tif ( e && !this.isSimulated ) {\r\n\t\t\te.stopImmediatePropagation();\r\n\t\t}\r\n\r\n\t\tthis.stopPropagation();\r\n\t}\r\n};\r\n\r\n// Includes all common event props including KeyEvent and MouseEvent specific props\r\njQuery.each( {\r\n\taltKey: true,\r\n\tbubbles: true,\r\n\tcancelable: true,\r\n\tchangedTouches: true,\r\n\tctrlKey: true,\r\n\tdetail: true,\r\n\teventPhase: true,\r\n\tmetaKey: true,\r\n\tpageX: true,\r\n\tpageY: true,\r\n\tshiftKey: true,\r\n\tview: true,\r\n\t\"char\": true,\r\n\tcharCode: true,\r\n\tkey: true,\r\n\tkeyCode: true,\r\n\tbutton: true,\r\n\tbuttons: true,\r\n\tclientX: true,\r\n\tclientY: true,\r\n\toffsetX: true,\r\n\toffsetY: true,\r\n\tpointerId: true,\r\n\tpointerType: true,\r\n\tscreenX: true,\r\n\tscreenY: true,\r\n\ttargetTouches: true,\r\n\ttoElement: true,\r\n\ttouches: true,\r\n\r\n\twhich: function( event ) {\r\n\t\tvar button = event.button;\r\n\r\n\t\t// Add which for key events\r\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\r\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\r\n\t\t}\r\n\r\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\r\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\r\n\t\t\tif ( button & 1 ) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\r\n\t\t\tif ( button & 2 ) {\r\n\t\t\t\treturn 3;\r\n\t\t\t}\r\n\r\n\t\t\tif ( button & 4 ) {\r\n\t\t\t\treturn 2;\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn event.which;\r\n\t}\r\n}, jQuery.event.addProp );\r\n\r\n// Create mouseenter/leave events using mouseover/out and event-time checks\r\n// so that event delegation works in jQuery.\r\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\r\n//\r\n// Support: Safari 7 only\r\n// Safari sends mouseenter too often; see:\r\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\r\n// for the description of the bug (it existed in older Chrome versions as well).\r\njQuery.each( {\r\n\tmouseenter: \"mouseover\",\r\n\tmouseleave: \"mouseout\",\r\n\tpointerenter: \"pointerover\",\r\n\tpointerleave: \"pointerout\"\r\n}, function( orig, fix ) {\r\n\tjQuery.event.special[ orig ] = {\r\n\t\tdelegateType: fix,\r\n\t\tbindType: fix,\r\n\r\n\t\thandle: function( event ) {\r\n\t\t\tvar ret,\r\n\t\t\t\ttarget = this,\r\n\t\t\t\trelated = event.relatedTarget,\r\n\t\t\t\thandleObj = event.handleObj;\r\n\r\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\r\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\r\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\r\n\t\t\t\tevent.type = handleObj.origType;\r\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\r\n\t\t\t\tevent.type = fix;\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t};\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\r\n\ton: function( types, selector, data, fn ) {\r\n\t\treturn on( this, types, selector, data, fn );\r\n\t},\r\n\tone: function( types, selector, data, fn ) {\r\n\t\treturn on( this, types, selector, data, fn, 1 );\r\n\t},\r\n\toff: function( types, selector, fn ) {\r\n\t\tvar handleObj, type;\r\n\t\tif ( types && types.preventDefault && types.handleObj ) {\r\n\r\n\t\t\t// ( event )  dispatched jQuery.Event\r\n\t\t\thandleObj = types.handleObj;\r\n\t\t\tjQuery( types.delegateTarget ).off(\r\n\t\t\t\thandleObj.namespace ?\r\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\r\n\t\t\t\t\thandleObj.origType,\r\n\t\t\t\thandleObj.selector,\r\n\t\t\t\thandleObj.handler\r\n\t\t\t);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( typeof types === \"object\" ) {\r\n\r\n\t\t\t// ( types-object [, selector] )\r\n\t\t\tfor ( type in types ) {\r\n\t\t\t\tthis.off( type, selector, types[ type ] );\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( selector === false || typeof selector === \"function\" ) {\r\n\r\n\t\t\t// ( types [, fn] )\r\n\t\t\tfn = selector;\r\n\t\t\tselector = undefined;\r\n\t\t}\r\n\t\tif ( fn === false ) {\r\n\t\t\tfn = returnFalse;\r\n\t\t}\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.event.remove( this, types, fn, selector );\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\n\r\nvar\r\n\r\n\t/* eslint-disable max-len */\r\n\r\n\t// See https://github.com/eslint/eslint/issues/3229\r\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\r\n\r\n\t/* eslint-enable */\r\n\r\n\t// Support: IE <=10 - 11, Edge 12 - 13\r\n\t// In IE/Edge using regex groups here causes severe slowdowns.\r\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\r\n\trnoInnerhtml = /<script|<style|<link/i,\r\n\r\n\t// checked=\"checked\" or checked\r\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\r\n\trscriptTypeMasked = /^true\\/(.*)/,\r\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\r\n\r\n// Prefer a tbody over its parent table for containing new rows\r\nfunction manipulationTarget( elem, content ) {\r\n\tif ( nodeName( elem, \"table\" ) &&\r\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\r\n\r\n\t\treturn jQuery( \">tbody\", elem )[ 0 ] || elem;\r\n\t}\r\n\r\n\treturn elem;\r\n}\r\n\r\n// Replace/restore the type attribute of script elements for safe DOM manipulation\r\nfunction disableScript( elem ) {\r\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\r\n\treturn elem;\r\n}\r\nfunction restoreScript( elem ) {\r\n\tvar match = rscriptTypeMasked.exec( elem.type );\r\n\r\n\tif ( match ) {\r\n\t\telem.type = match[ 1 ];\r\n\t} else {\r\n\t\telem.removeAttribute( \"type\" );\r\n\t}\r\n\r\n\treturn elem;\r\n}\r\n\r\nfunction cloneCopyEvent( src, dest ) {\r\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\r\n\r\n\tif ( dest.nodeType !== 1 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 1. Copy private data: events, handlers, etc.\r\n\tif ( dataPriv.hasData( src ) ) {\r\n\t\tpdataOld = dataPriv.access( src );\r\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\r\n\t\tevents = pdataOld.events;\r\n\r\n\t\tif ( events ) {\r\n\t\t\tdelete pdataCur.handle;\r\n\t\t\tpdataCur.events = {};\r\n\r\n\t\t\tfor ( type in events ) {\r\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\r\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 2. Copy user data\r\n\tif ( dataUser.hasData( src ) ) {\r\n\t\tudataOld = dataUser.access( src );\r\n\t\tudataCur = jQuery.extend( {}, udataOld );\r\n\r\n\t\tdataUser.set( dest, udataCur );\r\n\t}\r\n}\r\n\r\n// Fix IE bugs, see support tests\r\nfunction fixInput( src, dest ) {\r\n\tvar nodeName = dest.nodeName.toLowerCase();\r\n\r\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\r\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\r\n\t\tdest.checked = src.checked;\r\n\r\n\t// Fails to return the selected option to the default selected state when cloning options\r\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\r\n\t\tdest.defaultValue = src.defaultValue;\r\n\t}\r\n}\r\n\r\nfunction domManip( collection, args, callback, ignored ) {\r\n\r\n\t// Flatten any nested arrays\r\n\targs = concat.apply( [], args );\r\n\r\n\tvar fragment, first, scripts, hasScripts, node, doc,\r\n\t\ti = 0,\r\n\t\tl = collection.length,\r\n\t\tiNoClone = l - 1,\r\n\t\tvalue = args[ 0 ],\r\n\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t// We can't cloneNode fragments that contain checked, in WebKit\r\n\tif ( isFunction ||\r\n\t\t\t( l > 1 && typeof value === \"string\" &&\r\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\r\n\t\treturn collection.each( function( index ) {\r\n\t\t\tvar self = collection.eq( index );\r\n\t\t\tif ( isFunction ) {\r\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\r\n\t\t\t}\r\n\t\t\tdomManip( self, args, callback, ignored );\r\n\t\t} );\r\n\t}\r\n\r\n\tif ( l ) {\r\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\r\n\t\tfirst = fragment.firstChild;\r\n\r\n\t\tif ( fragment.childNodes.length === 1 ) {\r\n\t\t\tfragment = first;\r\n\t\t}\r\n\r\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\r\n\t\tif ( first || ignored ) {\r\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\r\n\t\t\thasScripts = scripts.length;\r\n\r\n\t\t\t// Use the original fragment for the last item\r\n\t\t\t// instead of the first because it can end up\r\n\t\t\t// being emptied incorrectly in certain situations (#8070).\r\n\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\tnode = fragment;\r\n\r\n\t\t\t\tif ( i !== iNoClone ) {\r\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\r\n\r\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\r\n\t\t\t\t\tif ( hasScripts ) {\r\n\r\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\r\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\r\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallback.call( collection[ i ], node, i );\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasScripts ) {\r\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\r\n\r\n\t\t\t\t// Reenable scripts\r\n\t\t\t\tjQuery.map( scripts, restoreScript );\r\n\r\n\t\t\t\t// Evaluate executable scripts on first document insertion\r\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\r\n\t\t\t\t\tnode = scripts[ i ];\r\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\r\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\r\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\r\n\r\n\t\t\t\t\t\tif ( node.src ) {\r\n\r\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\r\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\r\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn collection;\r\n}\r\n\r\nfunction remove( elem, selector, keepData ) {\r\n\tvar node,\r\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\r\n\t\ti = 0;\r\n\r\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\r\n\t\tif ( !keepData && node.nodeType === 1 ) {\r\n\t\t\tjQuery.cleanData( getAll( node ) );\r\n\t\t}\r\n\r\n\t\tif ( node.parentNode ) {\r\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\r\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\r\n\t\t\t}\r\n\t\t\tnode.parentNode.removeChild( node );\r\n\t\t}\r\n\t}\r\n\r\n\treturn elem;\r\n}\r\n\r\njQuery.extend( {\r\n\thtmlPrefilter: function( html ) {\r\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\r\n\t},\r\n\r\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\r\n\t\tvar i, l, srcElements, destElements,\r\n\t\t\tclone = elem.cloneNode( true ),\r\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t// Fix IE cloning issues\r\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\r\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\r\n\r\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\r\n\t\t\tdestElements = getAll( clone );\r\n\t\t\tsrcElements = getAll( elem );\r\n\r\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Copy the events from the original to the clone\r\n\t\tif ( dataAndEvents ) {\r\n\t\t\tif ( deepDataAndEvents ) {\r\n\t\t\t\tsrcElements = srcElements || getAll( elem );\r\n\t\t\t\tdestElements = destElements || getAll( clone );\r\n\r\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcloneCopyEvent( elem, clone );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Preserve script evaluation history\r\n\t\tdestElements = getAll( clone, \"script\" );\r\n\t\tif ( destElements.length > 0 ) {\r\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\r\n\t\t}\r\n\r\n\t\t// Return the cloned set\r\n\t\treturn clone;\r\n\t},\r\n\r\n\tcleanData: function( elems ) {\r\n\t\tvar data, elem, type,\r\n\t\t\tspecial = jQuery.event.special,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\r\n\t\t\tif ( acceptData( elem ) ) {\r\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\r\n\t\t\t\t\tif ( data.events ) {\r\n\t\t\t\t\t\tfor ( type in data.events ) {\r\n\t\t\t\t\t\t\tif ( special[ type ] ) {\r\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\r\n\r\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Support: Chrome <=35 - 45+\r\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\r\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\r\n\r\n\t\t\t\t\t// Support: Chrome <=35 - 45+\r\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\r\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\tdetach: function( selector ) {\r\n\t\treturn remove( this, selector, true );\r\n\t},\r\n\r\n\tremove: function( selector ) {\r\n\t\treturn remove( this, selector );\r\n\t},\r\n\r\n\ttext: function( value ) {\r\n\t\treturn access( this, function( value ) {\r\n\t\t\treturn value === undefined ?\r\n\t\t\t\tjQuery.text( this ) :\r\n\t\t\t\tthis.empty().each( function() {\r\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\t\t\tthis.textContent = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\tappend: function() {\r\n\t\treturn domManip( this, arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.appendChild( elem );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tprepend: function() {\r\n\t\treturn domManip( this, arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tbefore: function() {\r\n\t\treturn domManip( this, arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tafter: function() {\r\n\t\treturn domManip( this, arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\tempty: function() {\r\n\t\tvar elem,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\r\n\t\t\tif ( elem.nodeType === 1 ) {\r\n\r\n\t\t\t\t// Prevent memory leaks\r\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\r\n\t\t\t\t// Remove any remaining nodes\r\n\t\t\t\telem.textContent = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\r\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\r\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\r\n\r\n\t\treturn this.map( function() {\r\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\r\n\t\t} );\r\n\t},\r\n\r\n\thtml: function( value ) {\r\n\t\treturn access( this, function( value ) {\r\n\t\t\tvar elem = this[ 0 ] || {},\r\n\t\t\t\ti = 0,\r\n\t\t\t\tl = this.length;\r\n\r\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\r\n\t\t\t\treturn elem.innerHTML;\r\n\t\t\t}\r\n\r\n\t\t\t// See if we can take a shortcut and just use innerHTML\r\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\r\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\r\n\r\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\t\telem = this[ i ] || {};\r\n\r\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\r\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\t\t\t\t\t\t\telem.innerHTML = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telem = 0;\r\n\r\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\r\n\t\t\t\t} catch ( e ) {}\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem ) {\r\n\t\t\t\tthis.empty().append( value );\r\n\t\t\t}\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\treplaceWith: function() {\r\n\t\tvar ignored = [];\r\n\r\n\t\t// Make the changes, replacing each non-ignored context element with the new content\r\n\t\treturn domManip( this, arguments, function( elem ) {\r\n\t\t\tvar parent = this.parentNode;\r\n\r\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\r\n\t\t\t\tjQuery.cleanData( getAll( this ) );\r\n\t\t\t\tif ( parent ) {\r\n\t\t\t\t\tparent.replaceChild( elem, this );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Force callback invocation\r\n\t\t}, ignored );\r\n\t}\r\n} );\r\n\r\njQuery.each( {\r\n\tappendTo: \"append\",\r\n\tprependTo: \"prepend\",\r\n\tinsertBefore: \"before\",\r\n\tinsertAfter: \"after\",\r\n\treplaceAll: \"replaceWith\"\r\n}, function( name, original ) {\r\n\tjQuery.fn[ name ] = function( selector ) {\r\n\t\tvar elems,\r\n\t\t\tret = [],\r\n\t\t\tinsert = jQuery( selector ),\r\n\t\t\tlast = insert.length - 1,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; i <= last; i++ ) {\r\n\t\t\telems = i === last ? this : this.clone( true );\r\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\r\n\r\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\r\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\r\n\t\t\tpush.apply( ret, elems.get() );\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( ret );\r\n\t};\r\n} );\r\nvar rmargin = ( /^margin/ );\r\n\r\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\r\n\r\nvar getStyles = function( elem ) {\r\n\r\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\r\n\t\t// IE throws on elements created in popups\r\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\r\n\t\tvar view = elem.ownerDocument.defaultView;\r\n\r\n\t\tif ( !view || !view.opener ) {\r\n\t\t\tview = window;\r\n\t\t}\r\n\r\n\t\treturn view.getComputedStyle( elem );\r\n\t};\r\n\r\n\r\n\r\n( function() {\r\n\r\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\r\n\t// so they're executed at the same time to save the second computation.\r\n\tfunction computeStyleTests() {\r\n\r\n\t\t// This is a singleton, we need to execute it only once\r\n\t\tif ( !div ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdiv.style.cssText =\r\n\t\t\t\"box-sizing:border-box;\" +\r\n\t\t\t\"position:relative;display:block;\" +\r\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\r\n\t\t\t\"top:1%;width:50%\";\r\n\t\tdiv.innerHTML = \"\";\r\n\t\tdocumentElement.appendChild( container );\r\n\r\n\t\tvar divStyle = window.getComputedStyle( div );\r\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\r\n\r\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\r\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\r\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\r\n\r\n\t\t// Support: Android 4.0 - 4.3 only\r\n\t\t// Some styles come back with percentage values, even though they shouldn't\r\n\t\tdiv.style.marginRight = \"50%\";\r\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\r\n\r\n\t\tdocumentElement.removeChild( container );\r\n\r\n\t\t// Nullify the div so it wouldn't be stored in the memory and\r\n\t\t// it will also be a sign that checks already performed\r\n\t\tdiv = null;\r\n\t}\r\n\r\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\r\n\t\tcontainer = document.createElement( \"div\" ),\r\n\t\tdiv = document.createElement( \"div\" );\r\n\r\n\t// Finish early in limited (non-browser) environments\r\n\tif ( !div.style ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Support: IE <=9 - 11 only\r\n\t// Style of cloned element affects source element cloned (#8908)\r\n\tdiv.style.backgroundClip = \"content-box\";\r\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\r\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\r\n\r\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\r\n\t\t\"padding:0;margin-top:1px;position:absolute\";\r\n\tcontainer.appendChild( div );\r\n\r\n\tjQuery.extend( support, {\r\n\t\tpixelPosition: function() {\r\n\t\t\tcomputeStyleTests();\r\n\t\t\treturn pixelPositionVal;\r\n\t\t},\r\n\t\tboxSizingReliable: function() {\r\n\t\t\tcomputeStyleTests();\r\n\t\t\treturn boxSizingReliableVal;\r\n\t\t},\r\n\t\tpixelMarginRight: function() {\r\n\t\t\tcomputeStyleTests();\r\n\t\t\treturn pixelMarginRightVal;\r\n\t\t},\r\n\t\treliableMarginLeft: function() {\r\n\t\t\tcomputeStyleTests();\r\n\t\t\treturn reliableMarginLeftVal;\r\n\t\t}\r\n\t} );\r\n} )();\r\n\r\n\r\nfunction curCSS( elem, name, computed ) {\r\n\tvar width, minWidth, maxWidth, ret,\r\n\r\n\t\t// Support: Firefox 51+\r\n\t\t// Retrieving style before computed somehow\r\n\t\t// fixes an issue with getting wrong values\r\n\t\t// on detached elements\r\n\t\tstyle = elem.style;\r\n\r\n\tcomputed = computed || getStyles( elem );\r\n\r\n\t// getPropertyValue is needed for:\r\n\t//   .css('filter') (IE 9 only, #12537)\r\n\t//   .css('--customProperty) (#3144)\r\n\tif ( computed ) {\r\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\r\n\r\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\r\n\t\t\tret = jQuery.style( elem, name );\r\n\t\t}\r\n\r\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\r\n\t\t// Android Browser returns percentage for some values,\r\n\t\t// but width seems to be reliably pixels.\r\n\t\t// This is against the CSSOM draft spec:\r\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\r\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\r\n\r\n\t\t\t// Remember the original values\r\n\t\t\twidth = style.width;\r\n\t\t\tminWidth = style.minWidth;\r\n\t\t\tmaxWidth = style.maxWidth;\r\n\r\n\t\t\t// Put in the new values to get a computed value out\r\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\r\n\t\t\tret = computed.width;\r\n\r\n\t\t\t// Revert the changed values\r\n\t\t\tstyle.width = width;\r\n\t\t\tstyle.minWidth = minWidth;\r\n\t\t\tstyle.maxWidth = maxWidth;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret !== undefined ?\r\n\r\n\t\t// Support: IE <=9 - 11 only\r\n\t\t// IE returns zIndex value as an integer.\r\n\t\tret + \"\" :\r\n\t\tret;\r\n}\r\n\r\n\r\nfunction addGetHookIf( conditionFn, hookFn ) {\r\n\r\n\t// Define the hook, we'll check on the first run if it's really needed.\r\n\treturn {\r\n\t\tget: function() {\r\n\t\t\tif ( conditionFn() ) {\r\n\r\n\t\t\t\t// Hook not needed (or it's not possible to use it due\r\n\t\t\t\t// to missing dependency), remove it.\r\n\t\t\t\tdelete this.get;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\r\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\r\n\t\t}\r\n\t};\r\n}\r\n\r\n\r\nvar\r\n\r\n\t// Swappable if display is none or starts with table\r\n\t// except \"table\", \"table-cell\", or \"table-caption\"\r\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\r\n\trcustomProp = /^--/,\r\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\r\n\tcssNormalTransform = {\r\n\t\tletterSpacing: \"0\",\r\n\t\tfontWeight: \"400\"\r\n\t},\r\n\r\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\r\n\temptyStyle = document.createElement( \"div\" ).style;\r\n\r\n// Return a css property mapped to a potentially vendor prefixed property\r\nfunction vendorPropName( name ) {\r\n\r\n\t// Shortcut for names that are not vendor prefixed\r\n\tif ( name in emptyStyle ) {\r\n\t\treturn name;\r\n\t}\r\n\r\n\t// Check for vendor prefixed names\r\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\r\n\t\ti = cssPrefixes.length;\r\n\r\n\twhile ( i-- ) {\r\n\t\tname = cssPrefixes[ i ] + capName;\r\n\t\tif ( name in emptyStyle ) {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Return a property mapped along what jQuery.cssProps suggests or to\r\n// a vendor prefixed property.\r\nfunction finalPropName( name ) {\r\n\tvar ret = jQuery.cssProps[ name ];\r\n\tif ( !ret ) {\r\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction setPositiveNumber( elem, value, subtract ) {\r\n\r\n\t// Any relative (+/-) values have already been\r\n\t// normalized at this point\r\n\tvar matches = rcssNum.exec( value );\r\n\treturn matches ?\r\n\r\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\r\n\t\tvalue;\r\n}\r\n\r\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\r\n\tvar i,\r\n\t\tval = 0;\r\n\r\n\t// If we already have the right measurement, avoid augmentation\r\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\r\n\t\ti = 4;\r\n\r\n\t// Otherwise initialize for horizontal or vertical properties\r\n\t} else {\r\n\t\ti = name === \"width\" ? 1 : 0;\r\n\t}\r\n\r\n\tfor ( ; i < 4; i += 2 ) {\r\n\r\n\t\t// Both box models exclude margin, so add it if we want it\r\n\t\tif ( extra === \"margin\" ) {\r\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\r\n\t\t}\r\n\r\n\t\tif ( isBorderBox ) {\r\n\r\n\t\t\t// border-box includes padding, so remove it if we want content\r\n\t\t\tif ( extra === \"content\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\t\t\t}\r\n\r\n\t\t\t// At this point, extra isn't border nor margin, so remove border\r\n\t\t\tif ( extra !== \"margin\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t} else {\r\n\r\n\t\t\t// At this point, extra isn't content, so add padding\r\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\r\n\t\t\t// At this point, extra isn't content nor padding, so add border\r\n\t\t\tif ( extra !== \"padding\" ) {\r\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn val;\r\n}\r\n\r\nfunction getWidthOrHeight( elem, name, extra ) {\r\n\r\n\t// Start with computed style\r\n\tvar valueIsBorderBox,\r\n\t\tstyles = getStyles( elem ),\r\n\t\tval = curCSS( elem, name, styles ),\r\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\r\n\r\n\t// Computed unit is not pixels. Stop here and return.\r\n\tif ( rnumnonpx.test( val ) ) {\r\n\t\treturn val;\r\n\t}\r\n\r\n\t// Check for style in case a browser which returns unreliable values\r\n\t// for getComputedStyle silently falls back to the reliable elem.style\r\n\tvalueIsBorderBox = isBorderBox &&\r\n\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\r\n\r\n\t// Fall back to offsetWidth/Height when value is \"auto\"\r\n\t// This happens for inline elements with no explicit setting (gh-3571)\r\n\tif ( val === \"auto\" ) {\r\n\t\tval = elem[ \"offset\" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\r\n\t}\r\n\r\n\t// Normalize \"\", auto, and prepare for extra\r\n\tval = parseFloat( val ) || 0;\r\n\r\n\t// Use the active box-sizing model to add/subtract irrelevant styles\r\n\treturn ( val +\r\n\t\taugmentWidthOrHeight(\r\n\t\t\telem,\r\n\t\t\tname,\r\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\r\n\t\t\tvalueIsBorderBox,\r\n\t\t\tstyles\r\n\t\t)\r\n\t) + \"px\";\r\n}\r\n\r\njQuery.extend( {\r\n\r\n\t// Add in style property hooks for overriding the default\r\n\t// behavior of getting and setting a style property\r\n\tcssHooks: {\r\n\t\topacity: {\r\n\t\t\tget: function( elem, computed ) {\r\n\t\t\t\tif ( computed ) {\r\n\r\n\t\t\t\t\t// We should always get a number back from opacity\r\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\r\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Don't automatically add \"px\" to these possibly-unitless properties\r\n\tcssNumber: {\r\n\t\t\"animationIterationCount\": true,\r\n\t\t\"columnCount\": true,\r\n\t\t\"fillOpacity\": true,\r\n\t\t\"flexGrow\": true,\r\n\t\t\"flexShrink\": true,\r\n\t\t\"fontWeight\": true,\r\n\t\t\"lineHeight\": true,\r\n\t\t\"opacity\": true,\r\n\t\t\"order\": true,\r\n\t\t\"orphans\": true,\r\n\t\t\"widows\": true,\r\n\t\t\"zIndex\": true,\r\n\t\t\"zoom\": true\r\n\t},\r\n\r\n\t// Add in properties whose names you wish to fix before\r\n\t// setting or getting the value\r\n\tcssProps: {\r\n\t\t\"float\": \"cssFloat\"\r\n\t},\r\n\r\n\t// Get and set the style property on a DOM Node\r\n\tstyle: function( elem, name, value, extra ) {\r\n\r\n\t\t// Don't set styles on text and comment nodes\r\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure that we're working with the right name\r\n\t\tvar ret, type, hooks,\r\n\t\t\torigName = jQuery.camelCase( name ),\r\n\t\t\tisCustomProp = rcustomProp.test( name ),\r\n\t\t\tstyle = elem.style;\r\n\r\n\t\t// Make sure that we're working with the right name. We don't\r\n\t\t// want to query the value if it is a CSS custom property\r\n\t\t// since they are user-defined.\r\n\t\tif ( !isCustomProp ) {\r\n\t\t\tname = finalPropName( origName );\r\n\t\t}\r\n\r\n\t\t// Gets hook for the prefixed version, then unprefixed version\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// Check if we're setting a value\r\n\t\tif ( value !== undefined ) {\r\n\t\t\ttype = typeof value;\r\n\r\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\r\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\r\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\r\n\r\n\t\t\t\t// Fixes bug #9237\r\n\t\t\t\ttype = \"number\";\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\r\n\t\t\tif ( value == null || value !== value ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\r\n\t\t\tif ( type === \"number\" ) {\r\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\r\n\t\t\t}\r\n\r\n\t\t\t// background-* props affect original clone's values\r\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\r\n\t\t\t\tstyle[ name ] = \"inherit\";\r\n\t\t\t}\r\n\r\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\r\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\r\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\r\n\r\n\t\t\t\tif ( isCustomProp ) {\r\n\t\t\t\t\tstyle.setProperty( name, value );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyle[ name ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// If a hook was provided get the non-computed value from there\r\n\t\t\tif ( hooks && \"get\" in hooks &&\r\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\r\n\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise just get the value from the style object\r\n\t\t\treturn style[ name ];\r\n\t\t}\r\n\t},\r\n\r\n\tcss: function( elem, name, extra, styles ) {\r\n\t\tvar val, num, hooks,\r\n\t\t\torigName = jQuery.camelCase( name ),\r\n\t\t\tisCustomProp = rcustomProp.test( name );\r\n\r\n\t\t// Make sure that we're working with the right name. We don't\r\n\t\t// want to modify the value if it is a CSS custom property\r\n\t\t// since they are user-defined.\r\n\t\tif ( !isCustomProp ) {\r\n\t\t\tname = finalPropName( origName );\r\n\t\t}\r\n\r\n\t\t// Try prefixed name followed by the unprefixed name\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// If a hook was provided get the computed value from there\r\n\t\tif ( hooks && \"get\" in hooks ) {\r\n\t\t\tval = hooks.get( elem, true, extra );\r\n\t\t}\r\n\r\n\t\t// Otherwise, if a way to get the computed value exists, use that\r\n\t\tif ( val === undefined ) {\r\n\t\t\tval = curCSS( elem, name, styles );\r\n\t\t}\r\n\r\n\t\t// Convert \"normal\" to computed value\r\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\r\n\t\t\tval = cssNormalTransform[ name ];\r\n\t\t}\r\n\r\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\r\n\t\tif ( extra === \"\" || extra ) {\r\n\t\t\tnum = parseFloat( val );\r\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\r\n\t\t}\r\n\r\n\t\treturn val;\r\n\t}\r\n} );\r\n\r\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\r\n\tjQuery.cssHooks[ name ] = {\r\n\t\tget: function( elem, computed, extra ) {\r\n\t\t\tif ( computed ) {\r\n\r\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\r\n\t\t\t\t// but it must have a current display style that would benefit\r\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\r\n\r\n\t\t\t\t\t// Support: Safari 8+\r\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\r\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\r\n\t\t\t\t\t// Support: IE <=11 only\r\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\r\n\t\t\t\t\t// in IE throws an error.\r\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\r\n\t\t\t\t\t\tswap( elem, cssShow, function() {\r\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\r\n\t\t\t\t\t\t} ) :\r\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tset: function( elem, value, extra ) {\r\n\t\t\tvar matches,\r\n\t\t\t\tstyles = extra && getStyles( elem ),\r\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\r\n\t\t\t\t\telem,\r\n\t\t\t\t\tname,\r\n\t\t\t\t\textra,\r\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\r\n\t\t\t\t\tstyles\r\n\t\t\t\t);\r\n\r\n\t\t\t// Convert to pixels if value adjustment is needed\r\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\r\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\r\n\r\n\t\t\t\telem.style[ name ] = value;\r\n\t\t\t\tvalue = jQuery.css( elem, name );\r\n\t\t\t}\r\n\r\n\t\t\treturn setPositiveNumber( elem, value, subtract );\r\n\t\t}\r\n\t};\r\n} );\r\n\r\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\r\n\tfunction( elem, computed ) {\r\n\t\tif ( computed ) {\r\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\r\n\t\t\t\telem.getBoundingClientRect().left -\r\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\r\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\r\n\t\t\t\t\t} )\r\n\t\t\t\t) + \"px\";\r\n\t\t}\r\n\t}\r\n);\r\n\r\n// These hooks are used by animate to expand properties\r\njQuery.each( {\r\n\tmargin: \"\",\r\n\tpadding: \"\",\r\n\tborder: \"Width\"\r\n}, function( prefix, suffix ) {\r\n\tjQuery.cssHooks[ prefix + suffix ] = {\r\n\t\texpand: function( value ) {\r\n\t\t\tvar i = 0,\r\n\t\t\t\texpanded = {},\r\n\r\n\t\t\t\t// Assumes a single number if not a string\r\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\r\n\r\n\t\t\tfor ( ; i < 4; i++ ) {\r\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\r\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\r\n\t\t\t}\r\n\r\n\t\t\treturn expanded;\r\n\t\t}\r\n\t};\r\n\r\n\tif ( !rmargin.test( prefix ) ) {\r\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\r\n\t}\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\tcss: function( name, value ) {\r\n\t\treturn access( this, function( elem, name, value ) {\r\n\t\t\tvar styles, len,\r\n\t\t\t\tmap = {},\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\tif ( Array.isArray( name ) ) {\r\n\t\t\t\tstyles = getStyles( elem );\r\n\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn map;\r\n\t\t\t}\r\n\r\n\t\t\treturn value !== undefined ?\r\n\t\t\t\tjQuery.style( elem, name, value ) :\r\n\t\t\t\tjQuery.css( elem, name );\r\n\t\t}, name, value, arguments.length > 1 );\r\n\t}\r\n} );\r\n\r\n\r\nfunction Tween( elem, options, prop, end, easing ) {\r\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\r\n}\r\njQuery.Tween = Tween;\r\n\r\nTween.prototype = {\r\n\tconstructor: Tween,\r\n\tinit: function( elem, options, prop, end, easing, unit ) {\r\n\t\tthis.elem = elem;\r\n\t\tthis.prop = prop;\r\n\t\tthis.easing = easing || jQuery.easing._default;\r\n\t\tthis.options = options;\r\n\t\tthis.start = this.now = this.cur();\r\n\t\tthis.end = end;\r\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\r\n\t},\r\n\tcur: function() {\r\n\t\tvar hooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\treturn hooks && hooks.get ?\r\n\t\t\thooks.get( this ) :\r\n\t\t\tTween.propHooks._default.get( this );\r\n\t},\r\n\trun: function( percent ) {\r\n\t\tvar eased,\r\n\t\t\thooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\tif ( this.options.duration ) {\r\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\r\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tthis.pos = eased = percent;\r\n\t\t}\r\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\r\n\r\n\t\tif ( this.options.step ) {\r\n\t\t\tthis.options.step.call( this.elem, this.now, this );\r\n\t\t}\r\n\r\n\t\tif ( hooks && hooks.set ) {\r\n\t\t\thooks.set( this );\r\n\t\t} else {\r\n\t\t\tTween.propHooks._default.set( this );\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\nTween.prototype.init.prototype = Tween.prototype;\r\n\r\nTween.propHooks = {\r\n\t_default: {\r\n\t\tget: function( tween ) {\r\n\t\t\tvar result;\r\n\r\n\t\t\t// Use a property on the element directly when it is not a DOM element,\r\n\t\t\t// or when there is no matching style property that exists.\r\n\t\t\tif ( tween.elem.nodeType !== 1 ||\r\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\r\n\t\t\t\treturn tween.elem[ tween.prop ];\r\n\t\t\t}\r\n\r\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\r\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\r\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\r\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\r\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\r\n\r\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\r\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\r\n\t\t},\r\n\t\tset: function( tween ) {\r\n\r\n\t\t\t// Use step hook for back compat.\r\n\t\t\t// Use cssHook if its there.\r\n\t\t\t// Use .style if available and use plain properties where available.\r\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\r\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\r\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\r\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\r\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\r\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\r\n\t\t\t} else {\r\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Support: IE <=9 only\r\n// Panic based approach to setting things on disconnected nodes\r\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n\tset: function( tween ) {\r\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\r\n\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.easing = {\r\n\tlinear: function( p ) {\r\n\t\treturn p;\r\n\t},\r\n\tswing: function( p ) {\r\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\r\n\t},\r\n\t_default: \"swing\"\r\n};\r\n\r\njQuery.fx = Tween.prototype.init;\r\n\r\n// Back compat <1.8 extension point\r\njQuery.fx.step = {};\r\n\r\n\r\n\r\n\r\nvar\r\n\tfxNow, inProgress,\r\n\trfxtypes = /^(?:toggle|show|hide)$/,\r\n\trrun = /queueHooks$/;\r\n\r\nfunction schedule() {\r\n\tif ( inProgress ) {\r\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\r\n\t\t\twindow.requestAnimationFrame( schedule );\r\n\t\t} else {\r\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\r\n\t\t}\r\n\r\n\t\tjQuery.fx.tick();\r\n\t}\r\n}\r\n\r\n// Animations created synchronously will run synchronously\r\nfunction createFxNow() {\r\n\twindow.setTimeout( function() {\r\n\t\tfxNow = undefined;\r\n\t} );\r\n\treturn ( fxNow = jQuery.now() );\r\n}\r\n\r\n// Generate parameters to create a standard animation\r\nfunction genFx( type, includeWidth ) {\r\n\tvar which,\r\n\t\ti = 0,\r\n\t\tattrs = { height: type };\r\n\r\n\t// If we include width, step value is 1 to do all cssExpand values,\r\n\t// otherwise step value is 2 to skip over Left and Right\r\n\tincludeWidth = includeWidth ? 1 : 0;\r\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\r\n\t\twhich = cssExpand[ i ];\r\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\r\n\t}\r\n\r\n\tif ( includeWidth ) {\r\n\t\tattrs.opacity = attrs.width = type;\r\n\t}\r\n\r\n\treturn attrs;\r\n}\r\n\r\nfunction createTween( value, prop, animation ) {\r\n\tvar tween,\r\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\r\n\t\tindex = 0,\r\n\t\tlength = collection.length;\r\n\tfor ( ; index < length; index++ ) {\r\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\r\n\r\n\t\t\t// We're done with this property\r\n\t\t\treturn tween;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction defaultPrefilter( elem, props, opts ) {\r\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\r\n\t\tisBox = \"width\" in props || \"height\" in props,\r\n\t\tanim = this,\r\n\t\torig = {},\r\n\t\tstyle = elem.style,\r\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\r\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\r\n\r\n\t// Queue-skipping animations hijack the fx hooks\r\n\tif ( !opts.queue ) {\r\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\r\n\t\tif ( hooks.unqueued == null ) {\r\n\t\t\thooks.unqueued = 0;\r\n\t\t\toldfire = hooks.empty.fire;\r\n\t\t\thooks.empty.fire = function() {\r\n\t\t\t\tif ( !hooks.unqueued ) {\r\n\t\t\t\t\toldfire();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\thooks.unqueued++;\r\n\r\n\t\tanim.always( function() {\r\n\r\n\t\t\t// Ensure the complete handler is called before this completes\r\n\t\t\tanim.always( function() {\r\n\t\t\t\thooks.unqueued--;\r\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\r\n\t\t\t\t\thooks.empty.fire();\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\t// Detect show/hide animations\r\n\tfor ( prop in props ) {\r\n\t\tvalue = props[ prop ];\r\n\t\tif ( rfxtypes.test( value ) ) {\r\n\t\t\tdelete props[ prop ];\r\n\t\t\ttoggle = toggle || value === \"toggle\";\r\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\r\n\r\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\r\n\t\t\t\t// there is still data from a stopped show/hide\r\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\r\n\t\t\t\t\thidden = true;\r\n\r\n\t\t\t\t// Ignore all other no-op show/hide data\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\r\n\t\t}\r\n\t}\r\n\r\n\t// Bail out if this is a no-op like .hide().hide()\r\n\tpropTween = !jQuery.isEmptyObject( props );\r\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Restrict \"overflow\" and \"display\" styles during box animations\r\n\tif ( isBox && elem.nodeType === 1 ) {\r\n\r\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\r\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\r\n\t\t// from identically-valued overflowX and overflowY\r\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\r\n\r\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\r\n\t\trestoreDisplay = dataShow && dataShow.display;\r\n\t\tif ( restoreDisplay == null ) {\r\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\r\n\t\t}\r\n\t\tdisplay = jQuery.css( elem, \"display\" );\r\n\t\tif ( display === \"none\" ) {\r\n\t\t\tif ( restoreDisplay ) {\r\n\t\t\t\tdisplay = restoreDisplay;\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\r\n\t\t\t\tshowHide( [ elem ], true );\r\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\r\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\r\n\t\t\t\tshowHide( [ elem ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Animate inline elements as inline-block\r\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\r\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\r\n\r\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\r\n\t\t\t\tif ( !propTween ) {\r\n\t\t\t\t\tanim.done( function() {\r\n\t\t\t\t\t\tstyle.display = restoreDisplay;\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tif ( restoreDisplay == null ) {\r\n\t\t\t\t\t\tdisplay = style.display;\r\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstyle.display = \"inline-block\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( opts.overflow ) {\r\n\t\tstyle.overflow = \"hidden\";\r\n\t\tanim.always( function() {\r\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\r\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\r\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\r\n\t\t} );\r\n\t}\r\n\r\n\t// Implement show/hide animations\r\n\tpropTween = false;\r\n\tfor ( prop in orig ) {\r\n\r\n\t\t// General show/hide setup for this element animation\r\n\t\tif ( !propTween ) {\r\n\t\t\tif ( dataShow ) {\r\n\t\t\t\tif ( \"hidden\" in dataShow ) {\r\n\t\t\t\t\thidden = dataShow.hidden;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\r\n\t\t\t}\r\n\r\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\r\n\t\t\tif ( toggle ) {\r\n\t\t\t\tdataShow.hidden = !hidden;\r\n\t\t\t}\r\n\r\n\t\t\t// Show elements before animating them\r\n\t\t\tif ( hidden ) {\r\n\t\t\t\tshowHide( [ elem ], true );\r\n\t\t\t}\r\n\r\n\t\t\t/* eslint-disable no-loop-func */\r\n\r\n\t\t\tanim.done( function() {\r\n\r\n\t\t\t/* eslint-enable no-loop-func */\r\n\r\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\r\n\t\t\t\tif ( !hidden ) {\r\n\t\t\t\t\tshowHide( [ elem ] );\r\n\t\t\t\t}\r\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\r\n\t\t\t\tfor ( prop in orig ) {\r\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\t// Per-property setup\r\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\r\n\t\tif ( !( prop in dataShow ) ) {\r\n\t\t\tdataShow[ prop ] = propTween.start;\r\n\t\t\tif ( hidden ) {\r\n\t\t\t\tpropTween.end = propTween.start;\r\n\t\t\t\tpropTween.start = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction propFilter( props, specialEasing ) {\r\n\tvar index, name, easing, value, hooks;\r\n\r\n\t// camelCase, specialEasing and expand cssHook pass\r\n\tfor ( index in props ) {\r\n\t\tname = jQuery.camelCase( index );\r\n\t\teasing = specialEasing[ name ];\r\n\t\tvalue = props[ index ];\r\n\t\tif ( Array.isArray( value ) ) {\r\n\t\t\teasing = value[ 1 ];\r\n\t\t\tvalue = props[ index ] = value[ 0 ];\r\n\t\t}\r\n\r\n\t\tif ( index !== name ) {\r\n\t\t\tprops[ name ] = value;\r\n\t\t\tdelete props[ index ];\r\n\t\t}\r\n\r\n\t\thooks = jQuery.cssHooks[ name ];\r\n\t\tif ( hooks && \"expand\" in hooks ) {\r\n\t\t\tvalue = hooks.expand( value );\r\n\t\t\tdelete props[ name ];\r\n\r\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\r\n\t\t\t// Reusing 'index' because we have the correct \"name\"\r\n\t\t\tfor ( index in value ) {\r\n\t\t\t\tif ( !( index in props ) ) {\r\n\t\t\t\t\tprops[ index ] = value[ index ];\r\n\t\t\t\t\tspecialEasing[ index ] = easing;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tspecialEasing[ name ] = easing;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction Animation( elem, properties, options ) {\r\n\tvar result,\r\n\t\tstopped,\r\n\t\tindex = 0,\r\n\t\tlength = Animation.prefilters.length,\r\n\t\tdeferred = jQuery.Deferred().always( function() {\r\n\r\n\t\t\t// Don't match elem in the :animated selector\r\n\t\t\tdelete tick.elem;\r\n\t\t} ),\r\n\t\ttick = function() {\r\n\t\t\tif ( stopped ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar currentTime = fxNow || createFxNow(),\r\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\r\n\r\n\t\t\t\t// Support: Android 2.3 only\r\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\r\n\t\t\t\ttemp = remaining / animation.duration || 0,\r\n\t\t\t\tpercent = 1 - temp,\r\n\t\t\t\tindex = 0,\r\n\t\t\t\tlength = animation.tweens.length;\r\n\r\n\t\t\tfor ( ; index < length; index++ ) {\r\n\t\t\t\tanimation.tweens[ index ].run( percent );\r\n\t\t\t}\r\n\r\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\r\n\r\n\t\t\t// If there's more to do, yield\r\n\t\t\tif ( percent < 1 && length ) {\r\n\t\t\t\treturn remaining;\r\n\t\t\t}\r\n\r\n\t\t\t// If this was an empty animation, synthesize a final progress notification\r\n\t\t\tif ( !length ) {\r\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Resolve the animation and report its conclusion\r\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tanimation = deferred.promise( {\r\n\t\t\telem: elem,\r\n\t\t\tprops: jQuery.extend( {}, properties ),\r\n\t\t\topts: jQuery.extend( true, {\r\n\t\t\t\tspecialEasing: {},\r\n\t\t\t\teasing: jQuery.easing._default\r\n\t\t\t}, options ),\r\n\t\t\toriginalProperties: properties,\r\n\t\t\toriginalOptions: options,\r\n\t\t\tstartTime: fxNow || createFxNow(),\r\n\t\t\tduration: options.duration,\r\n\t\t\ttweens: [],\r\n\t\t\tcreateTween: function( prop, end ) {\r\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\r\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\r\n\t\t\t\tanimation.tweens.push( tween );\r\n\t\t\t\treturn tween;\r\n\t\t\t},\r\n\t\t\tstop: function( gotoEnd ) {\r\n\t\t\t\tvar index = 0,\r\n\r\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\r\n\t\t\t\t\t// otherwise we skip this part\r\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\r\n\t\t\t\tif ( stopped ) {\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t\tstopped = true;\r\n\t\t\t\tfor ( ; index < length; index++ ) {\r\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\r\n\t\t\t\tif ( gotoEnd ) {\r\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\r\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t} ),\r\n\t\tprops = animation.props;\r\n\r\n\tpropFilter( props, animation.opts.specialEasing );\r\n\r\n\tfor ( ; index < length; index++ ) {\r\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\r\n\t\tif ( result ) {\r\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\r\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\r\n\t\t\t\t\tjQuery.proxy( result.stop, result );\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\tjQuery.map( props, createTween, animation );\r\n\r\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\r\n\t\tanimation.opts.start.call( elem, animation );\r\n\t}\r\n\r\n\t// Attach callbacks from options\r\n\tanimation\r\n\t\t.progress( animation.opts.progress )\r\n\t\t.done( animation.opts.done, animation.opts.complete )\r\n\t\t.fail( animation.opts.fail )\r\n\t\t.always( animation.opts.always );\r\n\r\n\tjQuery.fx.timer(\r\n\t\tjQuery.extend( tick, {\r\n\t\t\telem: elem,\r\n\t\t\tanim: animation,\r\n\t\t\tqueue: animation.opts.queue\r\n\t\t} )\r\n\t);\r\n\r\n\treturn animation;\r\n}\r\n\r\njQuery.Animation = jQuery.extend( Animation, {\r\n\r\n\ttweeners: {\r\n\t\t\"*\": [ function( prop, value ) {\r\n\t\t\tvar tween = this.createTween( prop, value );\r\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\r\n\t\t\treturn tween;\r\n\t\t} ]\r\n\t},\r\n\r\n\ttweener: function( props, callback ) {\r\n\t\tif ( jQuery.isFunction( props ) ) {\r\n\t\t\tcallback = props;\r\n\t\t\tprops = [ \"*\" ];\r\n\t\t} else {\r\n\t\t\tprops = props.match( rnothtmlwhite );\r\n\t\t}\r\n\r\n\t\tvar prop,\r\n\t\t\tindex = 0,\r\n\t\t\tlength = props.length;\r\n\r\n\t\tfor ( ; index < length; index++ ) {\r\n\t\t\tprop = props[ index ];\r\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\r\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\r\n\t\t}\r\n\t},\r\n\r\n\tprefilters: [ defaultPrefilter ],\r\n\r\n\tprefilter: function( callback, prepend ) {\r\n\t\tif ( prepend ) {\r\n\t\t\tAnimation.prefilters.unshift( callback );\r\n\t\t} else {\r\n\t\t\tAnimation.prefilters.push( callback );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\njQuery.speed = function( speed, easing, fn ) {\r\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\r\n\t\tcomplete: fn || !fn && easing ||\r\n\t\t\tjQuery.isFunction( speed ) && speed,\r\n\t\tduration: speed,\r\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\r\n\t};\r\n\r\n\t// Go to the end state if fx are off\r\n\tif ( jQuery.fx.off ) {\r\n\t\topt.duration = 0;\r\n\r\n\t} else {\r\n\t\tif ( typeof opt.duration !== \"number\" ) {\r\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\r\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\r\n\r\n\t\t\t} else {\r\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\r\n\tif ( opt.queue == null || opt.queue === true ) {\r\n\t\topt.queue = \"fx\";\r\n\t}\r\n\r\n\t// Queueing\r\n\topt.old = opt.complete;\r\n\r\n\topt.complete = function() {\r\n\t\tif ( jQuery.isFunction( opt.old ) ) {\r\n\t\t\topt.old.call( this );\r\n\t\t}\r\n\r\n\t\tif ( opt.queue ) {\r\n\t\t\tjQuery.dequeue( this, opt.queue );\r\n\t\t}\r\n\t};\r\n\r\n\treturn opt;\r\n};\r\n\r\njQuery.fn.extend( {\r\n\tfadeTo: function( speed, to, easing, callback ) {\r\n\r\n\t\t// Show any hidden elements after setting opacity to 0\r\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\r\n\r\n\t\t\t// Animate to the value specified\r\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\r\n\t},\r\n\tanimate: function( prop, speed, easing, callback ) {\r\n\t\tvar empty = jQuery.isEmptyObject( prop ),\r\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\r\n\t\t\tdoAnimation = function() {\r\n\r\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\r\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\r\n\r\n\t\t\t\t// Empty animations, or finishing resolves immediately\r\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\r\n\t\t\t\t\tanim.stop( true );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tdoAnimation.finish = doAnimation;\r\n\r\n\t\treturn empty || optall.queue === false ?\r\n\t\t\tthis.each( doAnimation ) :\r\n\t\t\tthis.queue( optall.queue, doAnimation );\r\n\t},\r\n\tstop: function( type, clearQueue, gotoEnd ) {\r\n\t\tvar stopQueue = function( hooks ) {\r\n\t\t\tvar stop = hooks.stop;\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tstop( gotoEnd );\r\n\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tgotoEnd = clearQueue;\r\n\t\t\tclearQueue = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\tif ( clearQueue && type !== false ) {\r\n\t\t\tthis.queue( type || \"fx\", [] );\r\n\t\t}\r\n\r\n\t\treturn this.each( function() {\r\n\t\t\tvar dequeue = true,\r\n\t\t\t\tindex = type != null && type + \"queueHooks\",\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tdata = dataPriv.get( this );\r\n\r\n\t\t\tif ( index ) {\r\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\r\n\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( index in data ) {\r\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\r\n\t\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this &&\r\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\r\n\r\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\r\n\t\t\t\t\tdequeue = false;\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Start the next in the queue if the last step wasn't forced.\r\n\t\t\t// Timers currently will call their complete callbacks, which\r\n\t\t\t// will dequeue but only if they were gotoEnd.\r\n\t\t\tif ( dequeue || !gotoEnd ) {\r\n\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\tfinish: function( type ) {\r\n\t\tif ( type !== false ) {\r\n\t\t\ttype = type || \"fx\";\r\n\t\t}\r\n\t\treturn this.each( function() {\r\n\t\t\tvar index,\r\n\t\t\t\tdata = dataPriv.get( this ),\r\n\t\t\t\tqueue = data[ type + \"queue\" ],\r\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tlength = queue ? queue.length : 0;\r\n\r\n\t\t\t// Enable finishing flag on private data\r\n\t\t\tdata.finish = true;\r\n\r\n\t\t\t// Empty the queue first\r\n\t\t\tjQuery.queue( this, type, [] );\r\n\r\n\t\t\tif ( hooks && hooks.stop ) {\r\n\t\t\t\thooks.stop.call( this, true );\r\n\t\t\t}\r\n\r\n\t\t\t// Look for any active animations, and finish them\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\r\n\t\t\t\t\ttimers[ index ].anim.stop( true );\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Look for any animations in the old queue and finish them\r\n\t\t\tfor ( index = 0; index < length; index++ ) {\r\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\r\n\t\t\t\t\tqueue[ index ].finish.call( this );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Turn off finishing flag\r\n\t\t\tdelete data.finish;\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\r\n\tvar cssFn = jQuery.fn[ name ];\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn speed == null || typeof speed === \"boolean\" ?\r\n\t\t\tcssFn.apply( this, arguments ) :\r\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\r\n\t};\r\n} );\r\n\r\n// Generate shortcuts for custom animations\r\njQuery.each( {\r\n\tslideDown: genFx( \"show\" ),\r\n\tslideUp: genFx( \"hide\" ),\r\n\tslideToggle: genFx( \"toggle\" ),\r\n\tfadeIn: { opacity: \"show\" },\r\n\tfadeOut: { opacity: \"hide\" },\r\n\tfadeToggle: { opacity: \"toggle\" }\r\n}, function( name, props ) {\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn this.animate( props, speed, easing, callback );\r\n\t};\r\n} );\r\n\r\njQuery.timers = [];\r\njQuery.fx.tick = function() {\r\n\tvar timer,\r\n\t\ti = 0,\r\n\t\ttimers = jQuery.timers;\r\n\r\n\tfxNow = jQuery.now();\r\n\r\n\tfor ( ; i < timers.length; i++ ) {\r\n\t\ttimer = timers[ i ];\r\n\r\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\r\n\t\tif ( !timer() && timers[ i ] === timer ) {\r\n\t\t\ttimers.splice( i--, 1 );\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !timers.length ) {\r\n\t\tjQuery.fx.stop();\r\n\t}\r\n\tfxNow = undefined;\r\n};\r\n\r\njQuery.fx.timer = function( timer ) {\r\n\tjQuery.timers.push( timer );\r\n\tjQuery.fx.start();\r\n};\r\n\r\njQuery.fx.interval = 13;\r\njQuery.fx.start = function() {\r\n\tif ( inProgress ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinProgress = true;\r\n\tschedule();\r\n};\r\n\r\njQuery.fx.stop = function() {\r\n\tinProgress = null;\r\n};\r\n\r\njQuery.fx.speeds = {\r\n\tslow: 600,\r\n\tfast: 200,\r\n\r\n\t// Default speed\r\n\t_default: 400\r\n};\r\n\r\n\r\n// Based off of the plugin by Clint Helfers, with permission.\r\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\r\njQuery.fn.delay = function( time, type ) {\r\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\r\n\ttype = type || \"fx\";\r\n\r\n\treturn this.queue( type, function( next, hooks ) {\r\n\t\tvar timeout = window.setTimeout( next, time );\r\n\t\thooks.stop = function() {\r\n\t\t\twindow.clearTimeout( timeout );\r\n\t\t};\r\n\t} );\r\n};\r\n\r\n\r\n( function() {\r\n\tvar input = document.createElement( \"input\" ),\r\n\t\tselect = document.createElement( \"select\" ),\r\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\r\n\r\n\tinput.type = \"checkbox\";\r\n\r\n\t// Support: Android <=4.3 only\r\n\t// Default value for a checkbox should be \"on\"\r\n\tsupport.checkOn = input.value !== \"\";\r\n\r\n\t// Support: IE <=11 only\r\n\t// Must access selectedIndex to make default options select\r\n\tsupport.optSelected = opt.selected;\r\n\r\n\t// Support: IE <=11 only\r\n\t// An input loses its value after becoming a radio\r\n\tinput = document.createElement( \"input\" );\r\n\tinput.value = \"t\";\r\n\tinput.type = \"radio\";\r\n\tsupport.radioValue = input.value === \"t\";\r\n} )();\r\n\r\n\r\nvar boolHook,\r\n\tattrHandle = jQuery.expr.attrHandle;\r\n\r\njQuery.fn.extend( {\r\n\tattr: function( name, value ) {\r\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveAttr: function( name ) {\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.removeAttr( this, name );\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\njQuery.extend( {\r\n\tattr: function( elem, name, value ) {\r\n\t\tvar ret, hooks,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// Don't get/set attributes on text, comment and attribute nodes\r\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Fallback to prop when attributes are not supported\r\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\r\n\t\t\treturn jQuery.prop( elem, name, value );\r\n\t\t}\r\n\r\n\t\t// Attribute hooks are determined by the lowercase version\r\n\t\t// Grab necessary hook if one is defined\r\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\r\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\r\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\t\t\tif ( value === null ) {\r\n\t\t\t\tjQuery.removeAttr( elem, name );\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( hooks && \"set\" in hooks &&\r\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\telem.setAttribute( name, value + \"\" );\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tret = jQuery.find.attr( elem, name );\r\n\r\n\t\t// Non-existent attributes return null, we normalize to undefined\r\n\t\treturn ret == null ? undefined : ret;\r\n\t},\r\n\r\n\tattrHooks: {\r\n\t\ttype: {\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\r\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\r\n\t\t\t\t\tvar val = elem.value;\r\n\t\t\t\t\telem.setAttribute( \"type\", value );\r\n\t\t\t\t\tif ( val ) {\r\n\t\t\t\t\t\telem.value = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tremoveAttr: function( elem, value ) {\r\n\t\tvar name,\r\n\t\t\ti = 0,\r\n\r\n\t\t\t// Attribute names can contain non-HTML whitespace characters\r\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\r\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\r\n\r\n\t\tif ( attrNames && elem.nodeType === 1 ) {\r\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\r\n\t\t\t\telem.removeAttribute( name );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n// Hooks for boolean attributes\r\nboolHook = {\r\n\tset: function( elem, value, name ) {\r\n\t\tif ( value === false ) {\r\n\r\n\t\t\t// Remove boolean attributes when set to false\r\n\t\t\tjQuery.removeAttr( elem, name );\r\n\t\t} else {\r\n\t\t\telem.setAttribute( name, name );\r\n\t\t}\r\n\t\treturn name;\r\n\t}\r\n};\r\n\r\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\r\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\r\n\r\n\tattrHandle[ name ] = function( elem, name, isXML ) {\r\n\t\tvar ret, handle,\r\n\t\t\tlowercaseName = name.toLowerCase();\r\n\r\n\t\tif ( !isXML ) {\r\n\r\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\r\n\t\t\thandle = attrHandle[ lowercaseName ];\r\n\t\t\tattrHandle[ lowercaseName ] = ret;\r\n\t\t\tret = getter( elem, name, isXML ) != null ?\r\n\t\t\t\tlowercaseName :\r\n\t\t\t\tnull;\r\n\t\t\tattrHandle[ lowercaseName ] = handle;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n} );\r\n\r\n\r\n\r\n\r\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\r\n\trclickable = /^(?:a|area)$/i;\r\n\r\njQuery.fn.extend( {\r\n\tprop: function( name, value ) {\r\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveProp: function( name ) {\r\n\t\treturn this.each( function() {\r\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\njQuery.extend( {\r\n\tprop: function( elem, name, value ) {\r\n\t\tvar ret, hooks,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// Don't get/set properties on text, comment and attribute nodes\r\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\r\n\r\n\t\t\t// Fix name and attach hooks\r\n\t\t\tname = jQuery.propFix[ name ] || name;\r\n\t\t\thooks = jQuery.propHooks[ name ];\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\t\t\tif ( hooks && \"set\" in hooks &&\r\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\treturn ( elem[ name ] = value );\r\n\t\t}\r\n\r\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\treturn elem[ name ];\r\n\t},\r\n\r\n\tpropHooks: {\r\n\t\ttabIndex: {\r\n\t\t\tget: function( elem ) {\r\n\r\n\t\t\t\t// Support: IE <=9 - 11 only\r\n\t\t\t\t// elem.tabIndex doesn't always return the\r\n\t\t\t\t// correct value when it hasn't been explicitly set\r\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\r\n\t\t\t\t// Use proper attribute retrieval(#12072)\r\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\r\n\r\n\t\t\t\tif ( tabindex ) {\r\n\t\t\t\t\treturn parseInt( tabindex, 10 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\r\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\r\n\t\t\t\t\telem.href\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tpropFix: {\r\n\t\t\"for\": \"htmlFor\",\r\n\t\t\"class\": \"className\"\r\n\t}\r\n} );\r\n\r\n// Support: IE <=11 only\r\n// Accessing the selectedIndex property\r\n// forces the browser to respect setting selected\r\n// on the option\r\n// The getter ensures a default option is selected\r\n// when in an optgroup\r\n// eslint rule \"no-unused-expressions\" is disabled for this code\r\n// since it considers such accessions noop\r\nif ( !support.optSelected ) {\r\n\tjQuery.propHooks.selected = {\r\n\t\tget: function( elem ) {\r\n\r\n\t\t\t/* eslint no-unused-expressions: \"off\" */\r\n\r\n\t\t\tvar parent = elem.parentNode;\r\n\t\t\tif ( parent && parent.parentNode ) {\r\n\t\t\t\tparent.parentNode.selectedIndex;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\tset: function( elem ) {\r\n\r\n\t\t\t/* eslint no-unused-expressions: \"off\" */\r\n\r\n\t\t\tvar parent = elem.parentNode;\r\n\t\t\tif ( parent ) {\r\n\t\t\t\tparent.selectedIndex;\r\n\r\n\t\t\t\tif ( parent.parentNode ) {\r\n\t\t\t\t\tparent.parentNode.selectedIndex;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\njQuery.each( [\r\n\t\"tabIndex\",\r\n\t\"readOnly\",\r\n\t\"maxLength\",\r\n\t\"cellSpacing\",\r\n\t\"cellPadding\",\r\n\t\"rowSpan\",\r\n\t\"colSpan\",\r\n\t\"useMap\",\r\n\t\"frameBorder\",\r\n\t\"contentEditable\"\r\n], function() {\r\n\tjQuery.propFix[ this.toLowerCase() ] = this;\r\n} );\r\n\r\n\r\n\r\n\r\n\t// Strip and collapse whitespace according to HTML spec\r\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\r\n\tfunction stripAndCollapse( value ) {\r\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\r\n\t\treturn tokens.join( \" \" );\r\n\t}\r\n\r\n\r\nfunction getClass( elem ) {\r\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\r\n}\r\n\r\njQuery.fn.extend( {\r\n\taddClass: function( value ) {\r\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\r\n\t\t\ti = 0;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each( function( j ) {\r\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\tif ( typeof value === \"string\" && value ) {\r\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\r\n\r\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\r\n\t\t\t\tcurValue = getClass( elem );\r\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\r\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\r\n\t\t\t\t\t\t\tcur += clazz + \" \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\r\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\r\n\t\t\t\t\tif ( curValue !== finalValue ) {\r\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveClass: function( value ) {\r\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\r\n\t\t\ti = 0;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each( function( j ) {\r\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\tif ( !arguments.length ) {\r\n\t\t\treturn this.attr( \"class\", \"\" );\r\n\t\t}\r\n\r\n\t\tif ( typeof value === \"string\" && value ) {\r\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\r\n\r\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\r\n\t\t\t\tcurValue = getClass( elem );\r\n\r\n\t\t\t\t// This expression is here for better compressibility (see addClass)\r\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\r\n\r\n\t\t\t\t\t\t// Remove *all* instances\r\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\r\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\r\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\r\n\t\t\t\t\tif ( curValue !== finalValue ) {\r\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttoggleClass: function( value, stateVal ) {\r\n\t\tvar type = typeof value;\r\n\r\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\r\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\r\n\t\t}\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each( function( i ) {\r\n\t\t\t\tjQuery( this ).toggleClass(\r\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\r\n\t\t\t\t\tstateVal\r\n\t\t\t\t);\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\treturn this.each( function() {\r\n\t\t\tvar className, i, self, classNames;\r\n\r\n\t\t\tif ( type === \"string\" ) {\r\n\r\n\t\t\t\t// Toggle individual class names\r\n\t\t\t\ti = 0;\r\n\t\t\t\tself = jQuery( this );\r\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\r\n\r\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\r\n\r\n\t\t\t\t\t// Check each className given, space separated list\r\n\t\t\t\t\tif ( self.hasClass( className ) ) {\r\n\t\t\t\t\t\tself.removeClass( className );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tself.addClass( className );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Toggle whole class name\r\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\r\n\t\t\t\tclassName = getClass( this );\r\n\t\t\t\tif ( className ) {\r\n\r\n\t\t\t\t\t// Store className if set\r\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the element has a class name or if we're passed `false`,\r\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\r\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\r\n\t\t\t\t// falling back to the empty string if nothing was stored.\r\n\t\t\t\tif ( this.setAttribute ) {\r\n\t\t\t\t\tthis.setAttribute( \"class\",\r\n\t\t\t\t\t\tclassName || value === false ?\r\n\t\t\t\t\t\t\"\" :\r\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\thasClass: function( selector ) {\r\n\t\tvar className, elem,\r\n\t\t\ti = 0;\r\n\r\n\t\tclassName = \" \" + selector + \" \";\r\n\t\twhile ( ( elem = this[ i++ ] ) ) {\r\n\t\t\tif ( elem.nodeType === 1 &&\r\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\nvar rreturn = /\\r/g;\r\n\r\njQuery.fn.extend( {\r\n\tval: function( value ) {\r\n\t\tvar hooks, ret, isFunction,\r\n\t\t\telem = this[ 0 ];\r\n\r\n\t\tif ( !arguments.length ) {\r\n\t\t\tif ( elem ) {\r\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\r\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\r\n\r\n\t\t\t\tif ( hooks &&\r\n\t\t\t\t\t\"get\" in hooks &&\r\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tret = elem.value;\r\n\r\n\t\t\t\t// Handle most common string cases\r\n\t\t\t\tif ( typeof ret === \"string\" ) {\r\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Handle cases where value is null/undef or number\r\n\t\t\t\treturn ret == null ? \"\" : ret;\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t\treturn this.each( function( i ) {\r\n\t\t\tvar val;\r\n\r\n\t\t\tif ( this.nodeType !== 1 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( isFunction ) {\r\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\r\n\t\t\t} else {\r\n\t\t\t\tval = value;\r\n\t\t\t}\r\n\r\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\r\n\t\t\tif ( val == null ) {\r\n\t\t\t\tval = \"\";\r\n\r\n\t\t\t} else if ( typeof val === \"number\" ) {\r\n\t\t\t\tval += \"\";\r\n\r\n\t\t\t} else if ( Array.isArray( val ) ) {\r\n\t\t\t\tval = jQuery.map( val, function( value ) {\r\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\r\n\r\n\t\t\t// If set returns undefined, fall back to normal setting\r\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\r\n\t\t\t\tthis.value = val;\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\njQuery.extend( {\r\n\tvalHooks: {\r\n\t\toption: {\r\n\t\t\tget: function( elem ) {\r\n\r\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\r\n\t\t\t\treturn val != null ?\r\n\t\t\t\t\tval :\r\n\r\n\t\t\t\t\t// Support: IE <=10 - 11 only\r\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\r\n\t\t\t\t\t// Strip and collapse whitespace\r\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\r\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\r\n\t\t\t}\r\n\t\t},\r\n\t\tselect: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\tvar value, option, i,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tindex = elem.selectedIndex,\r\n\t\t\t\t\tone = elem.type === \"select-one\",\r\n\t\t\t\t\tvalues = one ? null : [],\r\n\t\t\t\t\tmax = one ? index + 1 : options.length;\r\n\r\n\t\t\t\tif ( index < 0 ) {\r\n\t\t\t\t\ti = max;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\ti = one ? index : 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop through all the selected options\r\n\t\t\t\tfor ( ; i < max; i++ ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\r\n\t\t\t\t\t// Support: IE <=9 only\r\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\r\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\r\n\r\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\r\n\t\t\t\t\t\t\t!option.disabled &&\r\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\r\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\r\n\r\n\t\t\t\t\t\t// Get the specific value for the option\r\n\t\t\t\t\t\tvalue = jQuery( option ).val();\r\n\r\n\t\t\t\t\t\t// We don't need an array for one selects\r\n\t\t\t\t\t\tif ( one ) {\r\n\t\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Multi-Selects return an array\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tvar optionSet, option,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\r\n\t\t\t\t\ti = options.length;\r\n\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\r\n\t\t\t\t\t/* eslint-disable no-cond-assign */\r\n\r\n\t\t\t\t\tif ( option.selected =\r\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\toptionSet = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* eslint-enable no-cond-assign */\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\r\n\t\t\t\tif ( !optionSet ) {\r\n\t\t\t\t\telem.selectedIndex = -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n// Radios and checkboxes getter/setter\r\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\r\n\tjQuery.valHooks[ this ] = {\r\n\t\tset: function( elem, value ) {\r\n\t\t\tif ( Array.isArray( value ) ) {\r\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tif ( !support.checkOn ) {\r\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\r\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\r\n\t\t};\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\n// Return jQuery for attributes-only inclusion\r\n\r\n\r\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\r\n\r\njQuery.extend( jQuery.event, {\r\n\r\n\ttrigger: function( event, data, elem, onlyHandlers ) {\r\n\r\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\r\n\t\t\teventPath = [ elem || document ],\r\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\r\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\r\n\r\n\t\tcur = tmp = elem = elem || document;\r\n\r\n\t\t// Don't do events on text and comment nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\r\n\r\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\r\n\t\t\tnamespaces = type.split( \".\" );\r\n\t\t\ttype = namespaces.shift();\r\n\t\t\tnamespaces.sort();\r\n\t\t}\r\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\r\n\r\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n\t\tevent = event[ jQuery.expando ] ?\r\n\t\t\tevent :\r\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\r\n\r\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\r\n\t\tevent.namespace = namespaces.join( \".\" );\r\n\t\tevent.rnamespace = event.namespace ?\r\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\r\n\t\t\tnull;\r\n\r\n\t\t// Clean up the event in case it is being reused\r\n\t\tevent.result = undefined;\r\n\t\tif ( !event.target ) {\r\n\t\t\tevent.target = elem;\r\n\t\t}\r\n\r\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\r\n\t\tdata = data == null ?\r\n\t\t\t[ event ] :\r\n\t\t\tjQuery.makeArray( data, [ event ] );\r\n\r\n\t\t// Allow special events to draw outside the lines\r\n\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\r\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\r\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\tbubbleType = special.delegateType || type;\r\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\r\n\t\t\t\tcur = cur.parentNode;\r\n\t\t\t}\r\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\r\n\t\t\t\teventPath.push( cur );\r\n\t\t\t\ttmp = cur;\r\n\t\t\t}\r\n\r\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\r\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Fire handlers on the event path\r\n\t\ti = 0;\r\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\r\n\r\n\t\t\tevent.type = i > 1 ?\r\n\t\t\t\tbubbleType :\r\n\t\t\t\tspecial.bindType || type;\r\n\r\n\t\t\t// jQuery handler\r\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\r\n\t\t\t\tdataPriv.get( cur, \"handle\" );\r\n\t\t\tif ( handle ) {\r\n\t\t\t\thandle.apply( cur, data );\r\n\t\t\t}\r\n\r\n\t\t\t// Native handler\r\n\t\t\thandle = ontype && cur[ ontype ];\r\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\r\n\t\t\t\tevent.result = handle.apply( cur, data );\r\n\t\t\t\tif ( event.result === false ) {\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tevent.type = type;\r\n\r\n\t\t// If nobody prevented the default action, do it now\r\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\r\n\r\n\t\t\tif ( ( !special._default ||\r\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\r\n\t\t\t\tacceptData( elem ) ) {\r\n\r\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\r\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\r\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\r\n\t\t\t\t\ttmp = elem[ ontype ];\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\r\n\t\t\t\t\tjQuery.event.triggered = type;\r\n\t\t\t\t\telem[ type ]();\r\n\t\t\t\t\tjQuery.event.triggered = undefined;\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = tmp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\t// Piggyback on a donor event to simulate a different one\r\n\t// Used only for `focus(in | out)` events\r\n\tsimulate: function( type, elem, event ) {\r\n\t\tvar e = jQuery.extend(\r\n\t\t\tnew jQuery.Event(),\r\n\t\t\tevent,\r\n\t\t\t{\r\n\t\t\t\ttype: type,\r\n\t\t\t\tisSimulated: true\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tjQuery.event.trigger( e, null, elem );\r\n\t}\r\n\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\r\n\ttrigger: function( type, data ) {\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.event.trigger( type, data, this );\r\n\t\t} );\r\n\t},\r\n\ttriggerHandler: function( type, data ) {\r\n\t\tvar elem = this[ 0 ];\r\n\t\tif ( elem ) {\r\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n\r\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\r\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\r\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\r\n\tfunction( i, name ) {\r\n\r\n\t// Handle event binding\r\n\tjQuery.fn[ name ] = function( data, fn ) {\r\n\t\treturn arguments.length > 0 ?\r\n\t\t\tthis.on( name, null, data, fn ) :\r\n\t\t\tthis.trigger( name );\r\n\t};\r\n} );\r\n\r\njQuery.fn.extend( {\r\n\thover: function( fnOver, fnOut ) {\r\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\nsupport.focusin = \"onfocusin\" in window;\r\n\r\n\r\n// Support: Firefox <=44\r\n// Firefox doesn't have focus(in | out) events\r\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\r\n//\r\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\r\n// focus(in | out) events fire after focus & blur events,\r\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\r\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\r\nif ( !support.focusin ) {\r\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\r\n\r\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\r\n\t\tvar handler = function( event ) {\r\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\r\n\t\t};\r\n\r\n\t\tjQuery.event.special[ fix ] = {\r\n\t\t\tsetup: function() {\r\n\t\t\t\tvar doc = this.ownerDocument || this,\r\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\r\n\r\n\t\t\t\tif ( !attaches ) {\r\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\r\n\t\t\t\t}\r\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\r\n\t\t\t},\r\n\t\t\tteardown: function() {\r\n\t\t\t\tvar doc = this.ownerDocument || this,\r\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\r\n\r\n\t\t\t\tif ( !attaches ) {\r\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\r\n\t\t\t\t\tdataPriv.remove( doc, fix );\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t} );\r\n}\r\nvar location = window.location;\r\n\r\nvar nonce = jQuery.now();\r\n\r\nvar rquery = ( /\\?/ );\r\n\r\n\r\n\r\n// Cross-browser xml parsing\r\njQuery.parseXML = function( data ) {\r\n\tvar xml;\r\n\tif ( !data || typeof data !== \"string\" ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Support: IE 9 - 11 only\r\n\t// IE throws on parseFromString with invalid input.\r\n\ttry {\r\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\r\n\t} catch ( e ) {\r\n\t\txml = undefined;\r\n\t}\r\n\r\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\r\n\t\tjQuery.error( \"Invalid XML: \" + data );\r\n\t}\r\n\treturn xml;\r\n};\r\n\r\n\r\nvar\r\n\trbracket = /\\[\\]$/,\r\n\trCRLF = /\\r?\\n/g,\r\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\nfunction buildParams( prefix, obj, traditional, add ) {\r\n\tvar name;\r\n\r\n\tif ( Array.isArray( obj ) ) {\r\n\r\n\t\t// Serialize array item.\r\n\t\tjQuery.each( obj, function( i, v ) {\r\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\r\n\r\n\t\t\t\t// Treat each array item as a scalar.\r\n\t\t\t\tadd( prefix, v );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\r\n\t\t\t\tbuildParams(\r\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\r\n\t\t\t\t\tv,\r\n\t\t\t\t\ttraditional,\r\n\t\t\t\t\tadd\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\r\n\r\n\t\t// Serialize object item.\r\n\t\tfor ( name in obj ) {\r\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// Serialize scalar item.\r\n\t\tadd( prefix, obj );\r\n\t}\r\n}\r\n\r\n// Serialize an array of form elements or a set of\r\n// key/values into a query string\r\njQuery.param = function( a, traditional ) {\r\n\tvar prefix,\r\n\t\ts = [],\r\n\t\tadd = function( key, valueOrFunction ) {\r\n\r\n\t\t\t// If value is a function, invoke it and use its return value\r\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\r\n\t\t\t\tvalueOrFunction() :\r\n\t\t\t\tvalueOrFunction;\r\n\r\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\r\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\r\n\t\t};\r\n\r\n\t// If an array was passed in, assume that it is an array of form elements.\r\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\r\n\r\n\t\t// Serialize the form elements\r\n\t\tjQuery.each( a, function() {\r\n\t\t\tadd( this.name, this.value );\r\n\t\t} );\r\n\r\n\t} else {\r\n\r\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n\t\t// did it), otherwise encode params recursively.\r\n\t\tfor ( prefix in a ) {\r\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the resulting serialization\r\n\treturn s.join( \"&\" );\r\n};\r\n\r\njQuery.fn.extend( {\r\n\tserialize: function() {\r\n\t\treturn jQuery.param( this.serializeArray() );\r\n\t},\r\n\tserializeArray: function() {\r\n\t\treturn this.map( function() {\r\n\r\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\r\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\r\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\r\n\t\t} )\r\n\t\t.filter( function() {\r\n\t\t\tvar type = this.type;\r\n\r\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\r\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\r\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\r\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\r\n\t\t} )\r\n\t\t.map( function( i, elem ) {\r\n\t\t\tvar val = jQuery( this ).val();\r\n\r\n\t\t\tif ( val == null ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tif ( Array.isArray( val ) ) {\r\n\t\t\t\treturn jQuery.map( val, function( val ) {\r\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t} ).get();\r\n\t}\r\n} );\r\n\r\n\r\nvar\r\n\tr20 = /%20/g,\r\n\trhash = /#.*$/,\r\n\trantiCache = /([?&])_=[^&]*/,\r\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\r\n\r\n\t// #7653, #8125, #8152: local protocol detection\r\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\r\n\trnoContent = /^(?:GET|HEAD)$/,\r\n\trprotocol = /^\\/\\//,\r\n\r\n\t/* Prefilters\r\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n\t * 2) These are called:\r\n\t *    - BEFORE asking for a transport\r\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n\t * 3) key is the dataType\r\n\t * 4) the catchall symbol \"*\" can be used\r\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n\t */\r\n\tprefilters = {},\r\n\r\n\t/* Transports bindings\r\n\t * 1) key is the dataType\r\n\t * 2) the catchall symbol \"*\" can be used\r\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n\t */\r\n\ttransports = {},\r\n\r\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\r\n\tallTypes = \"*/\".concat( \"*\" ),\r\n\r\n\t// Anchor tag for parsing the document origin\r\n\toriginAnchor = document.createElement( \"a\" );\r\n\toriginAnchor.href = location.href;\r\n\r\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\nfunction addToPrefiltersOrTransports( structure ) {\r\n\r\n\t// dataTypeExpression is optional and defaults to \"*\"\r\n\treturn function( dataTypeExpression, func ) {\r\n\r\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\r\n\t\t\tfunc = dataTypeExpression;\r\n\t\t\tdataTypeExpression = \"*\";\r\n\t\t}\r\n\r\n\t\tvar dataType,\r\n\t\t\ti = 0,\r\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\r\n\r\n\t\tif ( jQuery.isFunction( func ) ) {\r\n\r\n\t\t\t// For each dataType in the dataTypeExpression\r\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\r\n\r\n\t\t\t\t// Prepend if requested\r\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\r\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\r\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\r\n\r\n\t\t\t\t// Otherwise append\r\n\t\t\t\t} else {\r\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// Base inspection function for prefilters and transports\r\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\r\n\r\n\tvar inspected = {},\r\n\t\tseekingTransport = ( structure === transports );\r\n\r\n\tfunction inspect( dataType ) {\r\n\t\tvar selected;\r\n\t\tinspected[ dataType ] = true;\r\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\r\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\r\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\r\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\r\n\r\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\r\n\t\t\t\tinspect( dataTypeOrTransport );\r\n\t\t\t\treturn false;\r\n\t\t\t} else if ( seekingTransport ) {\r\n\t\t\t\treturn !( selected = dataTypeOrTransport );\r\n\t\t\t}\r\n\t\t} );\r\n\t\treturn selected;\r\n\t}\r\n\r\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\r\n}\r\n\r\n// A special extend for ajax options\r\n// that takes \"flat\" options (not to be deep extended)\r\n// Fixes #9887\r\nfunction ajaxExtend( target, src ) {\r\n\tvar key, deep,\r\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\r\n\r\n\tfor ( key in src ) {\r\n\t\tif ( src[ key ] !== undefined ) {\r\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\r\n\t\t}\r\n\t}\r\n\tif ( deep ) {\r\n\t\tjQuery.extend( true, target, deep );\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/* Handles responses to an ajax request:\r\n * - finds the right dataType (mediates between content-type and expected dataType)\r\n * - returns the corresponding response\r\n */\r\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\r\n\r\n\tvar ct, type, finalDataType, firstDataType,\r\n\t\tcontents = s.contents,\r\n\t\tdataTypes = s.dataTypes;\r\n\r\n\t// Remove auto dataType and get content-type in the process\r\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\r\n\t\tdataTypes.shift();\r\n\t\tif ( ct === undefined ) {\r\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if we're dealing with a known content-type\r\n\tif ( ct ) {\r\n\t\tfor ( type in contents ) {\r\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\r\n\t\t\t\tdataTypes.unshift( type );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Check to see if we have a response for the expected dataType\r\n\tif ( dataTypes[ 0 ] in responses ) {\r\n\t\tfinalDataType = dataTypes[ 0 ];\r\n\t} else {\r\n\r\n\t\t// Try convertible dataTypes\r\n\t\tfor ( type in responses ) {\r\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\r\n\t\t\t\tfinalDataType = type;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif ( !firstDataType ) {\r\n\t\t\t\tfirstDataType = type;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Or just use first one\r\n\t\tfinalDataType = finalDataType || firstDataType;\r\n\t}\r\n\r\n\t// If we found a dataType\r\n\t// We add the dataType to the list if needed\r\n\t// and return the corresponding response\r\n\tif ( finalDataType ) {\r\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\r\n\t\t\tdataTypes.unshift( finalDataType );\r\n\t\t}\r\n\t\treturn responses[ finalDataType ];\r\n\t}\r\n}\r\n\r\n/* Chain conversions given the request and the original response\r\n * Also sets the responseXXX fields on the jqXHR instance\r\n */\r\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\r\n\tvar conv2, current, conv, tmp, prev,\r\n\t\tconverters = {},\r\n\r\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\r\n\t\tdataTypes = s.dataTypes.slice();\r\n\r\n\t// Create converters map with lowercased keys\r\n\tif ( dataTypes[ 1 ] ) {\r\n\t\tfor ( conv in s.converters ) {\r\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\r\n\t\t}\r\n\t}\r\n\r\n\tcurrent = dataTypes.shift();\r\n\r\n\t// Convert to each sequential dataType\r\n\twhile ( current ) {\r\n\r\n\t\tif ( s.responseFields[ current ] ) {\r\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\r\n\t\t}\r\n\r\n\t\t// Apply the dataFilter if provided\r\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\r\n\t\t\tresponse = s.dataFilter( response, s.dataType );\r\n\t\t}\r\n\r\n\t\tprev = current;\r\n\t\tcurrent = dataTypes.shift();\r\n\r\n\t\tif ( current ) {\r\n\r\n\t\t\t// There's only work to do if current dataType is non-auto\r\n\t\t\tif ( current === \"*\" ) {\r\n\r\n\t\t\t\tcurrent = prev;\r\n\r\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\r\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\r\n\r\n\t\t\t\t// Seek a direct converter\r\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\r\n\r\n\t\t\t\t// If none found, seek a pair\r\n\t\t\t\tif ( !conv ) {\r\n\t\t\t\t\tfor ( conv2 in converters ) {\r\n\r\n\t\t\t\t\t\t// If conv2 outputs current\r\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\r\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\r\n\r\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\r\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\r\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\r\n\t\t\t\t\t\t\tif ( conv ) {\r\n\r\n\t\t\t\t\t\t\t\t// Condense equivalence converters\r\n\t\t\t\t\t\t\t\tif ( conv === true ) {\r\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\r\n\r\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\r\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\r\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\r\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply converter (if not an equivalence)\r\n\t\t\t\tif ( conv !== true ) {\r\n\r\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\r\n\t\t\t\t\tif ( conv && s.throws ) {\r\n\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t\t} catch ( e ) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\r\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { state: \"success\", data: response };\r\n}\r\n\r\njQuery.extend( {\r\n\r\n\t// Counter for holding the number of active queries\r\n\tactive: 0,\r\n\r\n\t// Last-Modified header cache for next request\r\n\tlastModified: {},\r\n\tetag: {},\r\n\r\n\tajaxSettings: {\r\n\t\turl: location.href,\r\n\t\ttype: \"GET\",\r\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\r\n\t\tglobal: true,\r\n\t\tprocessData: true,\r\n\t\tasync: true,\r\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\r\n\t\t/*\r\n\t\ttimeout: 0,\r\n\t\tdata: null,\r\n\t\tdataType: null,\r\n\t\tusername: null,\r\n\t\tpassword: null,\r\n\t\tcache: null,\r\n\t\tthrows: false,\r\n\t\ttraditional: false,\r\n\t\theaders: {},\r\n\t\t*/\r\n\r\n\t\taccepts: {\r\n\t\t\t\"*\": allTypes,\r\n\t\t\ttext: \"text/plain\",\r\n\t\t\thtml: \"text/html\",\r\n\t\t\txml: \"application/xml, text/xml\",\r\n\t\t\tjson: \"application/json, text/javascript\"\r\n\t\t},\r\n\r\n\t\tcontents: {\r\n\t\t\txml: /\\bxml\\b/,\r\n\t\t\thtml: /\\bhtml/,\r\n\t\t\tjson: /\\bjson\\b/\r\n\t\t},\r\n\r\n\t\tresponseFields: {\r\n\t\t\txml: \"responseXML\",\r\n\t\t\ttext: \"responseText\",\r\n\t\t\tjson: \"responseJSON\"\r\n\t\t},\r\n\r\n\t\t// Data converters\r\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\r\n\t\tconverters: {\r\n\r\n\t\t\t// Convert anything to text\r\n\t\t\t\"* text\": String,\r\n\r\n\t\t\t// Text to html (true = no transformation)\r\n\t\t\t\"text html\": true,\r\n\r\n\t\t\t// Evaluate text as a json expression\r\n\t\t\t\"text json\": JSON.parse,\r\n\r\n\t\t\t// Parse text as xml\r\n\t\t\t\"text xml\": jQuery.parseXML\r\n\t\t},\r\n\r\n\t\t// For options that shouldn't be deep extended:\r\n\t\t// you can add your own custom options here if\r\n\t\t// and when you create one that shouldn't be\r\n\t\t// deep extended (see ajaxExtend)\r\n\t\tflatOptions: {\r\n\t\t\turl: true,\r\n\t\t\tcontext: true\r\n\t\t}\r\n\t},\r\n\r\n\t// Creates a full fledged settings object into target\r\n\t// with both ajaxSettings and settings fields.\r\n\t// If target is omitted, writes into ajaxSettings.\r\n\tajaxSetup: function( target, settings ) {\r\n\t\treturn settings ?\r\n\r\n\t\t\t// Building a settings object\r\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\r\n\r\n\t\t\t// Extending ajaxSettings\r\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\r\n\t},\r\n\r\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\r\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\r\n\r\n\t// Main method\r\n\tajax: function( url, options ) {\r\n\r\n\t\t// If url is an object, simulate pre-1.5 signature\r\n\t\tif ( typeof url === \"object\" ) {\r\n\t\t\toptions = url;\r\n\t\t\turl = undefined;\r\n\t\t}\r\n\r\n\t\t// Force options to be an object\r\n\t\toptions = options || {};\r\n\r\n\t\tvar transport,\r\n\r\n\t\t\t// URL without anti-cache param\r\n\t\t\tcacheURL,\r\n\r\n\t\t\t// Response headers\r\n\t\t\tresponseHeadersString,\r\n\t\t\tresponseHeaders,\r\n\r\n\t\t\t// timeout handle\r\n\t\t\ttimeoutTimer,\r\n\r\n\t\t\t// Url cleanup var\r\n\t\t\turlAnchor,\r\n\r\n\t\t\t// Request state (becomes false upon send and true upon completion)\r\n\t\t\tcompleted,\r\n\r\n\t\t\t// To know if global events are to be dispatched\r\n\t\t\tfireGlobals,\r\n\r\n\t\t\t// Loop variable\r\n\t\t\ti,\r\n\r\n\t\t\t// uncached part of the url\r\n\t\t\tuncached,\r\n\r\n\t\t\t// Create the final options object\r\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\r\n\r\n\t\t\t// Callbacks context\r\n\t\t\tcallbackContext = s.context || s,\r\n\r\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n\t\t\tglobalEventContext = s.context &&\r\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\r\n\t\t\t\t\tjQuery( callbackContext ) :\r\n\t\t\t\t\tjQuery.event,\r\n\r\n\t\t\t// Deferreds\r\n\t\t\tdeferred = jQuery.Deferred(),\r\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\r\n\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tstatusCode = s.statusCode || {},\r\n\r\n\t\t\t// Headers (they are sent all at once)\r\n\t\t\trequestHeaders = {},\r\n\t\t\trequestHeadersNames = {},\r\n\r\n\t\t\t// Default abort message\r\n\t\t\tstrAbort = \"canceled\",\r\n\r\n\t\t\t// Fake xhr\r\n\t\t\tjqXHR = {\r\n\t\t\t\treadyState: 0,\r\n\r\n\t\t\t\t// Builds headers hashtable if needed\r\n\t\t\t\tgetResponseHeader: function( key ) {\r\n\t\t\t\t\tvar match;\r\n\t\t\t\t\tif ( completed ) {\r\n\t\t\t\t\t\tif ( !responseHeaders ) {\r\n\t\t\t\t\t\t\tresponseHeaders = {};\r\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\r\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn match == null ? null : match;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Raw string\r\n\t\t\t\tgetAllResponseHeaders: function() {\r\n\t\t\t\t\treturn completed ? responseHeadersString : null;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Caches the header\r\n\t\t\t\tsetRequestHeader: function( name, value ) {\r\n\t\t\t\t\tif ( completed == null ) {\r\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\r\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\r\n\t\t\t\t\t\trequestHeaders[ name ] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Overrides response content-type header\r\n\t\t\t\toverrideMimeType: function( type ) {\r\n\t\t\t\t\tif ( completed == null ) {\r\n\t\t\t\t\t\ts.mimeType = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Status-dependent callbacks\r\n\t\t\t\tstatusCode: function( map ) {\r\n\t\t\t\t\tvar code;\r\n\t\t\t\t\tif ( map ) {\r\n\t\t\t\t\t\tif ( completed ) {\r\n\r\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\r\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\r\n\t\t\t\t\t\t\tfor ( code in map ) {\r\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Cancel the request\r\n\t\t\t\tabort: function( statusText ) {\r\n\t\t\t\t\tvar finalText = statusText || strAbort;\r\n\t\t\t\t\tif ( transport ) {\r\n\t\t\t\t\t\ttransport.abort( finalText );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdone( 0, finalText );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t// Attach deferreds\r\n\t\tdeferred.promise( jqXHR );\r\n\r\n\t\t// Add protocol if not provided (prefilters might expect it)\r\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\r\n\t\t// We also use the url parameter if available\r\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\r\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\r\n\r\n\t\t// Alias method option to type as per ticket #12004\r\n\t\ts.type = options.method || options.type || s.method || s.type;\r\n\r\n\t\t// Extract dataTypes list\r\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\r\n\r\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\r\n\t\tif ( s.crossDomain == null ) {\r\n\t\t\turlAnchor = document.createElement( \"a\" );\r\n\r\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\r\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\r\n\t\t\t// e.g. http://example.com:80x/\r\n\t\t\ttry {\r\n\t\t\t\turlAnchor.href = s.url;\r\n\r\n\t\t\t\t// Support: IE <=8 - 11 only\r\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\r\n\t\t\t\turlAnchor.href = urlAnchor.href;\r\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\r\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\r\n\t\t\t\t// it can be rejected by the transport if it is invalid\r\n\t\t\t\ts.crossDomain = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Convert data if not already a string\r\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\r\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\r\n\t\t}\r\n\r\n\t\t// Apply prefilters\r\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\r\n\r\n\t\t// If request was aborted inside a prefilter, stop there\r\n\t\tif ( completed ) {\r\n\t\t\treturn jqXHR;\r\n\t\t}\r\n\r\n\t\t// We can fire global events as of now if asked to\r\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\r\n\t\tfireGlobals = jQuery.event && s.global;\r\n\r\n\t\t// Watch for a new set of requests\r\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\r\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\r\n\t\t}\r\n\r\n\t\t// Uppercase the type\r\n\t\ts.type = s.type.toUpperCase();\r\n\r\n\t\t// Determine if request has content\r\n\t\ts.hasContent = !rnoContent.test( s.type );\r\n\r\n\t\t// Save the URL in case we're toying with the If-Modified-Since\r\n\t\t// and/or If-None-Match header later on\r\n\t\t// Remove hash to simplify url manipulation\r\n\t\tcacheURL = s.url.replace( rhash, \"\" );\r\n\r\n\t\t// More options handling for requests with no content\r\n\t\tif ( !s.hasContent ) {\r\n\r\n\t\t\t// Remember the hash so we can put it back\r\n\t\t\tuncached = s.url.slice( cacheURL.length );\r\n\r\n\t\t\t// If data is available, append data to url\r\n\t\t\tif ( s.data ) {\r\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\r\n\r\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\r\n\t\t\t\tdelete s.data;\r\n\t\t\t}\r\n\r\n\t\t\t// Add or update anti-cache param if needed\r\n\t\t\tif ( s.cache === false ) {\r\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\r\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\r\n\t\t\t}\r\n\r\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\r\n\t\t\ts.url = cacheURL + uncached;\r\n\r\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\r\n\t\t} else if ( s.data && s.processData &&\r\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\r\n\t\t\ts.data = s.data.replace( r20, \"+\" );\r\n\t\t}\r\n\r\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\tif ( s.ifModified ) {\r\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\r\n\t\t\t}\r\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the correct header, if data is being sent\r\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\r\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\r\n\t\t}\r\n\r\n\t\t// Set the Accepts header for the server, depending on the dataType\r\n\t\tjqXHR.setRequestHeader(\r\n\t\t\t\"Accept\",\r\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\r\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\r\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\r\n\t\t\t\ts.accepts[ \"*\" ]\r\n\t\t);\r\n\r\n\t\t// Check for headers option\r\n\t\tfor ( i in s.headers ) {\r\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\r\n\t\t}\r\n\r\n\t\t// Allow custom headers/mimetypes and early abort\r\n\t\tif ( s.beforeSend &&\r\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\r\n\r\n\t\t\t// Abort if not done already and return\r\n\t\t\treturn jqXHR.abort();\r\n\t\t}\r\n\r\n\t\t// Aborting is no longer a cancellation\r\n\t\tstrAbort = \"abort\";\r\n\r\n\t\t// Install callbacks on deferreds\r\n\t\tcompleteDeferred.add( s.complete );\r\n\t\tjqXHR.done( s.success );\r\n\t\tjqXHR.fail( s.error );\r\n\r\n\t\t// Get transport\r\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\r\n\r\n\t\t// If no transport, we auto-abort\r\n\t\tif ( !transport ) {\r\n\t\t\tdone( -1, \"No Transport\" );\r\n\t\t} else {\r\n\t\t\tjqXHR.readyState = 1;\r\n\r\n\t\t\t// Send global event\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\r\n\t\t\t}\r\n\r\n\t\t\t// If request was aborted inside ajaxSend, stop there\r\n\t\t\tif ( completed ) {\r\n\t\t\t\treturn jqXHR;\r\n\t\t\t}\r\n\r\n\t\t\t// Timeout\r\n\t\t\tif ( s.async && s.timeout > 0 ) {\r\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\r\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\r\n\t\t\t\t}, s.timeout );\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\t\t\t\tcompleted = false;\r\n\t\t\t\ttransport.send( requestHeaders, done );\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t// Rethrow post-completion exceptions\r\n\t\t\t\tif ( completed ) {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Propagate others as results\r\n\t\t\t\tdone( -1, e );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Callback for when everything is done\r\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\r\n\t\t\tvar isSuccess, success, error, response, modified,\r\n\t\t\t\tstatusText = nativeStatusText;\r\n\r\n\t\t\t// Ignore repeat invocations\r\n\t\t\tif ( completed ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tcompleted = true;\r\n\r\n\t\t\t// Clear timeout if it exists\r\n\t\t\tif ( timeoutTimer ) {\r\n\t\t\t\twindow.clearTimeout( timeoutTimer );\r\n\t\t\t}\r\n\r\n\t\t\t// Dereference transport for early garbage collection\r\n\t\t\t// (no matter how long the jqXHR object will be used)\r\n\t\t\ttransport = undefined;\r\n\r\n\t\t\t// Cache response headers\r\n\t\t\tresponseHeadersString = headers || \"\";\r\n\r\n\t\t\t// Set readyState\r\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\r\n\r\n\t\t\t// Determine if successful\r\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\r\n\r\n\t\t\t// Get response data\r\n\t\t\tif ( responses ) {\r\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\r\n\t\t\t}\r\n\r\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\r\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\r\n\r\n\t\t\t// If successful, handle type chaining\r\n\t\t\tif ( isSuccess ) {\r\n\r\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\t\t\tif ( s.ifModified ) {\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if no content\r\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\r\n\t\t\t\t\tstatusText = \"nocontent\";\r\n\r\n\t\t\t\t// if not modified\r\n\t\t\t\t} else if ( status === 304 ) {\r\n\t\t\t\t\tstatusText = \"notmodified\";\r\n\r\n\t\t\t\t// If we have data, let's convert it\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstatusText = response.state;\r\n\t\t\t\t\tsuccess = response.data;\r\n\t\t\t\t\terror = response.error;\r\n\t\t\t\t\tisSuccess = !error;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\r\n\t\t\t\terror = statusText;\r\n\t\t\t\tif ( status || !statusText ) {\r\n\t\t\t\t\tstatusText = \"error\";\r\n\t\t\t\t\tif ( status < 0 ) {\r\n\t\t\t\t\t\tstatus = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set data for the fake xhr object\r\n\t\t\tjqXHR.status = status;\r\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\r\n\r\n\t\t\t// Success/Error\r\n\t\t\tif ( isSuccess ) {\r\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tjqXHR.statusCode( statusCode );\r\n\t\t\tstatusCode = undefined;\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\r\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Complete\r\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\r\n\r\n\t\t\t\t// Handle the global AJAX counter\r\n\t\t\t\tif ( !( --jQuery.active ) ) {\r\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn jqXHR;\r\n\t},\r\n\r\n\tgetJSON: function( url, data, callback ) {\r\n\t\treturn jQuery.get( url, data, callback, \"json\" );\r\n\t},\r\n\r\n\tgetScript: function( url, callback ) {\r\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\r\n\t}\r\n} );\r\n\r\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\r\n\tjQuery[ method ] = function( url, data, callback, type ) {\r\n\r\n\t\t// Shift arguments if data argument was omitted\r\n\t\tif ( jQuery.isFunction( data ) ) {\r\n\t\t\ttype = type || callback;\r\n\t\t\tcallback = data;\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\r\n\t\t// The url can be an options object (which then must have .url)\r\n\t\treturn jQuery.ajax( jQuery.extend( {\r\n\t\t\turl: url,\r\n\t\t\ttype: method,\r\n\t\t\tdataType: type,\r\n\t\t\tdata: data,\r\n\t\t\tsuccess: callback\r\n\t\t}, jQuery.isPlainObject( url ) && url ) );\r\n\t};\r\n} );\r\n\r\n\r\njQuery._evalUrl = function( url ) {\r\n\treturn jQuery.ajax( {\r\n\t\turl: url,\r\n\r\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\r\n\t\ttype: \"GET\",\r\n\t\tdataType: \"script\",\r\n\t\tcache: true,\r\n\t\tasync: false,\r\n\t\tglobal: false,\r\n\t\t\"throws\": true\r\n\t} );\r\n};\r\n\r\n\r\njQuery.fn.extend( {\r\n\twrapAll: function( html ) {\r\n\t\tvar wrap;\r\n\r\n\t\tif ( this[ 0 ] ) {\r\n\t\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\t\thtml = html.call( this[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\t// The elements to wrap the target around\r\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\r\n\r\n\t\t\tif ( this[ 0 ].parentNode ) {\r\n\t\t\t\twrap.insertBefore( this[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\twrap.map( function() {\r\n\t\t\t\tvar elem = this;\r\n\r\n\t\t\t\twhile ( elem.firstElementChild ) {\r\n\t\t\t\t\telem = elem.firstElementChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn elem;\r\n\t\t\t} ).append( this );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\twrapInner: function( html ) {\r\n\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\treturn this.each( function( i ) {\r\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\treturn this.each( function() {\r\n\t\t\tvar self = jQuery( this ),\r\n\t\t\t\tcontents = self.contents();\r\n\r\n\t\t\tif ( contents.length ) {\r\n\t\t\t\tcontents.wrapAll( html );\r\n\r\n\t\t\t} else {\r\n\t\t\t\tself.append( html );\r\n\t\t\t}\r\n\t\t} );\r\n\t},\r\n\r\n\twrap: function( html ) {\r\n\t\tvar isFunction = jQuery.isFunction( html );\r\n\r\n\t\treturn this.each( function( i ) {\r\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\r\n\t\t} );\r\n\t},\r\n\r\n\tunwrap: function( selector ) {\r\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\r\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\r\n\t\t} );\r\n\t\treturn this;\r\n\t}\r\n} );\r\n\r\n\r\njQuery.expr.pseudos.hidden = function( elem ) {\r\n\treturn !jQuery.expr.pseudos.visible( elem );\r\n};\r\njQuery.expr.pseudos.visible = function( elem ) {\r\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\r\n};\r\n\r\n\r\n\r\n\r\njQuery.ajaxSettings.xhr = function() {\r\n\ttry {\r\n\t\treturn new window.XMLHttpRequest();\r\n\t} catch ( e ) {}\r\n};\r\n\r\nvar xhrSuccessStatus = {\r\n\r\n\t\t// File protocol always yields status code 0, assume 200\r\n\t\t0: 200,\r\n\r\n\t\t// Support: IE <=9 only\r\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\r\n\t\t1223: 204\r\n\t},\r\n\txhrSupported = jQuery.ajaxSettings.xhr();\r\n\r\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\r\nsupport.ajax = xhrSupported = !!xhrSupported;\r\n\r\njQuery.ajaxTransport( function( options ) {\r\n\tvar callback, errorCallback;\r\n\r\n\t// Cross domain only allowed if supported through XMLHttpRequest\r\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\r\n\t\treturn {\r\n\t\t\tsend: function( headers, complete ) {\r\n\t\t\t\tvar i,\r\n\t\t\t\t\txhr = options.xhr();\r\n\r\n\t\t\t\txhr.open(\r\n\t\t\t\t\toptions.type,\r\n\t\t\t\t\toptions.url,\r\n\t\t\t\t\toptions.async,\r\n\t\t\t\t\toptions.username,\r\n\t\t\t\t\toptions.password\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Apply custom fields if provided\r\n\t\t\t\tif ( options.xhrFields ) {\r\n\t\t\t\t\tfor ( i in options.xhrFields ) {\r\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Override mime type if needed\r\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\r\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// X-Requested-With header\r\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\r\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\r\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\r\n\t\t\t\t// For same-domain requests, won't change header if already provided.\r\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\r\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set headers\r\n\t\t\t\tfor ( i in headers ) {\r\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Callback\r\n\t\t\t\tcallback = function( type ) {\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\r\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\r\n\r\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\r\n\t\t\t\t\t\t\t\txhr.abort();\r\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\r\n\r\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\r\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\r\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\r\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\r\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcomplete(\r\n\r\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\r\n\t\t\t\t\t\t\t\t\t\txhr.status,\r\n\t\t\t\t\t\t\t\t\t\txhr.statusText\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcomplete(\r\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\r\n\t\t\t\t\t\t\t\t\txhr.statusText,\r\n\r\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\r\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\r\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\r\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\r\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\r\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\r\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\r\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Listen to events\r\n\t\t\t\txhr.onload = callback();\r\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\r\n\r\n\t\t\t\t// Support: IE 9 only\r\n\t\t\t\t// Use onreadystatechange to replace onabort\r\n\t\t\t\t// to handle uncaught aborts\r\n\t\t\t\tif ( xhr.onabort !== undefined ) {\r\n\t\t\t\t\txhr.onabort = errorCallback;\r\n\t\t\t\t} else {\r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\r\n\t\t\t\t\t\t// Check readyState before timeout as it changes\r\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\r\n\r\n\t\t\t\t\t\t\t// Allow onerror to be called first,\r\n\t\t\t\t\t\t\t// but that will not handle a native abort\r\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\r\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\r\n\t\t\t\t\t\t\twindow.setTimeout( function() {\r\n\t\t\t\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\t\t\t\terrorCallback();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create the abort callback\r\n\t\t\t\tcallback = callback( \"abort\" );\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\t// Do send the request (this may raise an exception)\r\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\r\n\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\r\njQuery.ajaxPrefilter( function( s ) {\r\n\tif ( s.crossDomain ) {\r\n\t\ts.contents.script = false;\r\n\t}\r\n} );\r\n\r\n// Install script dataType\r\njQuery.ajaxSetup( {\r\n\taccepts: {\r\n\t\tscript: \"text/javascript, application/javascript, \" +\r\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\r\n\t},\r\n\tcontents: {\r\n\t\tscript: /\\b(?:java|ecma)script\\b/\r\n\t},\r\n\tconverters: {\r\n\t\t\"text script\": function( text ) {\r\n\t\t\tjQuery.globalEval( text );\r\n\t\t\treturn text;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n// Handle cache's special case and crossDomain\r\njQuery.ajaxPrefilter( \"script\", function( s ) {\r\n\tif ( s.cache === undefined ) {\r\n\t\ts.cache = false;\r\n\t}\r\n\tif ( s.crossDomain ) {\r\n\t\ts.type = \"GET\";\r\n\t}\r\n} );\r\n\r\n// Bind script tag hack transport\r\njQuery.ajaxTransport( \"script\", function( s ) {\r\n\r\n\t// This transport only deals with cross domain requests\r\n\tif ( s.crossDomain ) {\r\n\t\tvar script, callback;\r\n\t\treturn {\r\n\t\t\tsend: function( _, complete ) {\r\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\r\n\t\t\t\t\tcharset: s.scriptCharset,\r\n\t\t\t\t\tsrc: s.url\r\n\t\t\t\t} ).on(\r\n\t\t\t\t\t\"load error\",\r\n\t\t\t\t\tcallback = function( evt ) {\r\n\t\t\t\t\t\tscript.remove();\r\n\t\t\t\t\t\tcallback = null;\r\n\t\t\t\t\t\tif ( evt ) {\r\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\r\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\r\n\t\t\t},\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\nvar oldCallbacks = [],\r\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\r\n\r\n// Default jsonp settings\r\njQuery.ajaxSetup( {\r\n\tjsonp: \"callback\",\r\n\tjsonpCallback: function() {\r\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\r\n\t\tthis[ callback ] = true;\r\n\t\treturn callback;\r\n\t}\r\n} );\r\n\r\n// Detect, normalize options and install callbacks for jsonp requests\r\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\r\n\r\n\tvar callbackName, overwritten, responseContainer,\r\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\r\n\t\t\t\"url\" :\r\n\t\t\ttypeof s.data === \"string\" &&\r\n\t\t\t\t( s.contentType || \"\" )\r\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\r\n\t\t\t\trjsonp.test( s.data ) && \"data\"\r\n\t\t);\r\n\r\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\r\n\r\n\t\t// Get callback name, remembering preexisting value associated with it\r\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\r\n\t\t\ts.jsonpCallback() :\r\n\t\t\ts.jsonpCallback;\r\n\r\n\t\t// Insert callback into url or form data\r\n\t\tif ( jsonProp ) {\r\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\r\n\t\t} else if ( s.jsonp !== false ) {\r\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\r\n\t\t}\r\n\r\n\t\t// Use data converter to retrieve json after script execution\r\n\t\ts.converters[ \"script json\" ] = function() {\r\n\t\t\tif ( !responseContainer ) {\r\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\r\n\t\t\t}\r\n\t\t\treturn responseContainer[ 0 ];\r\n\t\t};\r\n\r\n\t\t// Force json dataType\r\n\t\ts.dataTypes[ 0 ] = \"json\";\r\n\r\n\t\t// Install callback\r\n\t\toverwritten = window[ callbackName ];\r\n\t\twindow[ callbackName ] = function() {\r\n\t\t\tresponseContainer = arguments;\r\n\t\t};\r\n\r\n\t\t// Clean-up function (fires after converters)\r\n\t\tjqXHR.always( function() {\r\n\r\n\t\t\t// If previous value didn't exist - remove it\r\n\t\t\tif ( overwritten === undefined ) {\r\n\t\t\t\tjQuery( window ).removeProp( callbackName );\r\n\r\n\t\t\t// Otherwise restore preexisting value\r\n\t\t\t} else {\r\n\t\t\t\twindow[ callbackName ] = overwritten;\r\n\t\t\t}\r\n\r\n\t\t\t// Save back as free\r\n\t\t\tif ( s[ callbackName ] ) {\r\n\r\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\r\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\r\n\r\n\t\t\t\t// Save the callback name for future use\r\n\t\t\t\toldCallbacks.push( callbackName );\r\n\t\t\t}\r\n\r\n\t\t\t// Call if it was a function and we have a response\r\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\r\n\t\t\t\toverwritten( responseContainer[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\tresponseContainer = overwritten = undefined;\r\n\t\t} );\r\n\r\n\t\t// Delegate to script\r\n\t\treturn \"script\";\r\n\t}\r\n} );\r\n\r\n\r\n\r\n\r\n// Support: Safari 8 only\r\n// In Safari 8 documents created via document.implementation.createHTMLDocument\r\n// collapse sibling forms: the second one becomes a child of the first one.\r\n// Because of that, this security measure has to be disabled in Safari 8.\r\n// https://bugs.webkit.org/show_bug.cgi?id=137337\r\nsupport.createHTMLDocument = ( function() {\r\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\r\n\tbody.innerHTML = \"<form></form><form></form>\";\r\n\treturn body.childNodes.length === 2;\r\n} )();\r\n\r\n\r\n// Argument \"data\" should be string of html\r\n// context (optional): If specified, the fragment will be created in this context,\r\n// defaults to document\r\n// keepScripts (optional): If true, will include scripts passed in the html string\r\njQuery.parseHTML = function( data, context, keepScripts ) {\r\n\tif ( typeof data !== \"string\" ) {\r\n\t\treturn [];\r\n\t}\r\n\tif ( typeof context === \"boolean\" ) {\r\n\t\tkeepScripts = context;\r\n\t\tcontext = false;\r\n\t}\r\n\r\n\tvar base, parsed, scripts;\r\n\r\n\tif ( !context ) {\r\n\r\n\t\t// Stop scripts or inline event handlers from being executed immediately\r\n\t\t// by using document.implementation\r\n\t\tif ( support.createHTMLDocument ) {\r\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\r\n\r\n\t\t\t// Set the base href for the created document\r\n\t\t\t// so any parsed elements with URLs\r\n\t\t\t// are based on the document's URL (gh-2965)\r\n\t\t\tbase = context.createElement( \"base\" );\r\n\t\t\tbase.href = document.location.href;\r\n\t\t\tcontext.head.appendChild( base );\r\n\t\t} else {\r\n\t\t\tcontext = document;\r\n\t\t}\r\n\t}\r\n\r\n\tparsed = rsingleTag.exec( data );\r\n\tscripts = !keepScripts && [];\r\n\r\n\t// Single tag\r\n\tif ( parsed ) {\r\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\r\n\t}\r\n\r\n\tparsed = buildFragment( [ data ], context, scripts );\r\n\r\n\tif ( scripts && scripts.length ) {\r\n\t\tjQuery( scripts ).remove();\r\n\t}\r\n\r\n\treturn jQuery.merge( [], parsed.childNodes );\r\n};\r\n\r\n\r\n/**\r\n * Load a url into a page\r\n */\r\njQuery.fn.load = function( url, params, callback ) {\r\n\tvar selector, type, response,\r\n\t\tself = this,\r\n\t\toff = url.indexOf( \" \" );\r\n\r\n\tif ( off > -1 ) {\r\n\t\tselector = stripAndCollapse( url.slice( off ) );\r\n\t\turl = url.slice( 0, off );\r\n\t}\r\n\r\n\t// If it's a function\r\n\tif ( jQuery.isFunction( params ) ) {\r\n\r\n\t\t// We assume that it's the callback\r\n\t\tcallback = params;\r\n\t\tparams = undefined;\r\n\r\n\t// Otherwise, build a param string\r\n\t} else if ( params && typeof params === \"object\" ) {\r\n\t\ttype = \"POST\";\r\n\t}\r\n\r\n\t// If we have elements to modify, make the request\r\n\tif ( self.length > 0 ) {\r\n\t\tjQuery.ajax( {\r\n\t\t\turl: url,\r\n\r\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\r\n\t\t\t// Make value of this field explicit since\r\n\t\t\t// user can override it through ajaxSetup method\r\n\t\t\ttype: type || \"GET\",\r\n\t\t\tdataType: \"html\",\r\n\t\t\tdata: params\r\n\t\t} ).done( function( responseText ) {\r\n\r\n\t\t\t// Save response for use in complete callback\r\n\t\t\tresponse = arguments;\r\n\r\n\t\t\tself.html( selector ?\r\n\r\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\r\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\r\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\r\n\r\n\t\t\t\t// Otherwise use the full result\r\n\t\t\t\tresponseText );\r\n\r\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\r\n\t\t// but they are ignored because response was set above.\r\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\r\n\t\t} ).always( callback && function( jqXHR, status ) {\r\n\t\t\tself.each( function() {\r\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n\r\n\r\n\r\n\r\n// Attach a bunch of functions for handling common AJAX events\r\njQuery.each( [\r\n\t\"ajaxStart\",\r\n\t\"ajaxStop\",\r\n\t\"ajaxComplete\",\r\n\t\"ajaxError\",\r\n\t\"ajaxSuccess\",\r\n\t\"ajaxSend\"\r\n], function( i, type ) {\r\n\tjQuery.fn[ type ] = function( fn ) {\r\n\t\treturn this.on( type, fn );\r\n\t};\r\n} );\r\n\r\n\r\n\r\n\r\njQuery.expr.pseudos.animated = function( elem ) {\r\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\r\n\t\treturn elem === fn.elem;\r\n\t} ).length;\r\n};\r\n\r\n\r\n\r\n\r\njQuery.offset = {\r\n\tsetOffset: function( elem, options, i ) {\r\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\r\n\t\t\tposition = jQuery.css( elem, \"position\" ),\r\n\t\t\tcurElem = jQuery( elem ),\r\n\t\t\tprops = {};\r\n\r\n\t\t// Set position first, in-case top/left are set even on static elem\r\n\t\tif ( position === \"static\" ) {\r\n\t\t\telem.style.position = \"relative\";\r\n\t\t}\r\n\r\n\t\tcurOffset = curElem.offset();\r\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\r\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\r\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\r\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\r\n\r\n\t\t// Need to be able to calculate position if either\r\n\t\t// top or left is auto and position is either absolute or fixed\r\n\t\tif ( calculatePosition ) {\r\n\t\t\tcurPosition = curElem.position();\r\n\t\t\tcurTop = curPosition.top;\r\n\t\t\tcurLeft = curPosition.left;\r\n\r\n\t\t} else {\r\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\r\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\r\n\t\t}\r\n\r\n\t\tif ( jQuery.isFunction( options ) ) {\r\n\r\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\r\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\r\n\t\t}\r\n\r\n\t\tif ( options.top != null ) {\r\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\r\n\t\t}\r\n\t\tif ( options.left != null ) {\r\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\r\n\t\t}\r\n\r\n\t\tif ( \"using\" in options ) {\r\n\t\t\toptions.using.call( elem, props );\r\n\r\n\t\t} else {\r\n\t\t\tcurElem.css( props );\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.fn.extend( {\r\n\toffset: function( options ) {\r\n\r\n\t\t// Preserve chaining for setter\r\n\t\tif ( arguments.length ) {\r\n\t\t\treturn options === undefined ?\r\n\t\t\t\tthis :\r\n\t\t\t\tthis.each( function( i ) {\r\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\r\n\t\t\t\t} );\r\n\t\t}\r\n\r\n\t\tvar doc, docElem, rect, win,\r\n\t\t\telem = this[ 0 ];\r\n\r\n\t\tif ( !elem ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\r\n\t\t// Support: IE <=11 only\r\n\t\t// Running getBoundingClientRect on a\r\n\t\t// disconnected node in IE throws an error\r\n\t\tif ( !elem.getClientRects().length ) {\r\n\t\t\treturn { top: 0, left: 0 };\r\n\t\t}\r\n\r\n\t\trect = elem.getBoundingClientRect();\r\n\r\n\t\tdoc = elem.ownerDocument;\r\n\t\tdocElem = doc.documentElement;\r\n\t\twin = doc.defaultView;\r\n\r\n\t\treturn {\r\n\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\r\n\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\r\n\t\t};\r\n\t},\r\n\r\n\tposition: function() {\r\n\t\tif ( !this[ 0 ] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar offsetParent, offset,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\tparentOffset = { top: 0, left: 0 };\r\n\r\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\r\n\t\t// because it is its only offset parent\r\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\r\n\r\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\r\n\t\t\toffset = elem.getBoundingClientRect();\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Get *real* offsetParent\r\n\t\t\toffsetParent = this.offsetParent();\r\n\r\n\t\t\t// Get correct offsets\r\n\t\t\toffset = this.offset();\r\n\t\t\tif ( !nodeName( offsetParent[ 0 ], \"html\" ) ) {\r\n\t\t\t\tparentOffset = offsetParent.offset();\r\n\t\t\t}\r\n\r\n\t\t\t// Add offsetParent borders\r\n\t\t\tparentOffset = {\r\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\r\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Subtract parent offsets and element margins\r\n\t\treturn {\r\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\r\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\r\n\t\t};\r\n\t},\r\n\r\n\t// This method will return documentElement in the following cases:\r\n\t// 1) For the element inside the iframe without offsetParent, this method will return\r\n\t//    documentElement of the parent window\r\n\t// 2) For the hidden or detached element\r\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\r\n\t//\r\n\t// but those exceptions were never presented as a real life use-cases\r\n\t// and might be considered as more preferable results.\r\n\t//\r\n\t// This logic, however, is not guaranteed and can change at any point in the future\r\n\toffsetParent: function() {\r\n\t\treturn this.map( function() {\r\n\t\t\tvar offsetParent = this.offsetParent;\r\n\r\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\r\n\t\t\t\toffsetParent = offsetParent.offsetParent;\r\n\t\t\t}\r\n\r\n\t\t\treturn offsetParent || documentElement;\r\n\t\t} );\r\n\t}\r\n} );\r\n\r\n// Create scrollLeft and scrollTop methods\r\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\r\n\tvar top = \"pageYOffset\" === prop;\r\n\r\n\tjQuery.fn[ method ] = function( val ) {\r\n\t\treturn access( this, function( elem, method, val ) {\r\n\r\n\t\t\t// Coalesce documents and windows\r\n\t\t\tvar win;\r\n\t\t\tif ( jQuery.isWindow( elem ) ) {\r\n\t\t\t\twin = elem;\r\n\t\t\t} else if ( elem.nodeType === 9 ) {\r\n\t\t\t\twin = elem.defaultView;\r\n\t\t\t}\r\n\r\n\t\t\tif ( val === undefined ) {\r\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\r\n\t\t\t}\r\n\r\n\t\t\tif ( win ) {\r\n\t\t\t\twin.scrollTo(\r\n\t\t\t\t\t!top ? val : win.pageXOffset,\r\n\t\t\t\t\ttop ? val : win.pageYOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\t\t\t\telem[ method ] = val;\r\n\t\t\t}\r\n\t\t}, method, val, arguments.length );\r\n\t};\r\n} );\r\n\r\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\r\n// Add the top/left cssHooks using jQuery.fn.position\r\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\r\n// getComputedStyle returns percent when specified for top/left/bottom/right;\r\n// rather than make the css module depend on the offset module, just check for it here\r\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\r\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\r\n\t\tfunction( elem, computed ) {\r\n\t\t\tif ( computed ) {\r\n\t\t\t\tcomputed = curCSS( elem, prop );\r\n\r\n\t\t\t\t// If curCSS returns percentage, fallback to offset\r\n\t\t\t\treturn rnumnonpx.test( computed ) ?\r\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\r\n\t\t\t\t\tcomputed;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n} );\r\n\r\n\r\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\r\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\r\n\t\tfunction( defaultExtra, funcName ) {\r\n\r\n\t\t// Margin is only for outerHeight, outerWidth\r\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\r\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\r\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\r\n\r\n\t\t\treturn access( this, function( elem, type, value ) {\r\n\t\t\t\tvar doc;\r\n\r\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\r\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\r\n\t\t\t\t\t\telem[ \"inner\" + name ] :\r\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get document width or height\r\n\t\t\t\tif ( elem.nodeType === 9 ) {\r\n\t\t\t\t\tdoc = elem.documentElement;\r\n\r\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n\t\t\t\t\t// whichever is greatest\r\n\t\t\t\t\treturn Math.max(\r\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\r\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\r\n\t\t\t\t\t\tdoc[ \"client\" + name ]\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn value === undefined ?\r\n\r\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\r\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\r\n\r\n\t\t\t\t\t// Set width or height on the element\r\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\r\n\t\t\t}, type, chainable ? margin : undefined, chainable );\r\n\t\t};\r\n\t} );\r\n} );\r\n\r\n\r\njQuery.fn.extend( {\r\n\r\n\tbind: function( types, data, fn ) {\r\n\t\treturn this.on( types, null, data, fn );\r\n\t},\r\n\tunbind: function( types, fn ) {\r\n\t\treturn this.off( types, null, fn );\r\n\t},\r\n\r\n\tdelegate: function( selector, types, data, fn ) {\r\n\t\treturn this.on( types, selector, data, fn );\r\n\t},\r\n\tundelegate: function( selector, types, fn ) {\r\n\r\n\t\t// ( namespace ) or ( selector, types [, fn] )\r\n\t\treturn arguments.length === 1 ?\r\n\t\t\tthis.off( selector, \"**\" ) :\r\n\t\t\tthis.off( types, selector || \"**\", fn );\r\n\t}\r\n} );\r\n\r\njQuery.holdReady = function( hold ) {\r\n\tif ( hold ) {\r\n\t\tjQuery.readyWait++;\r\n\t} else {\r\n\t\tjQuery.ready( true );\r\n\t}\r\n};\r\njQuery.isArray = Array.isArray;\r\njQuery.parseJSON = JSON.parse;\r\njQuery.nodeName = nodeName;\r\n\r\n\r\n\r\n\r\n// Register as a named AMD module, since jQuery can be concatenated with other\r\n// files that may use define, but not via a proper concatenation script that\r\n// understands anonymous AMD modules. A named AMD is safest and most robust\r\n// way to register. Lowercase jquery is used because AMD module names are\r\n// derived from file names, and jQuery is normally delivered in a lowercase\r\n// file name. Do this after creating the global so that if an AMD module wants\r\n// to call noConflict to hide this version of jQuery, it will work.\r\n\r\n// Note that for maximum portability, libraries that are not jQuery should\r\n// declare themselves as anonymous modules, and avoid setting a global if an\r\n// AMD loader is present. jQuery is a special case. For more information, see\r\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\r\n\r\nif ( typeof define === \"function\" && define.amd ) {\r\n\tdefine( \"jquery\", [], function() {\r\n\t\treturn jQuery;\r\n\t} );\r\n}\r\n\r\n\r\n\r\n\r\nvar\r\n\r\n\t// Map over jQuery in case of overwrite\r\n\t_jQuery = window.jQuery,\r\n\r\n\t// Map over the $ in case of overwrite\r\n\t_$ = window.$;\r\n\r\njQuery.noConflict = function( deep ) {\r\n\tif ( window.$ === jQuery ) {\r\n\t\twindow.$ = _$;\r\n\t}\r\n\r\n\tif ( deep && window.jQuery === jQuery ) {\r\n\t\twindow.jQuery = _jQuery;\r\n\t}\r\n\r\n\treturn jQuery;\r\n};\r\n\r\n// Expose jQuery and $ identifiers, even in AMD\r\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\r\n// and CommonJS for browser emulators (#13566)\r\nif ( !noGlobal ) {\r\n\twindow.jQuery = window.$ = jQuery;\r\n}\r\n\r\n\r\n\r\n\r\nreturn jQuery;\r\n} );\r\n"

/***/ }),

/***/ 256:
/***/ (function(module, exports) {

module.exports = "/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */\r\n!function(a,b){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){\"use strict\";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement(\"script\");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q=\"3.2.1\",r=function(a,b){return new r.fn.init(a,b)},s=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:\"jQuery\"+(q+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return(\"number\"===b||\"string\"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||\"[object Object]\"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,\"constructor\")&&b.constructor,\"function\"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?j[k.call(a)]||\"object\":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,\"ms-\").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(s,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,\"string\"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if(\"string\"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),\"function\"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(a,b){j[\"[object \"+b+\"]\"]=b.toLowerCase()});function w(a){var b=!!a&&\"length\"in a&&a.length,c=r.type(a);return\"function\"!==c&&!r.isWindow(a)&&(\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",K=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",L=\"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",M=\"\\\\[\"+K+\"*(\"+L+\")(?:\"+K+\"*([*^$|!~]?=)\"+K+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+L+\"))|)\"+K+\"*\\\\]\",N=\":(\"+L+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+M+\")*)|.*)\\\\)|)\",O=new RegExp(K+\"+\",\"g\"),P=new RegExp(\"^\"+K+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+K+\"+$\",\"g\"),Q=new RegExp(\"^\"+K+\"*,\"+K+\"*\"),R=new RegExp(\"^\"+K+\"*([>+~]|\"+K+\")\"+K+\"*\"),S=new RegExp(\"=\"+K+\"*([^\\\\]'\\\"]*?)\"+K+\"*\\\\]\",\"g\"),T=new RegExp(N),U=new RegExp(\"^\"+L+\"$\"),V={ID:new RegExp(\"^#(\"+L+\")\"),CLASS:new RegExp(\"^\\\\.(\"+L+\")\"),TAG:new RegExp(\"^(\"+L+\"|[*])\"),ATTR:new RegExp(\"^\"+M),PSEUDO:new RegExp(\"^\"+N),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+K+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+K+\"*(?:([+-]|)\"+K+\"*(\\\\d+)|))\"+K+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+J+\")$\",\"i\"),needsContext:new RegExp(\"^\"+K+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+K+\"*((?:-\\\\d)?\\\\d*)\"+K+\"*\\\\)|)(?=[^-]|$)\",\"i\")},W=/^(?:input|select|textarea|button)$/i,X=/^h\\d$/i,Y=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,$=/[+~]/,_=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+K+\"?|(\"+K+\")|.)\",\"ig\"),aa=function(a,b,c){var d=\"0x\"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ca=function(a,b){return b?\"\\0\"===a?\"\\ufffd\":a.slice(0,-1)+\"\\\\\"+a.charCodeAt(a.length-1).toString(16)+\" \":\"\\\\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&(\"form\"in a||\"label\"in a)},{dir:\"parentNode\",next:\"legend\"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],\"string\"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+\" \"]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if(\"object\"!==b.nodeName.toLowerCase()){(k=b.getAttribute(\"id\"))?k=k.replace(ba,ca):b.setAttribute(\"id\",k=u),o=g(a),h=o.length;while(h--)o[h]=\"#\"+k+\" \"+sa(o[h]);r=o.join(\",\"),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute(\"id\")}}}return i(a.replace(P,\"$1\"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+\" \")>d.cacheLength&&delete b[a.shift()],b[c+\" \"]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement(\"fieldset\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split(\"|\"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return\"input\"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return(\"input\"===c||\"button\"===c)&&b.type===a}}function oa(a){return function(b){return\"form\"in b?b.parentNode&&b.disabled===!1?\"label\"in b?\"label\"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:\"label\"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&\"undefined\"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&\"HTML\"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener(\"unload\",da,!1):e.attachEvent&&e.attachEvent(\"onunload\",da)),c.attributes=ja(function(a){return a.className=\"i\",!a.getAttribute(\"className\")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment(\"\")),!a.getElementsByTagName(\"*\").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute(\"id\")===b}},d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c=\"undefined\"!=typeof a.getAttributeNode&&a.getAttributeNode(\"id\");return c&&c.value===b}},d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode(\"id\"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode(\"id\"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\"undefined\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\"*\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if(\"undefined\"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML=\"<a id='\"+u+\"'></a><select id='\"+u+\"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\",a.querySelectorAll(\"[msallowcapture^='']\").length&&q.push(\"[*^$]=\"+K+\"*(?:''|\\\"\\\")\"),a.querySelectorAll(\"[selected]\").length||q.push(\"\\\\[\"+K+\"*(?:value|\"+J+\")\"),a.querySelectorAll(\"[id~=\"+u+\"-]\").length||q.push(\"~=\"),a.querySelectorAll(\":checked\").length||q.push(\":checked\"),a.querySelectorAll(\"a#\"+u+\"+*\").length||q.push(\".#.+[+~]\")}),ja(function(a){a.innerHTML=\"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\";var b=n.createElement(\"input\");b.setAttribute(\"type\",\"hidden\"),a.appendChild(b).setAttribute(\"name\",\"D\"),a.querySelectorAll(\"[name=d]\").length&&q.push(\"name\"+K+\"*[*^$|!~]?=\"),2!==a.querySelectorAll(\":enabled\").length&&q.push(\":enabled\",\":disabled\"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(\":disabled\").length&&q.push(\":enabled\",\":disabled\"),a.querySelectorAll(\"*,:x\"),q.push(\",.*:\")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,\"*\"),s.call(a,\"[s!='']:x\"),r.push(\"!=\",N)}),q=q.length&&new RegExp(q.join(\"|\")),r=r.length&&new RegExp(r.join(\"|\")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,\"='$1']\"),c.matchesSelector&&p&&!A[b+\" \"]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+\"\").replace(ba,ca)},ga.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c=\"\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\"string\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||\"\").replace(_,aa),\"~=\"===a[2]&&(a[3]=\" \"+a[3]+\" \"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\"nth\"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\"even\"===a[3]||\"odd\"===a[3])),a[5]=+(a[7]+a[8]||\"odd\"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\"\":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\")\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return\"*\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\" \"];return b||(b=new RegExp(\"(^|\"+K+\")\"+a+\"(\"+K+\"|$)\"))&&y(a,function(a){return b.test(\"string\"==typeof a.className&&a.className||\"undefined\"!=typeof a.getAttribute&&a.getAttribute(\"class\")||\"\")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?\"!=\"===b:!b||(e+=\"\",\"=\"===b?e===c:\"!=\"===b?e!==c:\"^=\"===b?c&&0===e.indexOf(c):\"*=\"===b?c&&e.indexOf(c)>-1:\"$=\"===b?c&&e.slice(-c.length)===c:\"~=\"===b?(\" \"+e.replace(O,\" \")+\" \").indexOf(c)>-1:\"|=\"===b&&(e===c||e.slice(0,c.length+1)===c+\"-\"))}},CHILD:function(a,b,c,d,e){var f=\"nth\"!==a.slice(0,3),g=\"last\"!==a.slice(-4),h=\"of-type\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\"nextSibling\":\"previousSibling\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p=\"only\"===a&&!o&&\"nextSibling\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error(\"unsupported pseudo: \"+a);return e[u]?e(b):e.length>1?(c=[a,a,\"\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,\"$1\"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||\"\")||ga.error(\"unsupported lang: \"+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\"xml:lang\")||b.getAttribute(\"lang\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\"-\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&!!a.checked||\"option\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&\"button\"===a.type||\"button\"===b},text:function(a){var b;return\"input\"===a.nodeName.toLowerCase()&&\"text\"===a.type&&(null==(b=a.getAttribute(\"type\"))||\"text\"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\" \"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P,\" \")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d=\"\";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&\"parentNode\"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||\"*\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\" \"],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:\" \"===a[i-2].type?\"*\":\"\"})).replace(P,\"$1\"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s=\"0\",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG(\"*\",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+\" \"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m=\"function\"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&\"ID\"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split(\"\").sort(B).join(\"\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement(\"fieldset\"))}),ja(function(a){return a.innerHTML=\"<a href='#'></a>\",\"#\"===a.firstChild.getAttribute(\"href\")})||ka(\"type|href|height|width\",function(a,b,c){if(!c)return a.getAttribute(b,\"type\"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML=\"<input/>\",a.firstChild.setAttribute(\"value\",\"\"),\"\"===a.firstChild.getAttribute(\"value\")})||ka(\"value\",function(a,b,c){if(!c&&\"input\"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute(\"disabled\")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[\":\"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i,D=/^.[^:#\\[\\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):\"string\"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=\":not(\"+a+\")\"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if(\"string\"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,\"string\"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,\"string\"==typeof a){if(e=\"<\"===a[0]&&\">\"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g=\"string\"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?\"string\"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,\"parentNode\")},parentsUntil:function(a,b,c){return y(a,\"parentNode\",c)},next:function(a){return K(a,\"nextSibling\")},prev:function(a){return K(a,\"previousSibling\")},nextAll:function(a){return y(a,\"nextSibling\")},prevAll:function(a){return y(a,\"previousSibling\")},nextUntil:function(a,b,c){return y(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return y(a,\"previousSibling\",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,\"iframe\")?a.contentDocument:(B(a,\"template\")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return\"Until\"!==a.slice(-5)&&(d=c),d&&\"string\"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\\x20\\t\\r\\n\\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a=\"string\"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:\"\")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&\"string\"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c=\"\",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=\"\"),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[[\"notify\",\"progress\",r.Callbacks(\"memory\"),r.Callbacks(\"memory\"),2],[\"resolve\",\"done\",r.Callbacks(\"once memory\"),r.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",r.Callbacks(\"once memory\"),r.Callbacks(\"once memory\"),1,\"rejected\"]],d=\"pending\",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},\"catch\":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+\"With\"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError(\"Thenable self-resolution\");j=a&&(\"object\"==typeof a||\"function\"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+\"With\"](this===f?void 0:this,arguments),this},f[b[0]+\"With\"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),\"pending\"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn(\"jQuery.Deferred exception: \"+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)[\"catch\"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener(\"DOMContentLoaded\",S),\r\na.removeEventListener(\"load\",S),r.ready()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener(\"DOMContentLoaded\",S),a.addEventListener(\"load\",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\"object\"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if(\"string\"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&\"string\"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,Z=/[A-Z]/g;function $(a){return\"true\"===a||\"false\"!==a&&(\"null\"===a?null:a===+a+\"\"?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d=\"data-\"+b.replace(Z,\"-$&\").toLowerCase(),c=a.getAttribute(d),\"string\"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,\"hasDataAttrs\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\"data-\")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,\"hasDataAttrs\",!0)}return e}return\"object\"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||\"fx\")+\"queue\",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||\"fx\";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};\"inprogress\"===e&&(e=c.shift(),d--),e&&(\"fx\"===b&&c.unshift(\"inprogress\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\"queueHooks\";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks(\"once memory\").add(function(){W.remove(a,[b+\"queue\",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return\"string\"!=typeof a&&(b=a,a=\"fx\",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),\"fx\"===a&&\"inprogress\"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\"string\"!=typeof a&&(b=a,a=void 0),a=a||\"fx\";while(g--)c=W.get(f[g],a+\"queueHooks\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,ba=new RegExp(\"^(?:([+-])=|)(\"+aa+\")([a-z%]*)$\",\"i\"),ca=[\"Top\",\"Right\",\"Bottom\",\"Left\"],da=function(a,b){return a=b||a,\"none\"===a.style.display||\"\"===a.style.display&&r.contains(a.ownerDocument,a)&&\"none\"===r.css(a,\"display\")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,\"\")},i=h(),j=c&&c[3]||(r.cssNumber[b]?\"\":\"px\"),k=(r.cssNumber[b]||\"px\"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||\".5\",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,\"display\"),b.parentNode.removeChild(b),\"none\"===e&&(e=\"block\"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?(\"none\"===c&&(e[f]=W.get(d,\"display\")||null,e[f]||(d.style.display=\"\")),\"\"===d.style.display&&da(d)&&(e[f]=ha(d))):\"none\"!==c&&(e[f]=\"none\",W.set(d,\"display\",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return\"boolean\"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i,la=/^$|\\/(?:java|ecma)script/i,ma={option:[1,\"<select multiple='multiple'>\",\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c=\"undefined\"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||\"*\"):\"undefined\"!=typeof a.querySelectorAll?a.querySelectorAll(b||\"*\"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],\"globalEval\",!b||W.get(b[c],\"globalEval\"))}var pa=/<|&#?\\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if(\"object\"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement(\"div\")),h=(ka.exec(f)||[\"\",\"\"])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=\"\"}else m.push(b.createTextNode(f));l.textContent=\"\",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),\"script\"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||\"\")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement(\"div\")),c=d.createElement(\"input\");c.setAttribute(\"type\",\"radio\"),c.setAttribute(\"checked\",\"checked\"),c.setAttribute(\"name\",\"t\"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML=\"<textarea>x</textarea>\",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if(\"object\"==typeof b){\"string\"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&(\"string\"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return\"undefined\"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||\"\").match(L)||[\"\"],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||\"\").split(\".\").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(\".\")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||\"\").match(L)||[\"\"],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||\"\").split(\".\").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp(\"(^|\\\\.)\"+o.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&(\"**\"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,\"handle events\")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,\"events\")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!(\"click\"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&(\"click\"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+\" \",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:\"focusin\"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:\"focusout\"},click:{trigger:function(){if(\"checkbox\"===this.type&&this.click&&B(this,\"input\"))return this.click(),!1},_default:function(a){return B(a.target,\"a\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+\".\"+d.namespace:d.origType,d.selector,d.handler),this;if(\"object\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&\"function\"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\\s*(?:[^=]|=\\s*.checked.)/i,Ca=/^true\\/(.*)/,Da=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function Ea(a,b){return B(a,\"table\")&&B(11!==b.nodeType?b:b.firstChild,\"tr\")?r(\">tbody\",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute(\"type\"))+\"/\"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\"type\"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();\"input\"===c&&ja.test(a.type)?b.checked=a.checked:\"input\"!==c&&\"textarea\"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&\"string\"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,\"script\"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,\"script\"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||\"\")&&!W.access(j,\"globalEval\")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,\"\"),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,\"script\")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,\"<$1></$2>\")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,\"script\"),g.length>0&&oa(g,!i&&na(a,\"script\")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent=\"\");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if(\"string\"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp(\"^(\"+aa+\")(?!px)[a-z%]+$\",\"i\"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText=\"box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\",i.innerHTML=\"\",ra.appendChild(h);var b=a.getComputedStyle(i);c=\"1%\"!==b.top,g=\"2px\"===b.marginLeft,e=\"4px\"===b.width,i.style.marginRight=\"50%\",f=\"4px\"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement(\"div\"),i=d.createElement(\"div\");i.style&&(i.style.backgroundClip=\"content-box\",i.cloneNode(!0).style.backgroundClip=\"\",o.clearCloneStyle=\"content-box\"===i.style.backgroundClip,h.style.cssText=\"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],\"\"!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+\"\":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Ta={letterSpacing:\"0\",fontWeight:\"400\"},Ua=[\"Webkit\",\"Moz\",\"ms\"],Va=d.createElement(\"div\").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||\"px\"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?\"border\":\"content\")?4:\"width\"===b?1:0;f<4;f+=2)\"margin\"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?(\"content\"===c&&(g-=r.css(a,\"padding\"+ca[f],!0,e)),\"margin\"!==c&&(g-=r.css(a,\"border\"+ca[f]+\"Width\",!0,e))):(g+=r.css(a,\"padding\"+ca[f],!0,e),\"padding\"!==c&&(g+=r.css(a,\"border\"+ca[f]+\"Width\",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g=\"border-box\"===r.css(a,\"boxSizing\",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),\"auto\"===f&&(f=a[\"offset\"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?\"border\":\"content\"),d,e)+\"px\")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,\"opacity\");return\"\"===c?\"1\":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":\"cssFloat\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&\"get\"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,\"string\"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f=\"number\"),null!=c&&c===c&&(\"number\"===f&&(c+=e&&e[3]||(r.cssNumber[h]?\"\":\"px\")),o.clearCloneStyle||\"\"!==c||0!==b.indexOf(\"background\")||(j[b]=\"inherit\"),g&&\"set\"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&\"get\"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),\"normal\"===e&&b in Ta&&(e=Ta[b]),\"\"===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each([\"height\",\"width\"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,\"display\"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,\"border-box\"===r.css(a,\"boxSizing\",!1,f),f);return g&&(e=ba.exec(c))&&\"px\"!==(e[3]||\"px\")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,\"marginLeft\"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+\"px\"}),r.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\"string\"==typeof c?c.split(\" \"):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?\"\":\"px\")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,\"\"),b&&\"auto\"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:\"swing\"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e[\"margin\"+c]=e[\"padding\"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners[\"*\"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l=\"width\"in b||\"height\"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,\"fxshow\");c.queue||(g=r._queueHooks(a,\"fx\"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,\"fx\").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||\"toggle\"===e,e===(p?\"hide\":\"show\")){if(\"show\"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,\"display\")),k=r.css(a,\"display\"),\"none\"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,\"display\"),ia([a]))),(\"inline\"===k||\"inline-block\"===k&&null!=j)&&\"none\"===r.css(a,\"float\")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j=\"none\"===k?\"\":k)),o.display=\"inline-block\")),c.overflow&&(o.overflow=\"hidden\",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?\"hidden\"in q&&(p=q.hidden):q=W.access(a,\"fxshow\",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,\"fxshow\");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&\"expand\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{\"*\":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=[\"*\"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&\"object\"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:\"number\"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue=\"fx\"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,\"finish\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\"string\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\"fx\",[]),this.each(function(){var b=!0,e=null!=a&&a+\"queueHooks\",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\"fx\"),this.each(function(){var b,c=W.get(this),d=c[a+\"queue\"],e=c[a+\"queueHooks\"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each([\"toggle\",\"show\",\"hide\"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||\"boolean\"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb(\"show\"),slideUp:gb(\"hide\"),slideToggle:gb(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||\"fx\",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement(\"input\"),b=d.createElement(\"select\"),c=b.appendChild(d.createElement(\"option\"));a.type=\"checkbox\",o.checkOn=\"\"!==a.value,o.optSelected=c.selected,a=d.createElement(\"input\"),a.value=\"t\",a.type=\"radio\",o.radioValue=\"t\"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return\"undefined\"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+\"\"),c):e&&\"get\"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),\r\nnull==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&\"radio\"===b&&B(a,\"input\")){var c=a.value;return a.setAttribute(\"type\",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\"get\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,\"tabindex\");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(\" \")}function qb(a){return a.getAttribute&&a.getAttribute(\"class\")||\"\"}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if(\"string\"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&\" \"+pb(e)+\" \"){g=0;while(f=b[g++])d.indexOf(\" \"+f+\" \")<0&&(d+=f+\" \");h=pb(d),e!==h&&c.setAttribute(\"class\",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if(\"string\"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&\" \"+pb(e)+\" \"){g=0;while(f=b[g++])while(d.indexOf(\" \"+f+\" \")>-1)d=d.replace(\" \"+f+\" \",\" \");h=pb(d),e!==h&&c.setAttribute(\"class\",h)}}return this},toggleClass:function(a,b){var c=typeof a;return\"boolean\"==typeof b&&\"string\"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if(\"string\"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&\"boolean\"!==c||(b=qb(this),b&&W.set(this,\"__className__\",b),this.setAttribute&&this.setAttribute(\"class\",b||a===!1?\"\":W.get(this,\"__className__\")||\"\"))})},hasClass:function(a){var b,c,d=0;b=\" \"+a+\" \";while(c=this[d++])if(1===c.nodeType&&(\" \"+pb(qb(c))+\" \").indexOf(b)>-1)return!0;return!1}});var rb=/\\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e=\"\":\"number\"==typeof e?e+=\"\":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?\"\":a+\"\"})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&\"set\"in b&&void 0!==b.set(this,e,\"value\")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&\"get\"in b&&void 0!==(c=b.get(e,\"value\"))?c:(c=e.value,\"string\"==typeof c?c.replace(rb,\"\"):null==c?\"\":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,\"value\");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g=\"select-one\"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,\"optgroup\"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each([\"radio\",\"checkbox\"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute(\"value\")?\"on\":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,\"type\")?b.type:b,q=l.call(b,\"namespace\")?b.namespace.split(\".\"):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(\".\")>-1&&(q=p.split(\".\"),p=q.shift(),q.sort()),k=p.indexOf(\":\")<0&&\"on\"+p,b=b[r.expando]?b:new r.Event(p,\"object\"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join(\".\"),b.rnamespace=b.namespace?new RegExp(\"(^|\\\\.)\"+q.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,\"events\")||{})[b.type]&&W.get(h,\"handle\"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin=\"onfocusin\"in a,o.focusin||r.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\\?/;r.parseXML=function(b){var c;if(!b||\"string\"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,\"text/xml\")}catch(d){c=void 0}return c&&!c.getElementsByTagName(\"parsererror\").length||r.error(\"Invalid XML: \"+b),c};var wb=/\\[\\]$/,xb=/\\r?\\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+\"[\"+(\"object\"==typeof e&&null!=e?b:\"\")+\"]\",e,c,d)});else if(c||\"object\"!==r.type(b))d(a,b);else for(e in b)Ab(a+\"[\"+e+\"]\",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(null==c?\"\":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join(\"&\")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,\"elements\");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(\":disabled\")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,\"\\r\\n\")}}):{name:b.name,value:c.replace(xb,\"\\r\\n\")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\\/\\//,Ib={},Jb={},Kb=\"*/\".concat(\"*\"),Lb=d.createElement(\"a\");Lb.href=tb.href;function Mb(a){return function(b,c){\"string\"!=typeof b&&(c=b,b=\"*\");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])\"+\"===d[0]?(d=d.slice(1)||\"*\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return\"string\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\"*\"]&&g(\"*\")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\"*\"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader(\"Content-Type\"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+\" \"+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\"*\"===f)f=i;else if(\"*\"!==i&&i!==f){if(g=j[i+\" \"+f]||j[\"* \"+f],!g)for(e in j)if(h=e.split(\" \"),h[1]===f&&(g=j[i+\" \"+h[0]]||j[\"* \"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\"throws\"])b=g(b);else try{b=g(b)}catch(l){return{state:\"parsererror\",error:g?l:\"No conversion from \"+i+\" to \"+f}}}return{state:\"success\",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:\"GET\",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Kb,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/\\bxml\\b/,html:/\\bhtml/,json:/\\bjson\\b/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){\"object\"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks(\"once memory\"),u=o.statusCode||{},v={},w={},x=\"canceled\",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+\"\").replace(Hb,tb.protocol+\"//\"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||\"*\").toLowerCase().match(L)||[\"\"],null==o.crossDomain){j=d.createElement(\"a\");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+\"//\"+Lb.host!=j.protocol+\"//\"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&\"string\"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger(\"ajaxStart\"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,\"\"),o.hasContent?o.data&&o.processData&&0===(o.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&(o.data=o.data.replace(Bb,\"+\")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?\"&\":\"?\")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,\"$1\"),n=(vb.test(f)?\"&\":\"?\")+\"_=\"+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader(\"If-Modified-Since\",r.lastModified[f]),r.etag[f]&&y.setRequestHeader(\"If-None-Match\",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader(\"Content-Type\",o.contentType),y.setRequestHeader(\"Accept\",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+(\"*\"!==o.dataTypes[0]?\", \"+Kb+\"; q=0.01\":\"\"):o.accepts[\"*\"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x=\"abort\",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger(\"ajaxSend\",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort(\"timeout\")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,\"No Transport\");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||\"\",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader(\"Last-Modified\"),w&&(r.lastModified[f]=w),w=y.getResponseHeader(\"etag\"),w&&(r.etag[f]=w)),204===b||\"HEAD\"===o.type?x=\"nocontent\":304===b?x=\"notmodified\":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x=\"error\",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+\"\",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?\"ajaxSuccess\":\"ajaxError\",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger(\"ajaxComplete\",[y,o]),--r.active||r.event.trigger(\"ajaxStop\")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,\"json\")},getScript:function(a,b){return r.get(a,void 0,b,\"script\")}}),r.each([\"get\",\"post\"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,\"throws\":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not(\"body\").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&\"withCredentials\"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,\"abort\"===a?h.abort():\"error\"===a?\"number\"!=typeof h.status?f(0,\"error\"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,\"text\"!==(h.responseType||\"text\")||\"string\"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c(\"error\"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c(\"abort\");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/\\b(?:java|ecma)script\\b/},converters:{\"text script\":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter(\"script\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\")}),r.ajaxTransport(\"script\",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r(\"<script>\").prop({charset:a.scriptCharset,src:a.url}).on(\"load error\",c=function(a){b.remove(),c=null,a&&f(\"error\"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\\?(?=&|$)|\\?\\?/;r.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var a=Tb.pop()||r.expando+\"_\"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?\"url\":\"string\"==typeof b.data&&0===(b.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Ub.test(b.data)&&\"data\");if(h||\"jsonp\"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,\"$1\"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?\"&\":\"?\")+b.jsonp+\"=\"+e),b.converters[\"script json\"]=function(){return g||r.error(e+\" was not called\"),g[0]},b.dataTypes[0]=\"json\",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),\"script\"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument(\"\").body;return a.innerHTML=\"<form></form><form></form>\",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if(\"string\"!=typeof a)return[];\"boolean\"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(\"\"),e=b.createElement(\"base\"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(\" \");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&\"object\"==typeof b&&(e=\"POST\"),g.length>0&&r.ajax({url:a,type:e||\"GET\",dataType:\"html\",data:b}).done(function(a){f=arguments,g.html(d?r(\"<div>\").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,\"position\"),l=r(a),m={};\"static\"===k&&(a.style.position=\"relative\"),h=l.offset(),f=r.css(a,\"top\"),i=r.css(a,\"left\"),j=(\"absolute\"===k||\"fixed\"===k)&&(f+i).indexOf(\"auto\")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\"using\"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return\"fixed\"===r.css(c,\"position\")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],\"html\")||(d=a.offset()),d={top:d.top+r.css(a[0],\"borderTopWidth\",!0),left:d.left+r.css(a[0],\"borderLeftWidth\",!0)}),{top:b.top-d.top-r.css(c,\"marginTop\",!0),left:b.left-d.left-r.css(c,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&\"static\"===r.css(a,\"position\"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(a,b){var c=\"pageYOffset\"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each([\"top\",\"left\"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+\"px\":c})}),r.each({Height:\"height\",Width:\"width\"},function(a,b){r.each({padding:\"inner\"+a,content:b,\"\":\"outer\"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||\"boolean\"!=typeof e),h=c||(e===!0||f===!0?\"margin\":\"border\");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf(\"outer\")?b[\"inner\"+a]:b.document.documentElement[\"client\"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body[\"scroll\"+a],f[\"scroll\"+a],b.body[\"offset\"+a],f[\"offset\"+a],f[\"client\"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\"**\"):this.off(b,a||\"**\",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});\r\n"

/***/ }),

/***/ 257:
/***/ (function(module, exports) {

module.exports = "/**\r\n * @license\r\n * lodash 3.10.1 (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modern -d -o ./index.js`\r\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n * Available under MIT license <https://lodash.com/license>\r\n */\r\n;(function() {\r\n\r\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\r\n  var undefined;\r\n\r\n  /** Used as the semantic version number. */\r\n  var VERSION = '3.10.1';\r\n\r\n  /** Used to compose bitmasks for wrapper metadata. */\r\n  var BIND_FLAG = 1,\r\n      BIND_KEY_FLAG = 2,\r\n      CURRY_BOUND_FLAG = 4,\r\n      CURRY_FLAG = 8,\r\n      CURRY_RIGHT_FLAG = 16,\r\n      PARTIAL_FLAG = 32,\r\n      PARTIAL_RIGHT_FLAG = 64,\r\n      ARY_FLAG = 128,\r\n      REARG_FLAG = 256;\r\n\r\n  /** Used as default options for `_.trunc`. */\r\n  var DEFAULT_TRUNC_LENGTH = 30,\r\n      DEFAULT_TRUNC_OMISSION = '...';\r\n\r\n  /** Used to detect when a function becomes hot. */\r\n  var HOT_COUNT = 150,\r\n      HOT_SPAN = 16;\r\n\r\n  /** Used as the size to enable large array optimizations. */\r\n  var LARGE_ARRAY_SIZE = 200;\r\n\r\n  /** Used to indicate the type of lazy iteratees. */\r\n  var LAZY_FILTER_FLAG = 1,\r\n      LAZY_MAP_FLAG = 2;\r\n\r\n  /** Used as the `TypeError` message for \"Functions\" methods. */\r\n  var FUNC_ERROR_TEXT = 'Expected a function';\r\n\r\n  /** Used as the internal argument placeholder. */\r\n  var PLACEHOLDER = '__lodash_placeholder__';\r\n\r\n  /** `Object#toString` result references. */\r\n  var argsTag = '[object Arguments]',\r\n      arrayTag = '[object Array]',\r\n      boolTag = '[object Boolean]',\r\n      dateTag = '[object Date]',\r\n      errorTag = '[object Error]',\r\n      funcTag = '[object Function]',\r\n      mapTag = '[object Map]',\r\n      numberTag = '[object Number]',\r\n      objectTag = '[object Object]',\r\n      regexpTag = '[object RegExp]',\r\n      setTag = '[object Set]',\r\n      stringTag = '[object String]',\r\n      weakMapTag = '[object WeakMap]';\r\n\r\n  var arrayBufferTag = '[object ArrayBuffer]',\r\n      float32Tag = '[object Float32Array]',\r\n      float64Tag = '[object Float64Array]',\r\n      int8Tag = '[object Int8Array]',\r\n      int16Tag = '[object Int16Array]',\r\n      int32Tag = '[object Int32Array]',\r\n      uint8Tag = '[object Uint8Array]',\r\n      uint8ClampedTag = '[object Uint8ClampedArray]',\r\n      uint16Tag = '[object Uint16Array]',\r\n      uint32Tag = '[object Uint32Array]';\r\n\r\n  /** Used to match empty string literals in compiled template source. */\r\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\r\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\r\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\r\n\r\n  /** Used to match HTML entities and HTML characters. */\r\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\r\n      reUnescapedHtml = /[&<>\"'`]/g,\r\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\r\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\r\n\r\n  /** Used to match template delimiters. */\r\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\r\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\r\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\r\n\r\n  /** Used to match property names within property paths. */\r\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\r\n      reIsPlainProp = /^\\w*$/,\r\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\r\n\r\n  /**\r\n   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)\r\n   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).\r\n   */\r\n  var reRegExpChars = /^[:!,]|[\\\\^$.*+?()[\\]{}|\\/]|(^[0-9a-fA-Fnrtuvx])|([\\n\\r\\u2028\\u2029])/g,\r\n      reHasRegExpChars = RegExp(reRegExpChars.source);\r\n\r\n  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\r\n  var reComboMark = /[\\u0300-\\u036f\\ufe20-\\ufe23]/g;\r\n\r\n  /** Used to match backslashes in property paths. */\r\n  var reEscapeChar = /\\\\(\\\\)?/g;\r\n\r\n  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\r\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\r\n\r\n  /** Used to match `RegExp` flags from their coerced string values. */\r\n  var reFlags = /\\w*$/;\r\n\r\n  /** Used to detect hexadecimal string values. */\r\n  var reHasHexPrefix = /^0[xX]/;\r\n\r\n  /** Used to detect host constructors (Safari > 5). */\r\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n\r\n  /** Used to detect unsigned integer values. */\r\n  var reIsUint = /^\\d+$/;\r\n\r\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\r\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\r\n\r\n  /** Used to ensure capturing order of template delimiters. */\r\n  var reNoMatch = /($^)/;\r\n\r\n  /** Used to match unescaped characters in compiled string literals. */\r\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\r\n\r\n  /** Used to match words to create compound words. */\r\n  var reWords = (function() {\r\n    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\r\n        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\r\n\r\n    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\r\n  }());\r\n\r\n  /** Used to assign default `context` object properties. */\r\n  var contextProps = [\r\n    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\r\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\r\n    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',\r\n    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\r\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'\r\n  ];\r\n\r\n  /** Used to make template sourceURLs easier to identify. */\r\n  var templateCounter = -1;\r\n\r\n  /** Used to identify `toStringTag` values of typed arrays. */\r\n  var typedArrayTags = {};\r\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\r\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\r\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\r\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\r\n  typedArrayTags[uint32Tag] = true;\r\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\r\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\r\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\r\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\r\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\r\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\r\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\r\n\r\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\r\n  var cloneableTags = {};\r\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\r\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\r\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\r\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\r\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\r\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\r\n  cloneableTags[regexpTag] = cloneableTags[stringTag] =\r\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\r\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\r\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\r\n  cloneableTags[mapTag] = cloneableTags[setTag] =\r\n  cloneableTags[weakMapTag] = false;\r\n\r\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\r\n  var deburredLetters = {\r\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\r\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\r\n    '\\xc7': 'C',  '\\xe7': 'c',\r\n    '\\xd0': 'D',  '\\xf0': 'd',\r\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\r\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\r\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\r\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\r\n    '\\xd1': 'N',  '\\xf1': 'n',\r\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\r\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\r\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\r\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\r\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\r\n    '\\xc6': 'Ae', '\\xe6': 'ae',\r\n    '\\xde': 'Th', '\\xfe': 'th',\r\n    '\\xdf': 'ss'\r\n  };\r\n\r\n  /** Used to map characters to HTML entities. */\r\n  var htmlEscapes = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&quot;',\r\n    \"'\": '&#39;',\r\n    '`': '&#96;'\r\n  };\r\n\r\n  /** Used to map HTML entities to characters. */\r\n  var htmlUnescapes = {\r\n    '&amp;': '&',\r\n    '&lt;': '<',\r\n    '&gt;': '>',\r\n    '&quot;': '\"',\r\n    '&#39;': \"'\",\r\n    '&#96;': '`'\r\n  };\r\n\r\n  /** Used to determine if values are of the language type `Object`. */\r\n  var objectTypes = {\r\n    'function': true,\r\n    'object': true\r\n  };\r\n\r\n  /** Used to escape characters for inclusion in compiled regexes. */\r\n  var regexpEscapes = {\r\n    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',\r\n    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',\r\n    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',\r\n    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',\r\n    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'\r\n  };\r\n\r\n  /** Used to escape characters for inclusion in compiled string literals. */\r\n  var stringEscapes = {\r\n    '\\\\': '\\\\',\r\n    \"'\": \"'\",\r\n    '\\n': 'n',\r\n    '\\r': 'r',\r\n    '\\u2028': 'u2028',\r\n    '\\u2029': 'u2029'\r\n  };\r\n\r\n  /** Detect free variable `exports`. */\r\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\r\n\r\n  /** Detect free variable `module`. */\r\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\r\n\r\n  /** Detect free variable `global` from Node.js. */\r\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;\r\n\r\n  /** Detect free variable `self`. */\r\n  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\r\n\r\n  /** Detect free variable `window`. */\r\n  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\r\n\r\n  /** Detect the popular CommonJS extension `module.exports`. */\r\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\r\n\r\n  /**\r\n   * Used as a reference to the global object.\r\n   *\r\n   * The `this` value is used if it's the global object to avoid Greasemonkey's\r\n   * restricted `window` object, otherwise the `window` object is used.\r\n   */\r\n  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * The base implementation of `compareAscending` which compares values and\r\n   * sorts them in ascending order without guaranteeing a stable sort.\r\n   *\r\n   * @private\r\n   * @param {*} value The value to compare.\r\n   * @param {*} other The other value to compare.\r\n   * @returns {number} Returns the sort order indicator for `value`.\r\n   */\r\n  function baseCompareAscending(value, other) {\r\n    if (value !== other) {\r\n      var valIsNull = value === null,\r\n          valIsUndef = value === undefined,\r\n          valIsReflexive = value === value;\r\n\r\n      var othIsNull = other === null,\r\n          othIsUndef = other === undefined,\r\n          othIsReflexive = other === other;\r\n\r\n      if ((value > other && !othIsNull) || !valIsReflexive ||\r\n          (valIsNull && !othIsUndef && othIsReflexive) ||\r\n          (valIsUndef && othIsReflexive)) {\r\n        return 1;\r\n      }\r\n      if ((value < other && !valIsNull) || !othIsReflexive ||\r\n          (othIsNull && !valIsUndef && valIsReflexive) ||\r\n          (othIsUndef && valIsReflexive)) {\r\n        return -1;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n   * support for callback shorthands and `this` binding.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to search.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @param {boolean} [fromRight] Specify iterating from right to left.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function baseFindIndex(array, predicate, fromRight) {\r\n    var length = array.length,\r\n        index = fromRight ? length : -1;\r\n\r\n    while ((fromRight ? index-- : ++index < length)) {\r\n      if (predicate(array[index], index, array)) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.indexOf` without support for binary searches.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to search.\r\n   * @param {*} value The value to search for.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function baseIndexOf(array, value, fromIndex) {\r\n    if (value !== value) {\r\n      return indexOfNaN(array, fromIndex);\r\n    }\r\n    var index = fromIndex - 1,\r\n        length = array.length;\r\n\r\n    while (++index < length) {\r\n      if (array[index] === value) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.isFunction` without support for environments\r\n   * with incorrect `typeof` results.\r\n   *\r\n   * @private\r\n   * @param {*} value The value to check.\r\n   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n   */\r\n  function baseIsFunction(value) {\r\n    // Avoid a Chakra JIT bug in compatibility modes of IE 11.\r\n    // See https://github.com/jashkenas/underscore/issues/1621 for more details.\r\n    return typeof value == 'function' || false;\r\n  }\r\n\r\n  /**\r\n   * Converts `value` to a string if it's not one. An empty string is returned\r\n   * for `null` or `undefined` values.\r\n   *\r\n   * @private\r\n   * @param {*} value The value to process.\r\n   * @returns {string} Returns the string.\r\n   */\r\n  function baseToString(value) {\r\n    return value == null ? '' : (value + '');\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\r\n   * of `string` that is not found in `chars`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @param {string} chars The characters to find.\r\n   * @returns {number} Returns the index of the first character not found in `chars`.\r\n   */\r\n  function charsLeftIndex(string, chars) {\r\n    var index = -1,\r\n        length = string.length;\r\n\r\n    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimRight` to get the index of the last character\r\n   * of `string` that is not found in `chars`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @param {string} chars The characters to find.\r\n   * @returns {number} Returns the index of the last character not found in `chars`.\r\n   */\r\n  function charsRightIndex(string, chars) {\r\n    var index = string.length;\r\n\r\n    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\r\n   * sort them in ascending order.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to compare.\r\n   * @param {Object} other The other object to compare.\r\n   * @returns {number} Returns the sort order indicator for `object`.\r\n   */\r\n  function compareAscending(object, other) {\r\n    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\r\n  }\r\n\r\n  /**\r\n   * Used by `_.sortByOrder` to compare multiple properties of a value to another\r\n   * and stable sort them.\r\n   *\r\n   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,\r\n   * a value is sorted in ascending order if its corresponding order is \"asc\", and\r\n   * descending if \"desc\".\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to compare.\r\n   * @param {Object} other The other object to compare.\r\n   * @param {boolean[]} orders The order to sort by for each property.\r\n   * @returns {number} Returns the sort order indicator for `object`.\r\n   */\r\n  function compareMultiple(object, other, orders) {\r\n    var index = -1,\r\n        objCriteria = object.criteria,\r\n        othCriteria = other.criteria,\r\n        length = objCriteria.length,\r\n        ordersLength = orders.length;\r\n\r\n    while (++index < length) {\r\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\r\n      if (result) {\r\n        if (index >= ordersLength) {\r\n          return result;\r\n        }\r\n        var order = orders[index];\r\n        return result * ((order === 'asc' || order === true) ? 1 : -1);\r\n      }\r\n    }\r\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\r\n    // that causes it, under certain circumstances, to provide the same value for\r\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\r\n    // for more details.\r\n    //\r\n    // This also ensures a stable sort in V8 and other engines.\r\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\r\n    return object.index - other.index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\r\n   *\r\n   * @private\r\n   * @param {string} letter The matched letter to deburr.\r\n   * @returns {string} Returns the deburred letter.\r\n   */\r\n  function deburrLetter(letter) {\r\n    return deburredLetters[letter];\r\n  }\r\n\r\n  /**\r\n   * Used by `_.escape` to convert characters to HTML entities.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to escape.\r\n   * @returns {string} Returns the escaped character.\r\n   */\r\n  function escapeHtmlChar(chr) {\r\n    return htmlEscapes[chr];\r\n  }\r\n\r\n  /**\r\n   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to escape.\r\n   * @param {string} leadingChar The capture group for a leading character.\r\n   * @param {string} whitespaceChar The capture group for a whitespace character.\r\n   * @returns {string} Returns the escaped character.\r\n   */\r\n  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {\r\n    if (leadingChar) {\r\n      chr = regexpEscapes[chr];\r\n    } else if (whitespaceChar) {\r\n      chr = stringEscapes[chr];\r\n    }\r\n    return '\\\\' + chr;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to escape.\r\n   * @returns {string} Returns the escaped character.\r\n   */\r\n  function escapeStringChar(chr) {\r\n    return '\\\\' + stringEscapes[chr];\r\n  }\r\n\r\n  /**\r\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to search.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @param {boolean} [fromRight] Specify iterating from right to left.\r\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\r\n   */\r\n  function indexOfNaN(array, fromIndex, fromRight) {\r\n    var length = array.length,\r\n        index = fromIndex + (fromRight ? 0 : -1);\r\n\r\n    while ((fromRight ? index-- : ++index < length)) {\r\n      var other = array[index];\r\n      if (other !== other) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Checks if `value` is object-like.\r\n   *\r\n   * @private\r\n   * @param {*} value The value to check.\r\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n   */\r\n  function isObjectLike(value) {\r\n    return !!value && typeof value == 'object';\r\n  }\r\n\r\n  /**\r\n   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\r\n   * character code is whitespace.\r\n   *\r\n   * @private\r\n   * @param {number} charCode The character code to inspect.\r\n   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\r\n   */\r\n  function isSpace(charCode) {\r\n    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\r\n      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\r\n  }\r\n\r\n  /**\r\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\r\n   * and returns an array of their indexes.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to modify.\r\n   * @param {*} placeholder The placeholder to replace.\r\n   * @returns {Array} Returns the new array of placeholder indexes.\r\n   */\r\n  function replaceHolders(array, placeholder) {\r\n    var index = -1,\r\n        length = array.length,\r\n        resIndex = -1,\r\n        result = [];\r\n\r\n    while (++index < length) {\r\n      if (array[index] === placeholder) {\r\n        array[index] = PLACEHOLDER;\r\n        result[++resIndex] = index;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * An implementation of `_.uniq` optimized for sorted arrays without support\r\n   * for callback shorthands and `this` binding.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {Function} [iteratee] The function invoked per iteration.\r\n   * @returns {Array} Returns the new duplicate-value-free array.\r\n   */\r\n  function sortedUniq(array, iteratee) {\r\n    var seen,\r\n        index = -1,\r\n        length = array.length,\r\n        resIndex = -1,\r\n        result = [];\r\n\r\n    while (++index < length) {\r\n      var value = array[index],\r\n          computed = iteratee ? iteratee(value, index, array) : value;\r\n\r\n      if (!index || seen !== computed) {\r\n        seen = computed;\r\n        result[++resIndex] = value;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\r\n   * character of `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {number} Returns the index of the first non-whitespace character.\r\n   */\r\n  function trimmedLeftIndex(string) {\r\n    var index = -1,\r\n        length = string.length;\r\n\r\n    while (++index < length && isSpace(string.charCodeAt(index))) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\r\n   * character of `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {number} Returns the index of the last non-whitespace character.\r\n   */\r\n  function trimmedRightIndex(string) {\r\n    var index = string.length;\r\n\r\n    while (index-- && isSpace(string.charCodeAt(index))) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.unescape` to convert HTML entities to characters.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to unescape.\r\n   * @returns {string} Returns the unescaped character.\r\n   */\r\n  function unescapeHtmlChar(chr) {\r\n    return htmlUnescapes[chr];\r\n  }\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * Create a new pristine `lodash` function using the given `context` object.\r\n   *\r\n   * @static\r\n   * @memberOf _\r\n   * @category Utility\r\n   * @param {Object} [context=root] The context object.\r\n   * @returns {Function} Returns a new `lodash` function.\r\n   * @example\r\n   *\r\n   * _.mixin({ 'foo': _.constant('foo') });\r\n   *\r\n   * var lodash = _.runInContext();\r\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\r\n   *\r\n   * _.isFunction(_.foo);\r\n   * // => true\r\n   * _.isFunction(_.bar);\r\n   * // => false\r\n   *\r\n   * lodash.isFunction(lodash.foo);\r\n   * // => false\r\n   * lodash.isFunction(lodash.bar);\r\n   * // => true\r\n   *\r\n   * // using `context` to mock `Date#getTime` use in `_.now`\r\n   * var mock = _.runInContext({\r\n   *   'Date': function() {\r\n   *     return { 'getTime': getTimeMock };\r\n   *   }\r\n   * });\r\n   *\r\n   * // or creating a suped-up `defer` in Node.js\r\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\r\n   */\r\n  function runInContext(context) {\r\n    // Avoid issues with some ES3 environments that attempt to use values, named\r\n    // after built-in constructors like `Object`, for the creation of literals.\r\n    // ES5 clears this up by stating that literals must use built-in constructors.\r\n    // See https://es5.github.io/#x11.1.5 for more details.\r\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\r\n\r\n    /** Native constructor references. */\r\n    var Array = context.Array,\r\n        Date = context.Date,\r\n        Error = context.Error,\r\n        Function = context.Function,\r\n        Math = context.Math,\r\n        Number = context.Number,\r\n        Object = context.Object,\r\n        RegExp = context.RegExp,\r\n        String = context.String,\r\n        TypeError = context.TypeError;\r\n\r\n    /** Used for native method references. */\r\n    var arrayProto = Array.prototype,\r\n        objectProto = Object.prototype,\r\n        stringProto = String.prototype;\r\n\r\n    /** Used to resolve the decompiled source of functions. */\r\n    var fnToString = Function.prototype.toString;\r\n\r\n    /** Used to check objects for own properties. */\r\n    var hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n    /** Used to generate unique IDs. */\r\n    var idCounter = 0;\r\n\r\n    /**\r\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\r\n     * of values.\r\n     */\r\n    var objToString = objectProto.toString;\r\n\r\n    /** Used to restore the original `_` reference in `_.noConflict`. */\r\n    var oldDash = root._;\r\n\r\n    /** Used to detect if a method is native. */\r\n    var reIsNative = RegExp('^' +\r\n      fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\r\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\r\n    );\r\n\r\n    /** Native method references. */\r\n    var ArrayBuffer = context.ArrayBuffer,\r\n        clearTimeout = context.clearTimeout,\r\n        parseFloat = context.parseFloat,\r\n        pow = Math.pow,\r\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\r\n        Set = getNative(context, 'Set'),\r\n        setTimeout = context.setTimeout,\r\n        splice = arrayProto.splice,\r\n        Uint8Array = context.Uint8Array,\r\n        WeakMap = getNative(context, 'WeakMap');\r\n\r\n    /* Native method references for those with the same name as other `lodash` methods. */\r\n    var nativeCeil = Math.ceil,\r\n        nativeCreate = getNative(Object, 'create'),\r\n        nativeFloor = Math.floor,\r\n        nativeIsArray = getNative(Array, 'isArray'),\r\n        nativeIsFinite = context.isFinite,\r\n        nativeKeys = getNative(Object, 'keys'),\r\n        nativeMax = Math.max,\r\n        nativeMin = Math.min,\r\n        nativeNow = getNative(Date, 'now'),\r\n        nativeParseInt = context.parseInt,\r\n        nativeRandom = Math.random;\r\n\r\n    /** Used as references for `-Infinity` and `Infinity`. */\r\n    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\r\n        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\r\n\r\n    /** Used as references for the maximum length and index of an array. */\r\n    var MAX_ARRAY_LENGTH = 4294967295,\r\n        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\r\n        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\r\n\r\n    /**\r\n     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\r\n     * of an array-like value.\r\n     */\r\n    var MAX_SAFE_INTEGER = 9007199254740991;\r\n\r\n    /** Used to store function metadata. */\r\n    var metaMap = WeakMap && new WeakMap;\r\n\r\n    /** Used to lookup unminified function names. */\r\n    var realNames = {};\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\r\n     * Methods that operate on and return arrays, collections, and functions can\r\n     * be chained together. Methods that retrieve a single value or may return a\r\n     * primitive value will automatically end the chain returning the unwrapped\r\n     * value. Explicit chaining may be enabled using `_.chain`. The execution of\r\n     * chained methods is lazy, that is, execution is deferred until `_#value`\r\n     * is implicitly or explicitly called.\r\n     *\r\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\r\n     * fusion is an optimization strategy which merge iteratee calls; this can help\r\n     * to avoid the creation of intermediate data structures and greatly reduce the\r\n     * number of iteratee executions.\r\n     *\r\n     * Chaining is supported in custom builds as long as the `_#value` method is\r\n     * directly or indirectly included in the build.\r\n     *\r\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\r\n     *\r\n     * The wrapper `Array` methods are:\r\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\r\n     * `splice`, and `unshift`\r\n     *\r\n     * The wrapper `String` methods are:\r\n     * `replace` and `split`\r\n     *\r\n     * The wrapper methods that support shortcut fusion are:\r\n     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\r\n     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\r\n     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\r\n     * and `where`\r\n     *\r\n     * The chainable wrapper methods are:\r\n     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\r\n     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\r\n     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\r\n     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\r\n     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\r\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\r\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\r\n     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\r\n     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\r\n     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\r\n     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\r\n     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\r\n     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\r\n     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\r\n     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\r\n     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\r\n     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\r\n     *\r\n     * The wrapper methods that are **not** chainable by default are:\r\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\r\n     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\r\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\r\n     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\r\n     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\r\n     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\r\n     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\r\n     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\r\n     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\r\n     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\r\n     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\r\n     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\r\n     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\r\n     * `unescape`, `uniqueId`, `value`, and `words`\r\n     *\r\n     * The wrapper method `sample` will return a wrapped value when `n` is provided,\r\n     * otherwise an unwrapped value is returned.\r\n     *\r\n     * @name _\r\n     * @constructor\r\n     * @category Chain\r\n     * @param {*} value The value to wrap in a `lodash` instance.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var wrapped = _([1, 2, 3]);\r\n     *\r\n     * // returns an unwrapped value\r\n     * wrapped.reduce(function(total, n) {\r\n     *   return total + n;\r\n     * });\r\n     * // => 6\r\n     *\r\n     * // returns a wrapped value\r\n     * var squares = wrapped.map(function(n) {\r\n     *   return n * n;\r\n     * });\r\n     *\r\n     * _.isArray(squares);\r\n     * // => false\r\n     *\r\n     * _.isArray(squares.value());\r\n     * // => true\r\n     */\r\n    function lodash(value) {\r\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\r\n        if (value instanceof LodashWrapper) {\r\n          return value;\r\n        }\r\n        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\r\n          return wrapperClone(value);\r\n        }\r\n      }\r\n      return new LodashWrapper(value);\r\n    }\r\n\r\n    /**\r\n     * The function whose prototype all chaining wrappers inherit from.\r\n     *\r\n     * @private\r\n     */\r\n    function baseLodash() {\r\n      // No operation performed.\r\n    }\r\n\r\n    /**\r\n     * The base constructor for creating `lodash` wrapper objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to wrap.\r\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\r\n     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\r\n     */\r\n    function LodashWrapper(value, chainAll, actions) {\r\n      this.__wrapped__ = value;\r\n      this.__actions__ = actions || [];\r\n      this.__chain__ = !!chainAll;\r\n    }\r\n\r\n    /**\r\n     * An object environment feature flags.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @type Object\r\n     */\r\n    var support = lodash.support = {};\r\n\r\n    /**\r\n     * By default, the template delimiters used by lodash are like those in\r\n     * embedded Ruby (ERB). Change the following template settings to use\r\n     * alternative delimiters.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @type Object\r\n     */\r\n    lodash.templateSettings = {\r\n\r\n      /**\r\n       * Used to detect `data` property values to be HTML-escaped.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type RegExp\r\n       */\r\n      'escape': reEscape,\r\n\r\n      /**\r\n       * Used to detect code to be evaluated.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type RegExp\r\n       */\r\n      'evaluate': reEvaluate,\r\n\r\n      /**\r\n       * Used to detect `data` property values to inject.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type RegExp\r\n       */\r\n      'interpolate': reInterpolate,\r\n\r\n      /**\r\n       * Used to reference the data object in the template text.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type string\r\n       */\r\n      'variable': '',\r\n\r\n      /**\r\n       * Used to import variables into the compiled template.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type Object\r\n       */\r\n      'imports': {\r\n\r\n        /**\r\n         * A reference to the `lodash` function.\r\n         *\r\n         * @memberOf _.templateSettings.imports\r\n         * @type Function\r\n         */\r\n        '_': lodash\r\n      }\r\n    };\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to wrap.\r\n     */\r\n    function LazyWrapper(value) {\r\n      this.__wrapped__ = value;\r\n      this.__actions__ = [];\r\n      this.__dir__ = 1;\r\n      this.__filtered__ = false;\r\n      this.__iteratees__ = [];\r\n      this.__takeCount__ = POSITIVE_INFINITY;\r\n      this.__views__ = [];\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the lazy wrapper object.\r\n     *\r\n     * @private\r\n     * @name clone\r\n     * @memberOf LazyWrapper\r\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\r\n     */\r\n    function lazyClone() {\r\n      var result = new LazyWrapper(this.__wrapped__);\r\n      result.__actions__ = arrayCopy(this.__actions__);\r\n      result.__dir__ = this.__dir__;\r\n      result.__filtered__ = this.__filtered__;\r\n      result.__iteratees__ = arrayCopy(this.__iteratees__);\r\n      result.__takeCount__ = this.__takeCount__;\r\n      result.__views__ = arrayCopy(this.__views__);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Reverses the direction of lazy iteration.\r\n     *\r\n     * @private\r\n     * @name reverse\r\n     * @memberOf LazyWrapper\r\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\r\n     */\r\n    function lazyReverse() {\r\n      if (this.__filtered__) {\r\n        var result = new LazyWrapper(this);\r\n        result.__dir__ = -1;\r\n        result.__filtered__ = true;\r\n      } else {\r\n        result = this.clone();\r\n        result.__dir__ *= -1;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the unwrapped value from its lazy wrapper.\r\n     *\r\n     * @private\r\n     * @name value\r\n     * @memberOf LazyWrapper\r\n     * @returns {*} Returns the unwrapped value.\r\n     */\r\n    function lazyValue() {\r\n      var array = this.__wrapped__.value(),\r\n          dir = this.__dir__,\r\n          isArr = isArray(array),\r\n          isRight = dir < 0,\r\n          arrLength = isArr ? array.length : 0,\r\n          view = getView(0, arrLength, this.__views__),\r\n          start = view.start,\r\n          end = view.end,\r\n          length = end - start,\r\n          index = isRight ? end : (start - 1),\r\n          iteratees = this.__iteratees__,\r\n          iterLength = iteratees.length,\r\n          resIndex = 0,\r\n          takeCount = nativeMin(length, this.__takeCount__);\r\n\r\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\r\n        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);\r\n      }\r\n      var result = [];\r\n\r\n      outer:\r\n      while (length-- && resIndex < takeCount) {\r\n        index += dir;\r\n\r\n        var iterIndex = -1,\r\n            value = array[index];\r\n\r\n        while (++iterIndex < iterLength) {\r\n          var data = iteratees[iterIndex],\r\n              iteratee = data.iteratee,\r\n              type = data.type,\r\n              computed = iteratee(value);\r\n\r\n          if (type == LAZY_MAP_FLAG) {\r\n            value = computed;\r\n          } else if (!computed) {\r\n            if (type == LAZY_FILTER_FLAG) {\r\n              continue outer;\r\n            } else {\r\n              break outer;\r\n            }\r\n          }\r\n        }\r\n        result[resIndex++] = value;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a cache object to store key/value pairs.\r\n     *\r\n     * @private\r\n     * @static\r\n     * @name Cache\r\n     * @memberOf _.memoize\r\n     */\r\n    function MapCache() {\r\n      this.__data__ = {};\r\n    }\r\n\r\n    /**\r\n     * Removes `key` and its value from the cache.\r\n     *\r\n     * @private\r\n     * @name delete\r\n     * @memberOf _.memoize.Cache\r\n     * @param {string} key The key of the value to remove.\r\n     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\r\n     */\r\n    function mapDelete(key) {\r\n      return this.has(key) && delete this.__data__[key];\r\n    }\r\n\r\n    /**\r\n     * Gets the cached value for `key`.\r\n     *\r\n     * @private\r\n     * @name get\r\n     * @memberOf _.memoize.Cache\r\n     * @param {string} key The key of the value to get.\r\n     * @returns {*} Returns the cached value.\r\n     */\r\n    function mapGet(key) {\r\n      return key == '__proto__' ? undefined : this.__data__[key];\r\n    }\r\n\r\n    /**\r\n     * Checks if a cached value for `key` exists.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf _.memoize.Cache\r\n     * @param {string} key The key of the entry to check.\r\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n     */\r\n    function mapHas(key) {\r\n      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\r\n    }\r\n\r\n    /**\r\n     * Sets `value` to `key` of the cache.\r\n     *\r\n     * @private\r\n     * @name set\r\n     * @memberOf _.memoize.Cache\r\n     * @param {string} key The key of the value to cache.\r\n     * @param {*} value The value to cache.\r\n     * @returns {Object} Returns the cache object.\r\n     */\r\n    function mapSet(key, value) {\r\n      if (key != '__proto__') {\r\n        this.__data__[key] = value;\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     *\r\n     * Creates a cache object to store unique values.\r\n     *\r\n     * @private\r\n     * @param {Array} [values] The values to cache.\r\n     */\r\n    function SetCache(values) {\r\n      var length = values ? values.length : 0;\r\n\r\n      this.data = { 'hash': nativeCreate(null), 'set': new Set };\r\n      while (length--) {\r\n        this.push(values[length]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is in `cache` mimicking the return signature of\r\n     * `_.indexOf` by returning `0` if the value is found, else `-1`.\r\n     *\r\n     * @private\r\n     * @param {Object} cache The cache to search.\r\n     * @param {*} value The value to search for.\r\n     * @returns {number} Returns `0` if `value` is found, else `-1`.\r\n     */\r\n    function cacheIndexOf(cache, value) {\r\n      var data = cache.data,\r\n          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\r\n\r\n      return result ? 0 : -1;\r\n    }\r\n\r\n    /**\r\n     * Adds `value` to the cache.\r\n     *\r\n     * @private\r\n     * @name push\r\n     * @memberOf SetCache\r\n     * @param {*} value The value to cache.\r\n     */\r\n    function cachePush(value) {\r\n      var data = this.data;\r\n      if (typeof value == 'string' || isObject(value)) {\r\n        data.set.add(value);\r\n      } else {\r\n        data.hash[value] = true;\r\n      }\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a new array joining `array` with `other`.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to join.\r\n     * @param {Array} other The other array to join.\r\n     * @returns {Array} Returns the new concatenated array.\r\n     */\r\n    function arrayConcat(array, other) {\r\n      var index = -1,\r\n          length = array.length,\r\n          othIndex = -1,\r\n          othLength = other.length,\r\n          result = Array(length + othLength);\r\n\r\n      while (++index < length) {\r\n        result[index] = array[index];\r\n      }\r\n      while (++othIndex < othLength) {\r\n        result[index++] = other[othIndex];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Copies the values of `source` to `array`.\r\n     *\r\n     * @private\r\n     * @param {Array} source The array to copy values from.\r\n     * @param {Array} [array=[]] The array to copy values to.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function arrayCopy(source, array) {\r\n      var index = -1,\r\n          length = source.length;\r\n\r\n      array || (array = Array(length));\r\n      while (++index < length) {\r\n        array[index] = source[index];\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.forEach` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function arrayEach(array, iteratee) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (iteratee(array[index], index, array) === false) {\r\n          break;\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.forEachRight` for arrays without support for\r\n     * callback shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function arrayEachRight(array, iteratee) {\r\n      var length = array.length;\r\n\r\n      while (length--) {\r\n        if (iteratee(array[length], length, array) === false) {\r\n          break;\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.every` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n     *  else `false`.\r\n     */\r\n    function arrayEvery(array, predicate) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (!predicate(array[index], index, array)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`\r\n     * with one argument: (value).\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} comparator The function used to compare values.\r\n     * @param {*} exValue The initial extremum value.\r\n     * @returns {*} Returns the extremum value.\r\n     */\r\n    function arrayExtremum(array, iteratee, comparator, exValue) {\r\n      var index = -1,\r\n          length = array.length,\r\n          computed = exValue,\r\n          result = computed;\r\n\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            current = +iteratee(value);\r\n\r\n        if (comparator(current, computed)) {\r\n          computed = current;\r\n          result = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.filter` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {Array} Returns the new filtered array.\r\n     */\r\n    function arrayFilter(array, predicate) {\r\n      var index = -1,\r\n          length = array.length,\r\n          resIndex = -1,\r\n          result = [];\r\n\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (predicate(value, index, array)) {\r\n          result[++resIndex] = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.map` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array} Returns the new mapped array.\r\n     */\r\n    function arrayMap(array, iteratee) {\r\n      var index = -1,\r\n          length = array.length,\r\n          result = Array(length);\r\n\r\n      while (++index < length) {\r\n        result[index] = iteratee(array[index], index, array);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Appends the elements of `values` to `array`.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to modify.\r\n     * @param {Array} values The values to append.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function arrayPush(array, values) {\r\n      var index = -1,\r\n          length = values.length,\r\n          offset = array.length;\r\n\r\n      while (++index < length) {\r\n        array[offset + index] = values[index];\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.reduce` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @param {boolean} [initFromArray] Specify using the first element of `array`\r\n     *  as the initial value.\r\n     * @returns {*} Returns the accumulated value.\r\n     */\r\n    function arrayReduce(array, iteratee, accumulator, initFromArray) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      if (initFromArray && length) {\r\n        accumulator = array[++index];\r\n      }\r\n      while (++index < length) {\r\n        accumulator = iteratee(accumulator, array[index], index, array);\r\n      }\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.reduceRight` for arrays without support for\r\n     * callback shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @param {boolean} [initFromArray] Specify using the last element of `array`\r\n     *  as the initial value.\r\n     * @returns {*} Returns the accumulated value.\r\n     */\r\n    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\r\n      var length = array.length;\r\n      if (initFromArray && length) {\r\n        accumulator = array[--length];\r\n      }\r\n      while (length--) {\r\n        accumulator = iteratee(accumulator, array[length], length, array);\r\n      }\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.some` for arrays without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n     *  else `false`.\r\n     */\r\n    function arraySome(array, predicate) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (predicate(array[index], index, array)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.sum` for arrays without support for callback\r\n     * shorthands and `this` binding..\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {number} Returns the sum.\r\n     */\r\n    function arraySum(array, iteratee) {\r\n      var length = array.length,\r\n          result = 0;\r\n\r\n      while (length--) {\r\n        result += +iteratee(array[length]) || 0;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.defaults` to customize its `_.assign` use.\r\n     *\r\n     * @private\r\n     * @param {*} objectValue The destination object property value.\r\n     * @param {*} sourceValue The source object property value.\r\n     * @returns {*} Returns the value to assign to the destination object.\r\n     */\r\n    function assignDefaults(objectValue, sourceValue) {\r\n      return objectValue === undefined ? sourceValue : objectValue;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.template` to customize its `_.assign` use.\r\n     *\r\n     * **Note:** This function is like `assignDefaults` except that it ignores\r\n     * inherited property values when checking if a property is `undefined`.\r\n     *\r\n     * @private\r\n     * @param {*} objectValue The destination object property value.\r\n     * @param {*} sourceValue The source object property value.\r\n     * @param {string} key The key associated with the object and source values.\r\n     * @param {Object} object The destination object.\r\n     * @returns {*} Returns the value to assign to the destination object.\r\n     */\r\n    function assignOwnDefaults(objectValue, sourceValue, key, object) {\r\n      return (objectValue === undefined || !hasOwnProperty.call(object, key))\r\n        ? sourceValue\r\n        : objectValue;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.assign` for customizing assigned values without\r\n     * support for argument juggling, multiple sources, and `this` binding `customizer`\r\n     * functions.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @param {Function} customizer The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function assignWith(object, source, customizer) {\r\n      var index = -1,\r\n          props = keys(source),\r\n          length = props.length;\r\n\r\n      while (++index < length) {\r\n        var key = props[index],\r\n            value = object[key],\r\n            result = customizer(value, source[key], key, object, source);\r\n\r\n        if ((result === result ? (result !== value) : (value === value)) ||\r\n            (value === undefined && !(key in object))) {\r\n          object[key] = result;\r\n        }\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.assign` without support for argument juggling,\r\n     * multiple sources, and `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseAssign(object, source) {\r\n      return source == null\r\n        ? object\r\n        : baseCopy(source, keys(source), object);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.at` without support for string collections\r\n     * and individual key arguments.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {number[]|string[]} props The property names or indexes of elements to pick.\r\n     * @returns {Array} Returns the new array of picked elements.\r\n     */\r\n    function baseAt(collection, props) {\r\n      var index = -1,\r\n          isNil = collection == null,\r\n          isArr = !isNil && isArrayLike(collection),\r\n          length = isArr ? collection.length : 0,\r\n          propsLength = props.length,\r\n          result = Array(propsLength);\r\n\r\n      while(++index < propsLength) {\r\n        var key = props[index];\r\n        if (isArr) {\r\n          result[index] = isIndex(key, length) ? collection[key] : undefined;\r\n        } else {\r\n          result[index] = isNil ? undefined : collection[key];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Copies properties of `source` to `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object to copy properties from.\r\n     * @param {Array} props The property names to copy.\r\n     * @param {Object} [object={}] The object to copy properties to.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseCopy(source, props, object) {\r\n      object || (object = {});\r\n\r\n      var index = -1,\r\n          length = props.length;\r\n\r\n      while (++index < length) {\r\n        var key = props[index];\r\n        object[key] = source[key];\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.callback` which supports specifying the\r\n     * number of arguments to provide to `func`.\r\n     *\r\n     * @private\r\n     * @param {*} [func=_.identity] The value to convert to a callback.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {number} [argCount] The number of arguments to provide to `func`.\r\n     * @returns {Function} Returns the callback.\r\n     */\r\n    function baseCallback(func, thisArg, argCount) {\r\n      var type = typeof func;\r\n      if (type == 'function') {\r\n        return thisArg === undefined\r\n          ? func\r\n          : bindCallback(func, thisArg, argCount);\r\n      }\r\n      if (func == null) {\r\n        return identity;\r\n      }\r\n      if (type == 'object') {\r\n        return baseMatches(func);\r\n      }\r\n      return thisArg === undefined\r\n        ? property(func)\r\n        : baseMatchesProperty(func, thisArg);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.clone` without support for argument juggling\r\n     * and `this` binding `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @param {Function} [customizer] The function to customize cloning values.\r\n     * @param {string} [key] The key of `value`.\r\n     * @param {Object} [object] The object `value` belongs to.\r\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\r\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\r\n     * @returns {*} Returns the cloned value.\r\n     */\r\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\r\n      var result;\r\n      if (customizer) {\r\n        result = object ? customizer(value, key, object) : customizer(value);\r\n      }\r\n      if (result !== undefined) {\r\n        return result;\r\n      }\r\n      if (!isObject(value)) {\r\n        return value;\r\n      }\r\n      var isArr = isArray(value);\r\n      if (isArr) {\r\n        result = initCloneArray(value);\r\n        if (!isDeep) {\r\n          return arrayCopy(value, result);\r\n        }\r\n      } else {\r\n        var tag = objToString.call(value),\r\n            isFunc = tag == funcTag;\r\n\r\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\r\n          result = initCloneObject(isFunc ? {} : value);\r\n          if (!isDeep) {\r\n            return baseAssign(result, value);\r\n          }\r\n        } else {\r\n          return cloneableTags[tag]\r\n            ? initCloneByTag(value, tag, isDeep)\r\n            : (object ? value : {});\r\n        }\r\n      }\r\n      // Check for circular references and return its corresponding clone.\r\n      stackA || (stackA = []);\r\n      stackB || (stackB = []);\r\n\r\n      var length = stackA.length;\r\n      while (length--) {\r\n        if (stackA[length] == value) {\r\n          return stackB[length];\r\n        }\r\n      }\r\n      // Add the source value to the stack of traversed objects and associate it with its clone.\r\n      stackA.push(value);\r\n      stackB.push(result);\r\n\r\n      // Recursively populate clone (susceptible to call stack limits).\r\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\r\n        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.create` without support for assigning\r\n     * properties to the created object.\r\n     *\r\n     * @private\r\n     * @param {Object} prototype The object to inherit from.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    var baseCreate = (function() {\r\n      function object() {}\r\n      return function(prototype) {\r\n        if (isObject(prototype)) {\r\n          object.prototype = prototype;\r\n          var result = new object;\r\n          object.prototype = undefined;\r\n        }\r\n        return result || {};\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * The base implementation of `_.delay` and `_.defer` which accepts an index\r\n     * of where to slice the arguments to provide to `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to delay.\r\n     * @param {number} wait The number of milliseconds to delay invocation.\r\n     * @param {Object} args The arguments provide to `func`.\r\n     * @returns {number} Returns the timer id.\r\n     */\r\n    function baseDelay(func, wait, args) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.difference` which accepts a single array\r\n     * of values to exclude.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Array} values The values to exclude.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     */\r\n    function baseDifference(array, values) {\r\n      var length = array ? array.length : 0,\r\n          result = [];\r\n\r\n      if (!length) {\r\n        return result;\r\n      }\r\n      var index = -1,\r\n          indexOf = getIndexOf(),\r\n          isCommon = indexOf == baseIndexOf,\r\n          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\r\n          valuesLength = values.length;\r\n\r\n      if (cache) {\r\n        indexOf = cacheIndexOf;\r\n        isCommon = false;\r\n        values = cache;\r\n      }\r\n      outer:\r\n      while (++index < length) {\r\n        var value = array[index];\r\n\r\n        if (isCommon && value === value) {\r\n          var valuesIndex = valuesLength;\r\n          while (valuesIndex--) {\r\n            if (values[valuesIndex] === value) {\r\n              continue outer;\r\n            }\r\n          }\r\n          result.push(value);\r\n        }\r\n        else if (indexOf(values, value, 0) < 0) {\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.forEach` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array|Object|string} Returns `collection`.\r\n     */\r\n    var baseEach = createBaseEach(baseForOwn);\r\n\r\n    /**\r\n     * The base implementation of `_.forEachRight` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array|Object|string} Returns `collection`.\r\n     */\r\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\r\n\r\n    /**\r\n     * The base implementation of `_.every` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n     *  else `false`\r\n     */\r\n    function baseEvery(collection, predicate) {\r\n      var result = true;\r\n      baseEach(collection, function(value, index, collection) {\r\n        result = !!predicate(value, index, collection);\r\n        return result;\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the extremum value of `collection` invoking `iteratee` for each value\r\n     * in `collection` to generate the criterion by which the value is ranked.\r\n     * The `iteratee` is invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} comparator The function used to compare values.\r\n     * @param {*} exValue The initial extremum value.\r\n     * @returns {*} Returns the extremum value.\r\n     */\r\n    function baseExtremum(collection, iteratee, comparator, exValue) {\r\n      var computed = exValue,\r\n          result = computed;\r\n\r\n      baseEach(collection, function(value, index, collection) {\r\n        var current = +iteratee(value, index, collection);\r\n        if (comparator(current, computed) || (current === exValue && current === result)) {\r\n          computed = current;\r\n          result = value;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.fill` without an iteratee call guard.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to fill.\r\n     * @param {*} value The value to fill `array` with.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function baseFill(array, value, start, end) {\r\n      var length = array.length;\r\n\r\n      start = start == null ? 0 : (+start || 0);\r\n      if (start < 0) {\r\n        start = -start > length ? 0 : (length + start);\r\n      }\r\n      end = (end === undefined || end > length) ? length : (+end || 0);\r\n      if (end < 0) {\r\n        end += length;\r\n      }\r\n      length = start > end ? 0 : (end >>> 0);\r\n      start >>>= 0;\r\n\r\n      while (start < length) {\r\n        array[start++] = value;\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.filter` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {Array} Returns the new filtered array.\r\n     */\r\n    function baseFilter(collection, predicate) {\r\n      var result = [];\r\n      baseEach(collection, function(value, index, collection) {\r\n        if (predicate(value, index, collection)) {\r\n          result.push(value);\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\r\n     * without support for callback shorthands and `this` binding, which iterates\r\n     * over `collection` using the provided `eachFunc`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {Function} eachFunc The function to iterate over `collection`.\r\n     * @param {boolean} [retKey] Specify returning the key of the found element\r\n     *  instead of the element itself.\r\n     * @returns {*} Returns the found element or its key, else `undefined`.\r\n     */\r\n    function baseFind(collection, predicate, eachFunc, retKey) {\r\n      var result;\r\n      eachFunc(collection, function(value, key, collection) {\r\n        if (predicate(value, key, collection)) {\r\n          result = retKey ? key : value;\r\n          return false;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.flatten` with added support for restricting\r\n     * flattening and specifying the start index.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to flatten.\r\n     * @param {boolean} [isDeep] Specify a deep flatten.\r\n     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\r\n     * @param {Array} [result=[]] The initial result value.\r\n     * @returns {Array} Returns the new flattened array.\r\n     */\r\n    function baseFlatten(array, isDeep, isStrict, result) {\r\n      result || (result = []);\r\n\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (isObjectLike(value) && isArrayLike(value) &&\r\n            (isStrict || isArray(value) || isArguments(value))) {\r\n          if (isDeep) {\r\n            // Recursively flatten arrays (susceptible to call stack limits).\r\n            baseFlatten(value, isDeep, isStrict, result);\r\n          } else {\r\n            arrayPush(result, value);\r\n          }\r\n        } else if (!isStrict) {\r\n          result[result.length] = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\r\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\r\n     * each property. Iteratee functions may exit iteration early by explicitly\r\n     * returning `false`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} keysFunc The function to get the keys of `object`.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    var baseFor = createBaseFor();\r\n\r\n    /**\r\n     * This function is like `baseFor` except that it iterates over properties\r\n     * in the opposite order.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} keysFunc The function to get the keys of `object`.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    var baseForRight = createBaseFor(true);\r\n\r\n    /**\r\n     * The base implementation of `_.forIn` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseForIn(object, iteratee) {\r\n      return baseFor(object, iteratee, keysIn);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.forOwn` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseForOwn(object, iteratee) {\r\n      return baseFor(object, iteratee, keys);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.forOwnRight` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseForOwnRight(object, iteratee) {\r\n      return baseForRight(object, iteratee, keys);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.functions` which creates an array of\r\n     * `object` function property names filtered from those provided.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Array} props The property names to filter.\r\n     * @returns {Array} Returns the new array of filtered property names.\r\n     */\r\n    function baseFunctions(object, props) {\r\n      var index = -1,\r\n          length = props.length,\r\n          resIndex = -1,\r\n          result = [];\r\n\r\n      while (++index < length) {\r\n        var key = props[index];\r\n        if (isFunction(object[key])) {\r\n          result[++resIndex] = key;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `get` without support for string paths\r\n     * and default values.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array} path The path of the property to get.\r\n     * @param {string} [pathKey] The key representation of path.\r\n     * @returns {*} Returns the resolved value.\r\n     */\r\n    function baseGet(object, path, pathKey) {\r\n      if (object == null) {\r\n        return;\r\n      }\r\n      if (pathKey !== undefined && pathKey in toObject(object)) {\r\n        path = [pathKey];\r\n      }\r\n      var index = 0,\r\n          length = path.length;\r\n\r\n      while (object != null && index < length) {\r\n        object = object[path[index++]];\r\n      }\r\n      return (index && index == length) ? object : undefined;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isEqual` without support for `this` binding\r\n     * `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @param {Function} [customizer] The function to customize comparing values.\r\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\r\n     * @param {Array} [stackA] Tracks traversed `value` objects.\r\n     * @param {Array} [stackB] Tracks traversed `other` objects.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     */\r\n    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\r\n      if (value === other) {\r\n        return true;\r\n      }\r\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\r\n        return value !== value && other !== other;\r\n      }\r\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\r\n     * deep comparisons and tracks traversed objects enabling objects with circular\r\n     * references to be compared.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Function} [customizer] The function to customize comparing objects.\r\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\r\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\r\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\r\n      var objIsArr = isArray(object),\r\n          othIsArr = isArray(other),\r\n          objTag = arrayTag,\r\n          othTag = arrayTag;\r\n\r\n      if (!objIsArr) {\r\n        objTag = objToString.call(object);\r\n        if (objTag == argsTag) {\r\n          objTag = objectTag;\r\n        } else if (objTag != objectTag) {\r\n          objIsArr = isTypedArray(object);\r\n        }\r\n      }\r\n      if (!othIsArr) {\r\n        othTag = objToString.call(other);\r\n        if (othTag == argsTag) {\r\n          othTag = objectTag;\r\n        } else if (othTag != objectTag) {\r\n          othIsArr = isTypedArray(other);\r\n        }\r\n      }\r\n      var objIsObj = objTag == objectTag,\r\n          othIsObj = othTag == objectTag,\r\n          isSameTag = objTag == othTag;\r\n\r\n      if (isSameTag && !(objIsArr || objIsObj)) {\r\n        return equalByTag(object, other, objTag);\r\n      }\r\n      if (!isLoose) {\r\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\r\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\r\n\r\n        if (objIsWrapped || othIsWrapped) {\r\n          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\r\n        }\r\n      }\r\n      if (!isSameTag) {\r\n        return false;\r\n      }\r\n      // Assume cyclic values are equal.\r\n      // For more information on detecting circular references see https://es5.github.io/#JO.\r\n      stackA || (stackA = []);\r\n      stackB || (stackB = []);\r\n\r\n      var length = stackA.length;\r\n      while (length--) {\r\n        if (stackA[length] == object) {\r\n          return stackB[length] == other;\r\n        }\r\n      }\r\n      // Add `object` and `other` to the stack of traversed objects.\r\n      stackA.push(object);\r\n      stackB.push(other);\r\n\r\n      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\r\n\r\n      stackA.pop();\r\n      stackB.pop();\r\n\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isMatch` without support for callback\r\n     * shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Array} matchData The propery names, values, and compare flags to match.\r\n     * @param {Function} [customizer] The function to customize comparing objects.\r\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n     */\r\n    function baseIsMatch(object, matchData, customizer) {\r\n      var index = matchData.length,\r\n          length = index,\r\n          noCustomizer = !customizer;\r\n\r\n      if (object == null) {\r\n        return !length;\r\n      }\r\n      object = toObject(object);\r\n      while (index--) {\r\n        var data = matchData[index];\r\n        if ((noCustomizer && data[2])\r\n              ? data[1] !== object[data[0]]\r\n              : !(data[0] in object)\r\n            ) {\r\n          return false;\r\n        }\r\n      }\r\n      while (++index < length) {\r\n        data = matchData[index];\r\n        var key = data[0],\r\n            objValue = object[key],\r\n            srcValue = data[1];\r\n\r\n        if (noCustomizer && data[2]) {\r\n          if (objValue === undefined && !(key in object)) {\r\n            return false;\r\n          }\r\n        } else {\r\n          var result = customizer ? customizer(objValue, srcValue, key) : undefined;\r\n          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.map` without support for callback shorthands\r\n     * and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array} Returns the new mapped array.\r\n     */\r\n    function baseMap(collection, iteratee) {\r\n      var index = -1,\r\n          result = isArrayLike(collection) ? Array(collection.length) : [];\r\n\r\n      baseEach(collection, function(value, key, collection) {\r\n        result[++index] = iteratee(value, key, collection);\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.matches` which does not clone `source`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function baseMatches(source) {\r\n      var matchData = getMatchData(source);\r\n      if (matchData.length == 1 && matchData[0][2]) {\r\n        var key = matchData[0][0],\r\n            value = matchData[0][1];\r\n\r\n        return function(object) {\r\n          if (object == null) {\r\n            return false;\r\n          }\r\n          return object[key] === value && (value !== undefined || (key in toObject(object)));\r\n        };\r\n      }\r\n      return function(object) {\r\n        return baseIsMatch(object, matchData);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\r\n     *\r\n     * @private\r\n     * @param {string} path The path of the property to get.\r\n     * @param {*} srcValue The value to compare.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function baseMatchesProperty(path, srcValue) {\r\n      var isArr = isArray(path),\r\n          isCommon = isKey(path) && isStrictComparable(srcValue),\r\n          pathKey = (path + '');\r\n\r\n      path = toPath(path);\r\n      return function(object) {\r\n        if (object == null) {\r\n          return false;\r\n        }\r\n        var key = pathKey;\r\n        object = toObject(object);\r\n        if ((isArr || !isCommon) && !(key in object)) {\r\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n          if (object == null) {\r\n            return false;\r\n          }\r\n          key = last(path);\r\n          object = toObject(object);\r\n        }\r\n        return object[key] === srcValue\r\n          ? (srcValue !== undefined || (key in object))\r\n          : baseIsEqual(srcValue, object[key], undefined, true);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.merge` without support for argument juggling,\r\n     * multiple sources, and `this` binding `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @param {Function} [customizer] The function to customize merged values.\r\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\r\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseMerge(object, source, customizer, stackA, stackB) {\r\n      if (!isObject(object)) {\r\n        return object;\r\n      }\r\n      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\r\n          props = isSrcArr ? undefined : keys(source);\r\n\r\n      arrayEach(props || source, function(srcValue, key) {\r\n        if (props) {\r\n          key = srcValue;\r\n          srcValue = source[key];\r\n        }\r\n        if (isObjectLike(srcValue)) {\r\n          stackA || (stackA = []);\r\n          stackB || (stackB = []);\r\n          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\r\n        }\r\n        else {\r\n          var value = object[key],\r\n              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\r\n              isCommon = result === undefined;\r\n\r\n          if (isCommon) {\r\n            result = srcValue;\r\n          }\r\n          if ((result !== undefined || (isSrcArr && !(key in object))) &&\r\n              (isCommon || (result === result ? (result !== value) : (value === value)))) {\r\n            object[key] = result;\r\n          }\r\n        }\r\n      });\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseMerge` for arrays and objects which performs\r\n     * deep merges and tracks traversed objects enabling objects with circular\r\n     * references to be merged.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @param {string} key The key of the value to merge.\r\n     * @param {Function} mergeFunc The function to merge values.\r\n     * @param {Function} [customizer] The function to customize merged values.\r\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\r\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\r\n      var length = stackA.length,\r\n          srcValue = source[key];\r\n\r\n      while (length--) {\r\n        if (stackA[length] == srcValue) {\r\n          object[key] = stackB[length];\r\n          return;\r\n        }\r\n      }\r\n      var value = object[key],\r\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\r\n          isCommon = result === undefined;\r\n\r\n      if (isCommon) {\r\n        result = srcValue;\r\n        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\r\n          result = isArray(value)\r\n            ? value\r\n            : (isArrayLike(value) ? arrayCopy(value) : []);\r\n        }\r\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\r\n          result = isArguments(value)\r\n            ? toPlainObject(value)\r\n            : (isPlainObject(value) ? value : {});\r\n        }\r\n        else {\r\n          isCommon = false;\r\n        }\r\n      }\r\n      // Add the source value to the stack of traversed objects and associate\r\n      // it with its merged value.\r\n      stackA.push(srcValue);\r\n      stackB.push(result);\r\n\r\n      if (isCommon) {\r\n        // Recursively merge objects and arrays (susceptible to call stack limits).\r\n        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\r\n      } else if (result === result ? (result !== value) : (value === value)) {\r\n        object[key] = result;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.property` without support for deep paths.\r\n     *\r\n     * @private\r\n     * @param {string} key The key of the property to get.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function baseProperty(key) {\r\n      return function(object) {\r\n        return object == null ? undefined : object[key];\r\n      };\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseProperty` which supports deep paths.\r\n     *\r\n     * @private\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function basePropertyDeep(path) {\r\n      var pathKey = (path + '');\r\n      path = toPath(path);\r\n      return function(object) {\r\n        return baseGet(object, path, pathKey);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.pullAt` without support for individual\r\n     * index arguments and capturing the removed elements.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to modify.\r\n     * @param {number[]} indexes The indexes of elements to remove.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function basePullAt(array, indexes) {\r\n      var length = array ? indexes.length : 0;\r\n      while (length--) {\r\n        var index = indexes[length];\r\n        if (index != previous && isIndex(index)) {\r\n          var previous = index;\r\n          splice.call(array, index, 1);\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.random` without support for argument juggling\r\n     * and returning floating-point numbers.\r\n     *\r\n     * @private\r\n     * @param {number} min The minimum possible value.\r\n     * @param {number} max The maximum possible value.\r\n     * @returns {number} Returns the random number.\r\n     */\r\n    function baseRandom(min, max) {\r\n      return min + nativeFloor(nativeRandom() * (max - min + 1));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.reduce` and `_.reduceRight` without support\r\n     * for callback shorthands and `this` binding, which iterates over `collection`\r\n     * using the provided `eachFunc`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {*} accumulator The initial value.\r\n     * @param {boolean} initFromCollection Specify using the first or last element\r\n     *  of `collection` as the initial value.\r\n     * @param {Function} eachFunc The function to iterate over `collection`.\r\n     * @returns {*} Returns the accumulated value.\r\n     */\r\n    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\r\n      eachFunc(collection, function(value, index, collection) {\r\n        accumulator = initFromCollection\r\n          ? (initFromCollection = false, value)\r\n          : iteratee(accumulator, value, index, collection);\r\n      });\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `setData` without support for hot loop detection.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to associate metadata with.\r\n     * @param {*} data The metadata.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var baseSetData = !metaMap ? identity : function(func, data) {\r\n      metaMap.set(func, data);\r\n      return func;\r\n    };\r\n\r\n    /**\r\n     * The base implementation of `_.slice` without an iteratee call guard.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to slice.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function baseSlice(array, start, end) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      start = start == null ? 0 : (+start || 0);\r\n      if (start < 0) {\r\n        start = -start > length ? 0 : (length + start);\r\n      }\r\n      end = (end === undefined || end > length) ? length : (+end || 0);\r\n      if (end < 0) {\r\n        end += length;\r\n      }\r\n      length = start > end ? 0 : ((end - start) >>> 0);\r\n      start >>>= 0;\r\n\r\n      var result = Array(length);\r\n      while (++index < length) {\r\n        result[index] = array[index + start];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.some` without support for callback shorthands\r\n     * and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n     *  else `false`.\r\n     */\r\n    function baseSome(collection, predicate) {\r\n      var result;\r\n\r\n      baseEach(collection, function(value, index, collection) {\r\n        result = predicate(value, index, collection);\r\n        return !result;\r\n      });\r\n      return !!result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sortBy` which uses `comparer` to define\r\n     * the sort order of `array` and replaces criteria objects with their\r\n     * corresponding values.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to sort.\r\n     * @param {Function} comparer The function to define sort order.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function baseSortBy(array, comparer) {\r\n      var length = array.length;\r\n\r\n      array.sort(comparer);\r\n      while (length--) {\r\n        array[length] = array[length].value;\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sortByOrder` without param guards.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\r\n     * @param {boolean[]} orders The sort orders of `iteratees`.\r\n     * @returns {Array} Returns the new sorted array.\r\n     */\r\n    function baseSortByOrder(collection, iteratees, orders) {\r\n      var callback = getCallback(),\r\n          index = -1;\r\n\r\n      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });\r\n\r\n      var result = baseMap(collection, function(value) {\r\n        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });\r\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\r\n      });\r\n\r\n      return baseSortBy(result, function(object, other) {\r\n        return compareMultiple(object, other, orders);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sum` without support for callback shorthands\r\n     * and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {number} Returns the sum.\r\n     */\r\n    function baseSum(collection, iteratee) {\r\n      var result = 0;\r\n      baseEach(collection, function(value, index, collection) {\r\n        result += +iteratee(value, index, collection) || 0;\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.uniq` without support for callback shorthands\r\n     * and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [iteratee] The function invoked per iteration.\r\n     * @returns {Array} Returns the new duplicate-value-free array.\r\n     */\r\n    function baseUniq(array, iteratee) {\r\n      var index = -1,\r\n          indexOf = getIndexOf(),\r\n          length = array.length,\r\n          isCommon = indexOf == baseIndexOf,\r\n          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\r\n          seen = isLarge ? createCache() : null,\r\n          result = [];\r\n\r\n      if (seen) {\r\n        indexOf = cacheIndexOf;\r\n        isCommon = false;\r\n      } else {\r\n        isLarge = false;\r\n        seen = iteratee ? [] : result;\r\n      }\r\n      outer:\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            computed = iteratee ? iteratee(value, index, array) : value;\r\n\r\n        if (isCommon && value === value) {\r\n          var seenIndex = seen.length;\r\n          while (seenIndex--) {\r\n            if (seen[seenIndex] === computed) {\r\n              continue outer;\r\n            }\r\n          }\r\n          if (iteratee) {\r\n            seen.push(computed);\r\n          }\r\n          result.push(value);\r\n        }\r\n        else if (indexOf(seen, computed, 0) < 0) {\r\n          if (iteratee || isLarge) {\r\n            seen.push(computed);\r\n          }\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\r\n     * array of `object` property values corresponding to the property names\r\n     * of `props`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array} props The property names to get values for.\r\n     * @returns {Object} Returns the array of property values.\r\n     */\r\n    function baseValues(object, props) {\r\n      var index = -1,\r\n          length = props.length,\r\n          result = Array(length);\r\n\r\n      while (++index < length) {\r\n        result[index] = object[props[index]];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,\r\n     * and `_.takeWhile` without support for callback shorthands and `this` binding.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function baseWhile(array, predicate, isDrop, fromRight) {\r\n      var length = array.length,\r\n          index = fromRight ? length : -1;\r\n\r\n      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}\r\n      return isDrop\r\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\r\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `wrapperValue` which returns the result of\r\n     * performing a sequence of actions on the unwrapped `value`, where each\r\n     * successive action is supplied the return value of the previous.\r\n     *\r\n     * @private\r\n     * @param {*} value The unwrapped value.\r\n     * @param {Array} actions Actions to peform to resolve the unwrapped value.\r\n     * @returns {*} Returns the resolved value.\r\n     */\r\n    function baseWrapperValue(value, actions) {\r\n      var result = value;\r\n      if (result instanceof LazyWrapper) {\r\n        result = result.value();\r\n      }\r\n      var index = -1,\r\n          length = actions.length;\r\n\r\n      while (++index < length) {\r\n        var action = actions[index];\r\n        result = action.func.apply(action.thisArg, arrayPush([result], action.args));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Performs a binary search of `array` to determine the index at which `value`\r\n     * should be inserted into `array` in order to maintain its sort order.\r\n     *\r\n     * @private\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     */\r\n    function binaryIndex(array, value, retHighest) {\r\n      var low = 0,\r\n          high = array ? array.length : low;\r\n\r\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\r\n        while (low < high) {\r\n          var mid = (low + high) >>> 1,\r\n              computed = array[mid];\r\n\r\n          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\r\n            low = mid + 1;\r\n          } else {\r\n            high = mid;\r\n          }\r\n        }\r\n        return high;\r\n      }\r\n      return binaryIndexBy(array, value, identity, retHighest);\r\n    }\r\n\r\n    /**\r\n     * This function is like `binaryIndex` except that it invokes `iteratee` for\r\n     * `value` and each element of `array` to compute their sort ranking. The\r\n     * iteratee is invoked with one argument; (value).\r\n     *\r\n     * @private\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     */\r\n    function binaryIndexBy(array, value, iteratee, retHighest) {\r\n      value = iteratee(value);\r\n\r\n      var low = 0,\r\n          high = array ? array.length : 0,\r\n          valIsNaN = value !== value,\r\n          valIsNull = value === null,\r\n          valIsUndef = value === undefined;\r\n\r\n      while (low < high) {\r\n        var mid = nativeFloor((low + high) / 2),\r\n            computed = iteratee(array[mid]),\r\n            isDef = computed !== undefined,\r\n            isReflexive = computed === computed;\r\n\r\n        if (valIsNaN) {\r\n          var setLow = isReflexive || retHighest;\r\n        } else if (valIsNull) {\r\n          setLow = isReflexive && isDef && (retHighest || computed != null);\r\n        } else if (valIsUndef) {\r\n          setLow = isReflexive && (retHighest || isDef);\r\n        } else if (computed == null) {\r\n          setLow = false;\r\n        } else {\r\n          setLow = retHighest ? (computed <= value) : (computed < value);\r\n        }\r\n        if (setLow) {\r\n          low = mid + 1;\r\n        } else {\r\n          high = mid;\r\n        }\r\n      }\r\n      return nativeMin(high, MAX_ARRAY_INDEX);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseCallback` which only supports `this` binding\r\n     * and specifying the number of arguments to provide to `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to bind.\r\n     * @param {*} thisArg The `this` binding of `func`.\r\n     * @param {number} [argCount] The number of arguments to provide to `func`.\r\n     * @returns {Function} Returns the callback.\r\n     */\r\n    function bindCallback(func, thisArg, argCount) {\r\n      if (typeof func != 'function') {\r\n        return identity;\r\n      }\r\n      if (thisArg === undefined) {\r\n        return func;\r\n      }\r\n      switch (argCount) {\r\n        case 1: return function(value) {\r\n          return func.call(thisArg, value);\r\n        };\r\n        case 3: return function(value, index, collection) {\r\n          return func.call(thisArg, value, index, collection);\r\n        };\r\n        case 4: return function(accumulator, value, index, collection) {\r\n          return func.call(thisArg, accumulator, value, index, collection);\r\n        };\r\n        case 5: return function(value, other, key, object, source) {\r\n          return func.call(thisArg, value, other, key, object, source);\r\n        };\r\n      }\r\n      return function() {\r\n        return func.apply(thisArg, arguments);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the given array buffer.\r\n     *\r\n     * @private\r\n     * @param {ArrayBuffer} buffer The array buffer to clone.\r\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\r\n     */\r\n    function bufferClone(buffer) {\r\n      var result = new ArrayBuffer(buffer.byteLength),\r\n          view = new Uint8Array(result);\r\n\r\n      view.set(new Uint8Array(buffer));\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array that is the composition of partially applied arguments,\r\n     * placeholders, and provided arguments into a single array of arguments.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} args The provided arguments.\r\n     * @param {Array} partials The arguments to prepend to those provided.\r\n     * @param {Array} holders The `partials` placeholder indexes.\r\n     * @returns {Array} Returns the new array of composed arguments.\r\n     */\r\n    function composeArgs(args, partials, holders) {\r\n      var holdersLength = holders.length,\r\n          argsIndex = -1,\r\n          argsLength = nativeMax(args.length - holdersLength, 0),\r\n          leftIndex = -1,\r\n          leftLength = partials.length,\r\n          result = Array(leftLength + argsLength);\r\n\r\n      while (++leftIndex < leftLength) {\r\n        result[leftIndex] = partials[leftIndex];\r\n      }\r\n      while (++argsIndex < holdersLength) {\r\n        result[holders[argsIndex]] = args[argsIndex];\r\n      }\r\n      while (argsLength--) {\r\n        result[leftIndex++] = args[argsIndex++];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This function is like `composeArgs` except that the arguments composition\r\n     * is tailored for `_.partialRight`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} args The provided arguments.\r\n     * @param {Array} partials The arguments to append to those provided.\r\n     * @param {Array} holders The `partials` placeholder indexes.\r\n     * @returns {Array} Returns the new array of composed arguments.\r\n     */\r\n    function composeArgsRight(args, partials, holders) {\r\n      var holdersIndex = -1,\r\n          holdersLength = holders.length,\r\n          argsIndex = -1,\r\n          argsLength = nativeMax(args.length - holdersLength, 0),\r\n          rightIndex = -1,\r\n          rightLength = partials.length,\r\n          result = Array(argsLength + rightLength);\r\n\r\n      while (++argsIndex < argsLength) {\r\n        result[argsIndex] = args[argsIndex];\r\n      }\r\n      var offset = argsIndex;\r\n      while (++rightIndex < rightLength) {\r\n        result[offset + rightIndex] = partials[rightIndex];\r\n      }\r\n      while (++holdersIndex < holdersLength) {\r\n        result[offset + holders[holdersIndex]] = args[argsIndex++];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\r\n     *\r\n     * @private\r\n     * @param {Function} setter The function to set keys and values of the accumulator object.\r\n     * @param {Function} [initializer] The function to initialize the accumulator object.\r\n     * @returns {Function} Returns the new aggregator function.\r\n     */\r\n    function createAggregator(setter, initializer) {\r\n      return function(collection, iteratee, thisArg) {\r\n        var result = initializer ? initializer() : {};\r\n        iteratee = getCallback(iteratee, thisArg, 3);\r\n\r\n        if (isArray(collection)) {\r\n          var index = -1,\r\n              length = collection.length;\r\n\r\n          while (++index < length) {\r\n            var value = collection[index];\r\n            setter(result, value, iteratee(value, index, collection), collection);\r\n          }\r\n        } else {\r\n          baseEach(collection, function(value, key, collection) {\r\n            setter(result, value, iteratee(value, key, collection), collection);\r\n          });\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\r\n     *\r\n     * @private\r\n     * @param {Function} assigner The function to assign values.\r\n     * @returns {Function} Returns the new assigner function.\r\n     */\r\n    function createAssigner(assigner) {\r\n      return restParam(function(object, sources) {\r\n        var index = -1,\r\n            length = object == null ? 0 : sources.length,\r\n            customizer = length > 2 ? sources[length - 2] : undefined,\r\n            guard = length > 2 ? sources[2] : undefined,\r\n            thisArg = length > 1 ? sources[length - 1] : undefined;\r\n\r\n        if (typeof customizer == 'function') {\r\n          customizer = bindCallback(customizer, thisArg, 5);\r\n          length -= 2;\r\n        } else {\r\n          customizer = typeof thisArg == 'function' ? thisArg : undefined;\r\n          length -= (customizer ? 1 : 0);\r\n        }\r\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n          customizer = length < 3 ? undefined : customizer;\r\n          length = 1;\r\n        }\r\n        while (++index < length) {\r\n          var source = sources[index];\r\n          if (source) {\r\n            assigner(object, source, customizer);\r\n          }\r\n        }\r\n        return object;\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a `baseEach` or `baseEachRight` function.\r\n     *\r\n     * @private\r\n     * @param {Function} eachFunc The function to iterate over a collection.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new base function.\r\n     */\r\n    function createBaseEach(eachFunc, fromRight) {\r\n      return function(collection, iteratee) {\r\n        var length = collection ? getLength(collection) : 0;\r\n        if (!isLength(length)) {\r\n          return eachFunc(collection, iteratee);\r\n        }\r\n        var index = fromRight ? length : -1,\r\n            iterable = toObject(collection);\r\n\r\n        while ((fromRight ? index-- : ++index < length)) {\r\n          if (iteratee(iterable[index], index, iterable) === false) {\r\n            break;\r\n          }\r\n        }\r\n        return collection;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a base function for `_.forIn` or `_.forInRight`.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new base function.\r\n     */\r\n    function createBaseFor(fromRight) {\r\n      return function(object, iteratee, keysFunc) {\r\n        var iterable = toObject(object),\r\n            props = keysFunc(object),\r\n            length = props.length,\r\n            index = fromRight ? length : -1;\r\n\r\n        while ((fromRight ? index-- : ++index < length)) {\r\n          var key = props[index];\r\n          if (iteratee(iterable[key], key, iterable) === false) {\r\n            break;\r\n          }\r\n        }\r\n        return object;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` and invokes it with the `this`\r\n     * binding of `thisArg`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to bind.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @returns {Function} Returns the new bound function.\r\n     */\r\n    function createBindWrapper(func, thisArg) {\r\n      var Ctor = createCtorWrapper(func);\r\n\r\n      function wrapper() {\r\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\r\n        return fn.apply(thisArg, arguments);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a `Set` cache object to optimize linear searches of large arrays.\r\n     *\r\n     * @private\r\n     * @param {Array} [values] The values to cache.\r\n     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\r\n     */\r\n    function createCache(values) {\r\n      return (nativeCreate && Set) ? new SetCache(values) : null;\r\n    }\r\n\r\n    /**\r\n     * Creates a function that produces compound words out of the words in a\r\n     * given string.\r\n     *\r\n     * @private\r\n     * @param {Function} callback The function to combine each word.\r\n     * @returns {Function} Returns the new compounder function.\r\n     */\r\n    function createCompounder(callback) {\r\n      return function(string) {\r\n        var index = -1,\r\n            array = words(deburr(string)),\r\n            length = array.length,\r\n            result = '';\r\n\r\n        while (++index < length) {\r\n          result = callback(result, array[index], index);\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that produces an instance of `Ctor` regardless of\r\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\r\n     *\r\n     * @private\r\n     * @param {Function} Ctor The constructor to wrap.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createCtorWrapper(Ctor) {\r\n      return function() {\r\n        // Use a `switch` statement to work with class constructors.\r\n        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\r\n        // for more details.\r\n        var args = arguments;\r\n        switch (args.length) {\r\n          case 0: return new Ctor;\r\n          case 1: return new Ctor(args[0]);\r\n          case 2: return new Ctor(args[0], args[1]);\r\n          case 3: return new Ctor(args[0], args[1], args[2]);\r\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\r\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\r\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\r\n        }\r\n        var thisBinding = baseCreate(Ctor.prototype),\r\n            result = Ctor.apply(thisBinding, args);\r\n\r\n        // Mimic the constructor's `return` behavior.\r\n        // See https://es5.github.io/#x13.2.2 for more details.\r\n        return isObject(result) ? result : thisBinding;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.curry` or `_.curryRight` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} flag The curry bit flag.\r\n     * @returns {Function} Returns the new curry function.\r\n     */\r\n    function createCurry(flag) {\r\n      function curryFunc(func, arity, guard) {\r\n        if (guard && isIterateeCall(func, arity, guard)) {\r\n          arity = undefined;\r\n        }\r\n        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);\r\n        result.placeholder = curryFunc.placeholder;\r\n        return result;\r\n      }\r\n      return curryFunc;\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.defaults` or `_.defaultsDeep` function.\r\n     *\r\n     * @private\r\n     * @param {Function} assigner The function to assign values.\r\n     * @param {Function} customizer The function to customize assigned values.\r\n     * @returns {Function} Returns the new defaults function.\r\n     */\r\n    function createDefaults(assigner, customizer) {\r\n      return restParam(function(args) {\r\n        var object = args[0];\r\n        if (object == null) {\r\n          return object;\r\n        }\r\n        args.push(customizer);\r\n        return assigner.apply(undefined, args);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.max` or `_.min` function.\r\n     *\r\n     * @private\r\n     * @param {Function} comparator The function used to compare values.\r\n     * @param {*} exValue The initial extremum value.\r\n     * @returns {Function} Returns the new extremum function.\r\n     */\r\n    function createExtremum(comparator, exValue) {\r\n      return function(collection, iteratee, thisArg) {\r\n        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\r\n          iteratee = undefined;\r\n        }\r\n        iteratee = getCallback(iteratee, thisArg, 3);\r\n        if (iteratee.length == 1) {\r\n          collection = isArray(collection) ? collection : toIterable(collection);\r\n          var result = arrayExtremum(collection, iteratee, comparator, exValue);\r\n          if (!(collection.length && result === exValue)) {\r\n            return result;\r\n          }\r\n        }\r\n        return baseExtremum(collection, iteratee, comparator, exValue);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.find` or `_.findLast` function.\r\n     *\r\n     * @private\r\n     * @param {Function} eachFunc The function to iterate over a collection.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new find function.\r\n     */\r\n    function createFind(eachFunc, fromRight) {\r\n      return function(collection, predicate, thisArg) {\r\n        predicate = getCallback(predicate, thisArg, 3);\r\n        if (isArray(collection)) {\r\n          var index = baseFindIndex(collection, predicate, fromRight);\r\n          return index > -1 ? collection[index] : undefined;\r\n        }\r\n        return baseFind(collection, predicate, eachFunc);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.findIndex` or `_.findLastIndex` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new find function.\r\n     */\r\n    function createFindIndex(fromRight) {\r\n      return function(array, predicate, thisArg) {\r\n        if (!(array && array.length)) {\r\n          return -1;\r\n        }\r\n        predicate = getCallback(predicate, thisArg, 3);\r\n        return baseFindIndex(array, predicate, fromRight);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.findKey` or `_.findLastKey` function.\r\n     *\r\n     * @private\r\n     * @param {Function} objectFunc The function to iterate over an object.\r\n     * @returns {Function} Returns the new find function.\r\n     */\r\n    function createFindKey(objectFunc) {\r\n      return function(object, predicate, thisArg) {\r\n        predicate = getCallback(predicate, thisArg, 3);\r\n        return baseFind(object, predicate, objectFunc, true);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.flow` or `_.flowRight` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new flow function.\r\n     */\r\n    function createFlow(fromRight) {\r\n      return function() {\r\n        var wrapper,\r\n            length = arguments.length,\r\n            index = fromRight ? length : -1,\r\n            leftIndex = 0,\r\n            funcs = Array(length);\r\n\r\n        while ((fromRight ? index-- : ++index < length)) {\r\n          var func = funcs[leftIndex++] = arguments[index];\r\n          if (typeof func != 'function') {\r\n            throw new TypeError(FUNC_ERROR_TEXT);\r\n          }\r\n          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {\r\n            wrapper = new LodashWrapper([], true);\r\n          }\r\n        }\r\n        index = wrapper ? -1 : length;\r\n        while (++index < length) {\r\n          func = funcs[index];\r\n\r\n          var funcName = getFuncName(func),\r\n              data = funcName == 'wrapper' ? getData(func) : undefined;\r\n\r\n          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\r\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\r\n          } else {\r\n            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\r\n          }\r\n        }\r\n        return function() {\r\n          var args = arguments,\r\n              value = args[0];\r\n\r\n          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\r\n            return wrapper.plant(value).value();\r\n          }\r\n          var index = 0,\r\n              result = length ? funcs[index].apply(this, args) : value;\r\n\r\n          while (++index < length) {\r\n            result = funcs[index].call(this, result);\r\n          }\r\n          return result;\r\n        };\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.forEach` or `_.forEachRight`.\r\n     *\r\n     * @private\r\n     * @param {Function} arrayFunc The function to iterate over an array.\r\n     * @param {Function} eachFunc The function to iterate over a collection.\r\n     * @returns {Function} Returns the new each function.\r\n     */\r\n    function createForEach(arrayFunc, eachFunc) {\r\n      return function(collection, iteratee, thisArg) {\r\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\r\n          ? arrayFunc(collection, iteratee)\r\n          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.forIn` or `_.forInRight`.\r\n     *\r\n     * @private\r\n     * @param {Function} objectFunc The function to iterate over an object.\r\n     * @returns {Function} Returns the new each function.\r\n     */\r\n    function createForIn(objectFunc) {\r\n      return function(object, iteratee, thisArg) {\r\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\r\n          iteratee = bindCallback(iteratee, thisArg, 3);\r\n        }\r\n        return objectFunc(object, iteratee, keysIn);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.forOwn` or `_.forOwnRight`.\r\n     *\r\n     * @private\r\n     * @param {Function} objectFunc The function to iterate over an object.\r\n     * @returns {Function} Returns the new each function.\r\n     */\r\n    function createForOwn(objectFunc) {\r\n      return function(object, iteratee, thisArg) {\r\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\r\n          iteratee = bindCallback(iteratee, thisArg, 3);\r\n        }\r\n        return objectFunc(object, iteratee);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.mapKeys` or `_.mapValues`.\r\n     *\r\n     * @private\r\n     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.\r\n     * @returns {Function} Returns the new map function.\r\n     */\r\n    function createObjectMapper(isMapKeys) {\r\n      return function(object, iteratee, thisArg) {\r\n        var result = {};\r\n        iteratee = getCallback(iteratee, thisArg, 3);\r\n\r\n        baseForOwn(object, function(value, key, object) {\r\n          var mapped = iteratee(value, key, object);\r\n          key = isMapKeys ? mapped : key;\r\n          value = isMapKeys ? value : mapped;\r\n          result[key] = value;\r\n        });\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.padLeft` or `_.padRight`.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify padding from the right.\r\n     * @returns {Function} Returns the new pad function.\r\n     */\r\n    function createPadDir(fromRight) {\r\n      return function(string, length, chars) {\r\n        string = baseToString(string);\r\n        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.partial` or `_.partialRight` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} flag The partial bit flag.\r\n     * @returns {Function} Returns the new partial function.\r\n     */\r\n    function createPartial(flag) {\r\n      var partialFunc = restParam(function(func, partials) {\r\n        var holders = replaceHolders(partials, partialFunc.placeholder);\r\n        return createWrapper(func, flag, undefined, partials, holders);\r\n      });\r\n      return partialFunc;\r\n    }\r\n\r\n    /**\r\n     * Creates a function for `_.reduce` or `_.reduceRight`.\r\n     *\r\n     * @private\r\n     * @param {Function} arrayFunc The function to iterate over an array.\r\n     * @param {Function} eachFunc The function to iterate over a collection.\r\n     * @returns {Function} Returns the new each function.\r\n     */\r\n    function createReduce(arrayFunc, eachFunc) {\r\n      return function(collection, iteratee, accumulator, thisArg) {\r\n        var initFromArray = arguments.length < 3;\r\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\r\n          ? arrayFunc(collection, iteratee, accumulator, initFromArray)\r\n          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` and invokes it with optional `this`\r\n     * binding of, partial application, and currying.\r\n     *\r\n     * @private\r\n     * @param {Function|string} func The function or method name to reference.\r\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\r\n     * @param {Array} [holders] The `partials` placeholder indexes.\r\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\r\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\r\n     * @param {Array} [argPos] The argument positions of the new function.\r\n     * @param {number} [ary] The arity cap of `func`.\r\n     * @param {number} [arity] The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\r\n      var isAry = bitmask & ARY_FLAG,\r\n          isBind = bitmask & BIND_FLAG,\r\n          isBindKey = bitmask & BIND_KEY_FLAG,\r\n          isCurry = bitmask & CURRY_FLAG,\r\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\r\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\r\n          Ctor = isBindKey ? undefined : createCtorWrapper(func);\r\n\r\n      function wrapper() {\r\n        // Avoid `arguments` object use disqualifying optimizations by\r\n        // converting it to an array before providing it to other functions.\r\n        var length = arguments.length,\r\n            index = length,\r\n            args = Array(length);\r\n\r\n        while (index--) {\r\n          args[index] = arguments[index];\r\n        }\r\n        if (partials) {\r\n          args = composeArgs(args, partials, holders);\r\n        }\r\n        if (partialsRight) {\r\n          args = composeArgsRight(args, partialsRight, holdersRight);\r\n        }\r\n        if (isCurry || isCurryRight) {\r\n          var placeholder = wrapper.placeholder,\r\n              argsHolders = replaceHolders(args, placeholder);\r\n\r\n          length -= argsHolders.length;\r\n          if (length < arity) {\r\n            var newArgPos = argPos ? arrayCopy(argPos) : undefined,\r\n                newArity = nativeMax(arity - length, 0),\r\n                newsHolders = isCurry ? argsHolders : undefined,\r\n                newHoldersRight = isCurry ? undefined : argsHolders,\r\n                newPartials = isCurry ? args : undefined,\r\n                newPartialsRight = isCurry ? undefined : args;\r\n\r\n            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\r\n            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\r\n\r\n            if (!isCurryBound) {\r\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\r\n            }\r\n            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\r\n                result = createHybridWrapper.apply(undefined, newData);\r\n\r\n            if (isLaziable(func)) {\r\n              setData(result, newData);\r\n            }\r\n            result.placeholder = placeholder;\r\n            return result;\r\n          }\r\n        }\r\n        var thisBinding = isBind ? thisArg : this,\r\n            fn = isBindKey ? thisBinding[func] : func;\r\n\r\n        if (argPos) {\r\n          args = reorder(args, argPos);\r\n        }\r\n        if (isAry && ary < args.length) {\r\n          args.length = ary;\r\n        }\r\n        if (this && this !== root && this instanceof wrapper) {\r\n          fn = Ctor || createCtorWrapper(func);\r\n        }\r\n        return fn.apply(thisBinding, args);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates the padding required for `string` based on the given `length`.\r\n     * The `chars` string is truncated if the number of characters exceeds `length`.\r\n     *\r\n     * @private\r\n     * @param {string} string The string to create padding for.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the pad for `string`.\r\n     */\r\n    function createPadding(string, length, chars) {\r\n      var strLength = string.length;\r\n      length = +length;\r\n\r\n      if (strLength >= length || !nativeIsFinite(length)) {\r\n        return '';\r\n      }\r\n      var padLength = length - strLength;\r\n      chars = chars == null ? ' ' : (chars + '');\r\n      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` and invokes it with the optional `this`\r\n     * binding of `thisArg` and the `partials` prepended to those provided to\r\n     * the wrapper.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to partially apply arguments to.\r\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\r\n     * @param {*} thisArg The `this` binding of `func`.\r\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\r\n     * @returns {Function} Returns the new bound function.\r\n     */\r\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\r\n      var isBind = bitmask & BIND_FLAG,\r\n          Ctor = createCtorWrapper(func);\r\n\r\n      function wrapper() {\r\n        // Avoid `arguments` object use disqualifying optimizations by\r\n        // converting it to an array before providing it `func`.\r\n        var argsIndex = -1,\r\n            argsLength = arguments.length,\r\n            leftIndex = -1,\r\n            leftLength = partials.length,\r\n            args = Array(leftLength + argsLength);\r\n\r\n        while (++leftIndex < leftLength) {\r\n          args[leftIndex] = partials[leftIndex];\r\n        }\r\n        while (argsLength--) {\r\n          args[leftIndex++] = arguments[++argsIndex];\r\n        }\r\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\r\n        return fn.apply(isBind ? thisArg : this, args);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.ceil`, `_.floor`, or `_.round` function.\r\n     *\r\n     * @private\r\n     * @param {string} methodName The name of the `Math` method to use when rounding.\r\n     * @returns {Function} Returns the new round function.\r\n     */\r\n    function createRound(methodName) {\r\n      var func = Math[methodName];\r\n      return function(number, precision) {\r\n        precision = precision === undefined ? 0 : (+precision || 0);\r\n        if (precision) {\r\n          precision = pow(10, precision);\r\n          return func(number * precision) / precision;\r\n        }\r\n        return func(number);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\r\n     * @returns {Function} Returns the new index function.\r\n     */\r\n    function createSortedIndex(retHighest) {\r\n      return function(array, value, iteratee, thisArg) {\r\n        var callback = getCallback(iteratee);\r\n        return (iteratee == null && callback === baseCallback)\r\n          ? binaryIndex(array, value, retHighest)\r\n          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that either curries or invokes `func` with optional\r\n     * `this` binding and partially applied arguments.\r\n     *\r\n     * @private\r\n     * @param {Function|string} func The function or method name to reference.\r\n     * @param {number} bitmask The bitmask of flags.\r\n     *  The bitmask may be composed of the following flags:\r\n     *     1 - `_.bind`\r\n     *     2 - `_.bindKey`\r\n     *     4 - `_.curry` or `_.curryRight` of a bound function\r\n     *     8 - `_.curry`\r\n     *    16 - `_.curryRight`\r\n     *    32 - `_.partial`\r\n     *    64 - `_.partialRight`\r\n     *   128 - `_.rearg`\r\n     *   256 - `_.ary`\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {Array} [partials] The arguments to be partially applied.\r\n     * @param {Array} [holders] The `partials` placeholder indexes.\r\n     * @param {Array} [argPos] The argument positions of the new function.\r\n     * @param {number} [ary] The arity cap of `func`.\r\n     * @param {number} [arity] The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\r\n      var isBindKey = bitmask & BIND_KEY_FLAG;\r\n      if (!isBindKey && typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      var length = partials ? partials.length : 0;\r\n      if (!length) {\r\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\r\n        partials = holders = undefined;\r\n      }\r\n      length -= (holders ? holders.length : 0);\r\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\r\n        var partialsRight = partials,\r\n            holdersRight = holders;\r\n\r\n        partials = holders = undefined;\r\n      }\r\n      var data = isBindKey ? undefined : getData(func),\r\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\r\n\r\n      if (data) {\r\n        mergeData(newData, data);\r\n        bitmask = newData[1];\r\n        arity = newData[9];\r\n      }\r\n      newData[9] = arity == null\r\n        ? (isBindKey ? 0 : func.length)\r\n        : (nativeMax(arity - length, 0) || 0);\r\n\r\n      if (bitmask == BIND_FLAG) {\r\n        var result = createBindWrapper(newData[0], newData[2]);\r\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\r\n        result = createPartialWrapper.apply(undefined, newData);\r\n      } else {\r\n        result = createHybridWrapper.apply(undefined, newData);\r\n      }\r\n      var setter = data ? baseSetData : setData;\r\n      return setter(result, newData);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\r\n     * partial deep comparisons.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to compare.\r\n     * @param {Array} other The other array to compare.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Function} [customizer] The function to customize comparing arrays.\r\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\r\n     * @param {Array} [stackA] Tracks traversed `value` objects.\r\n     * @param {Array} [stackB] Tracks traversed `other` objects.\r\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\r\n     */\r\n    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\r\n      var index = -1,\r\n          arrLength = array.length,\r\n          othLength = other.length;\r\n\r\n      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\r\n        return false;\r\n      }\r\n      // Ignore non-index properties.\r\n      while (++index < arrLength) {\r\n        var arrValue = array[index],\r\n            othValue = other[index],\r\n            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\r\n\r\n        if (result !== undefined) {\r\n          if (result) {\r\n            continue;\r\n          }\r\n          return false;\r\n        }\r\n        // Recursively compare arrays (susceptible to call stack limits).\r\n        if (isLoose) {\r\n          if (!arraySome(other, function(othValue) {\r\n                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\r\n              })) {\r\n            return false;\r\n          }\r\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\r\n     * the same `toStringTag`.\r\n     *\r\n     * **Note:** This function only supports comparing values with tags of\r\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {string} tag The `toStringTag` of the objects to compare.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function equalByTag(object, other, tag) {\r\n      switch (tag) {\r\n        case boolTag:\r\n        case dateTag:\r\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\r\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\r\n          return +object == +other;\r\n\r\n        case errorTag:\r\n          return object.name == other.name && object.message == other.message;\r\n\r\n        case numberTag:\r\n          // Treat `NaN` vs. `NaN` as equal.\r\n          return (object != +object)\r\n            ? other != +other\r\n            : object == +other;\r\n\r\n        case regexpTag:\r\n        case stringTag:\r\n          // Coerce regexes to strings and treat strings primitives and string\r\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\r\n          return object == (other + '');\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for objects with support for\r\n     * partial deep comparisons.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Function} [customizer] The function to customize comparing values.\r\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\r\n     * @param {Array} [stackA] Tracks traversed `value` objects.\r\n     * @param {Array} [stackB] Tracks traversed `other` objects.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\r\n      var objProps = keys(object),\r\n          objLength = objProps.length,\r\n          othProps = keys(other),\r\n          othLength = othProps.length;\r\n\r\n      if (objLength != othLength && !isLoose) {\r\n        return false;\r\n      }\r\n      var index = objLength;\r\n      while (index--) {\r\n        var key = objProps[index];\r\n        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\r\n          return false;\r\n        }\r\n      }\r\n      var skipCtor = isLoose;\r\n      while (++index < objLength) {\r\n        key = objProps[index];\r\n        var objValue = object[key],\r\n            othValue = other[key],\r\n            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\r\n\r\n        // Recursively compare objects (susceptible to call stack limits).\r\n        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\r\n          return false;\r\n        }\r\n        skipCtor || (skipCtor = key == 'constructor');\r\n      }\r\n      if (!skipCtor) {\r\n        var objCtor = object.constructor,\r\n            othCtor = other.constructor;\r\n\r\n        // Non `Object` object instances with different constructors are not equal.\r\n        if (objCtor != othCtor &&\r\n            ('constructor' in object && 'constructor' in other) &&\r\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\r\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate \"callback\" function. If the `_.callback` method is\r\n     * customized this function returns the custom method, otherwise it returns\r\n     * the `baseCallback` function. If arguments are provided the chosen function\r\n     * is invoked with them and its result is returned.\r\n     *\r\n     * @private\r\n     * @returns {Function} Returns the chosen function or its result.\r\n     */\r\n    function getCallback(func, thisArg, argCount) {\r\n      var result = lodash.callback || callback;\r\n      result = result === callback ? baseCallback : result;\r\n      return argCount ? result(func, thisArg, argCount) : result;\r\n    }\r\n\r\n    /**\r\n     * Gets metadata for `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to query.\r\n     * @returns {*} Returns the metadata for `func`.\r\n     */\r\n    var getData = !metaMap ? noop : function(func) {\r\n      return metaMap.get(func);\r\n    };\r\n\r\n    /**\r\n     * Gets the name of `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to query.\r\n     * @returns {string} Returns the function name.\r\n     */\r\n    function getFuncName(func) {\r\n      var result = func.name,\r\n          array = realNames[result],\r\n          length = array ? array.length : 0;\r\n\r\n      while (length--) {\r\n        var data = array[length],\r\n            otherFunc = data.func;\r\n        if (otherFunc == null || otherFunc == func) {\r\n          return data.name;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\r\n     * customized this function returns the custom method, otherwise it returns\r\n     * the `baseIndexOf` function. If arguments are provided the chosen function\r\n     * is invoked with them and its result is returned.\r\n     *\r\n     * @private\r\n     * @returns {Function|number} Returns the chosen function or its result.\r\n     */\r\n    function getIndexOf(collection, target, fromIndex) {\r\n      var result = lodash.indexOf || indexOf;\r\n      result = result === indexOf ? baseIndexOf : result;\r\n      return collection ? result(collection, target, fromIndex) : result;\r\n    }\r\n\r\n    /**\r\n     * Gets the \"length\" property value of `object`.\r\n     *\r\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\r\n     * that affects Safari on at least iOS 8.1-8.3 ARM64.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {*} Returns the \"length\" value.\r\n     */\r\n    var getLength = baseProperty('length');\r\n\r\n    /**\r\n     * Gets the propery names, values, and compare flags of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the match data of `object`.\r\n     */\r\n    function getMatchData(object) {\r\n      var result = pairs(object),\r\n          length = result.length;\r\n\r\n      while (length--) {\r\n        result[length][2] = isStrictComparable(result[length][1]);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the native function at `key` of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {string} key The key of the method to get.\r\n     * @returns {*} Returns the function if it's native, else `undefined`.\r\n     */\r\n    function getNative(object, key) {\r\n      var value = object == null ? undefined : object[key];\r\n      return isNative(value) ? value : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\r\n     *\r\n     * @private\r\n     * @param {number} start The start of the view.\r\n     * @param {number} end The end of the view.\r\n     * @param {Array} transforms The transformations to apply to the view.\r\n     * @returns {Object} Returns an object containing the `start` and `end`\r\n     *  positions of the view.\r\n     */\r\n    function getView(start, end, transforms) {\r\n      var index = -1,\r\n          length = transforms.length;\r\n\r\n      while (++index < length) {\r\n        var data = transforms[index],\r\n            size = data.size;\r\n\r\n        switch (data.type) {\r\n          case 'drop':      start += size; break;\r\n          case 'dropRight': end -= size; break;\r\n          case 'take':      end = nativeMin(end, start + size); break;\r\n          case 'takeRight': start = nativeMax(start, end - size); break;\r\n        }\r\n      }\r\n      return { 'start': start, 'end': end };\r\n    }\r\n\r\n    /**\r\n     * Initializes an array clone.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to clone.\r\n     * @returns {Array} Returns the initialized clone.\r\n     */\r\n    function initCloneArray(array) {\r\n      var length = array.length,\r\n          result = new array.constructor(length);\r\n\r\n      // Add array properties assigned by `RegExp#exec`.\r\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\r\n        result.index = array.index;\r\n        result.input = array.input;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Initializes an object clone.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to clone.\r\n     * @returns {Object} Returns the initialized clone.\r\n     */\r\n    function initCloneObject(object) {\r\n      var Ctor = object.constructor;\r\n      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\r\n        Ctor = Object;\r\n      }\r\n      return new Ctor;\r\n    }\r\n\r\n    /**\r\n     * Initializes an object clone based on its `toStringTag`.\r\n     *\r\n     * **Note:** This function only supports cloning values with tags of\r\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to clone.\r\n     * @param {string} tag The `toStringTag` of the object to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @returns {Object} Returns the initialized clone.\r\n     */\r\n    function initCloneByTag(object, tag, isDeep) {\r\n      var Ctor = object.constructor;\r\n      switch (tag) {\r\n        case arrayBufferTag:\r\n          return bufferClone(object);\r\n\r\n        case boolTag:\r\n        case dateTag:\r\n          return new Ctor(+object);\r\n\r\n        case float32Tag: case float64Tag:\r\n        case int8Tag: case int16Tag: case int32Tag:\r\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\r\n          var buffer = object.buffer;\r\n          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\r\n\r\n        case numberTag:\r\n        case stringTag:\r\n          return new Ctor(object);\r\n\r\n        case regexpTag:\r\n          var result = new Ctor(object.source, reFlags.exec(object));\r\n          result.lastIndex = object.lastIndex;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Invokes the method at `path` on `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the method to invoke.\r\n     * @param {Array} args The arguments to invoke the method with.\r\n     * @returns {*} Returns the result of the invoked method.\r\n     */\r\n    function invokePath(object, path, args) {\r\n      if (object != null && !isKey(path, object)) {\r\n        path = toPath(path);\r\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n        path = last(path);\r\n      }\r\n      var func = object == null ? object : object[path];\r\n      return func == null ? undefined : func.apply(object, args);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is array-like.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n     */\r\n    function isArrayLike(value) {\r\n      return value != null && isLength(getLength(value));\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a valid array-like index.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n     */\r\n    function isIndex(value, length) {\r\n      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\r\n      length = length == null ? MAX_SAFE_INTEGER : length;\r\n      return value > -1 && value % 1 == 0 && value < length;\r\n    }\r\n\r\n    /**\r\n     * Checks if the provided arguments are from an iteratee call.\r\n     *\r\n     * @private\r\n     * @param {*} value The potential iteratee value argument.\r\n     * @param {*} index The potential iteratee index or key argument.\r\n     * @param {*} object The potential iteratee object argument.\r\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\r\n     */\r\n    function isIterateeCall(value, index, object) {\r\n      if (!isObject(object)) {\r\n        return false;\r\n      }\r\n      var type = typeof index;\r\n      if (type == 'number'\r\n          ? (isArrayLike(object) && isIndex(index, object.length))\r\n          : (type == 'string' && index in object)) {\r\n        var other = object[index];\r\n        return value === value ? (value === other) : (other !== other);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a property name and not a property path.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @param {Object} [object] The object to query keys on.\r\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n     */\r\n    function isKey(value, object) {\r\n      var type = typeof value;\r\n      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\r\n        return true;\r\n      }\r\n      if (isArray(value)) {\r\n        return false;\r\n      }\r\n      var result = !reIsDeepProp.test(value);\r\n      return result || (object != null && value in toObject(object));\r\n    }\r\n\r\n    /**\r\n     * Checks if `func` has a lazy counterpart.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to check.\r\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\r\n     */\r\n    function isLaziable(func) {\r\n      var funcName = getFuncName(func);\r\n      if (!(funcName in LazyWrapper.prototype)) {\r\n        return false;\r\n      }\r\n      var other = lodash[funcName];\r\n      if (func === other) {\r\n        return true;\r\n      }\r\n      var data = getData(other);\r\n      return !!data && func === data[0];\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a valid array-like length.\r\n     *\r\n     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n     */\r\n    function isLength(value) {\r\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\r\n     *  equality comparisons, else `false`.\r\n     */\r\n    function isStrictComparable(value) {\r\n      return value === value && !isObject(value);\r\n    }\r\n\r\n    /**\r\n     * Merges the function metadata of `source` into `data`.\r\n     *\r\n     * Merging metadata reduces the number of wrappers required to invoke a function.\r\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\r\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\r\n     * augment function arguments, making the order in which they are executed important,\r\n     * preventing the merging of metadata. However, we make an exception for a safe\r\n     * common case where curried functions have `_.ary` and or `_.rearg` applied.\r\n     *\r\n     * @private\r\n     * @param {Array} data The destination metadata.\r\n     * @param {Array} source The source metadata.\r\n     * @returns {Array} Returns `data`.\r\n     */\r\n    function mergeData(data, source) {\r\n      var bitmask = data[1],\r\n          srcBitmask = source[1],\r\n          newBitmask = bitmask | srcBitmask,\r\n          isCommon = newBitmask < ARY_FLAG;\r\n\r\n      var isCombo =\r\n        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\r\n        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\r\n        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\r\n\r\n      // Exit early if metadata can't be merged.\r\n      if (!(isCommon || isCombo)) {\r\n        return data;\r\n      }\r\n      // Use source `thisArg` if available.\r\n      if (srcBitmask & BIND_FLAG) {\r\n        data[2] = source[2];\r\n        // Set when currying a bound function.\r\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\r\n      }\r\n      // Compose partial arguments.\r\n      var value = source[3];\r\n      if (value) {\r\n        var partials = data[3];\r\n        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\r\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\r\n      }\r\n      // Compose partial right arguments.\r\n      value = source[5];\r\n      if (value) {\r\n        partials = data[5];\r\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\r\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\r\n      }\r\n      // Use source `argPos` if available.\r\n      value = source[7];\r\n      if (value) {\r\n        data[7] = arrayCopy(value);\r\n      }\r\n      // Use source `ary` if it's smaller.\r\n      if (srcBitmask & ARY_FLAG) {\r\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\r\n      }\r\n      // Use source `arity` if one is not provided.\r\n      if (data[9] == null) {\r\n        data[9] = source[9];\r\n      }\r\n      // Use source `func` and merge bitmasks.\r\n      data[0] = source[0];\r\n      data[1] = newBitmask;\r\n\r\n      return data;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\r\n     *\r\n     * @private\r\n     * @param {*} objectValue The destination object property value.\r\n     * @param {*} sourceValue The source object property value.\r\n     * @returns {*} Returns the value to assign to the destination object.\r\n     */\r\n    function mergeDefaults(objectValue, sourceValue) {\r\n      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.pick` which picks `object` properties specified\r\n     * by `props`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The source object.\r\n     * @param {string[]} props The property names to pick.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    function pickByArray(object, props) {\r\n      object = toObject(object);\r\n\r\n      var index = -1,\r\n          length = props.length,\r\n          result = {};\r\n\r\n      while (++index < length) {\r\n        var key = props[index];\r\n        if (key in object) {\r\n          result[key] = object[key];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.pick` which picks `object` properties `predicate`\r\n     * returns truthy for.\r\n     *\r\n     * @private\r\n     * @param {Object} object The source object.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    function pickByCallback(object, predicate) {\r\n      var result = {};\r\n      baseForIn(object, function(value, key, object) {\r\n        if (predicate(value, key, object)) {\r\n          result[key] = value;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Reorder `array` according to the specified indexes where the element at\r\n     * the first index is assigned as the first element, the element at\r\n     * the second index is assigned as the second element, and so on.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to reorder.\r\n     * @param {Array} indexes The arranged array indexes.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function reorder(array, indexes) {\r\n      var arrLength = array.length,\r\n          length = nativeMin(indexes.length, arrLength),\r\n          oldArray = arrayCopy(array);\r\n\r\n      while (length--) {\r\n        var index = indexes[length];\r\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * Sets metadata for `func`.\r\n     *\r\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\r\n     * period of time, it will trip its breaker and transition to an identity function\r\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\r\n     * for more details.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to associate metadata with.\r\n     * @param {*} data The metadata.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var setData = (function() {\r\n      var count = 0,\r\n          lastCalled = 0;\r\n\r\n      return function(key, value) {\r\n        var stamp = now(),\r\n            remaining = HOT_SPAN - (stamp - lastCalled);\r\n\r\n        lastCalled = stamp;\r\n        if (remaining > 0) {\r\n          if (++count >= HOT_COUNT) {\r\n            return key;\r\n          }\r\n        } else {\r\n          count = 0;\r\n        }\r\n        return baseSetData(key, value);\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * A fallback implementation of `Object.keys` which creates an array of the\r\n     * own enumerable property names of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     */\r\n    function shimKeys(object) {\r\n      var props = keysIn(object),\r\n          propsLength = props.length,\r\n          length = propsLength && object.length;\r\n\r\n      var allowIndexes = !!length && isLength(length) &&\r\n        (isArray(object) || isArguments(object));\r\n\r\n      var index = -1,\r\n          result = [];\r\n\r\n      while (++index < propsLength) {\r\n        var key = props[index];\r\n        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an array-like object if it's not one.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to process.\r\n     * @returns {Array|Object} Returns the array-like object.\r\n     */\r\n    function toIterable(value) {\r\n      if (value == null) {\r\n        return [];\r\n      }\r\n      if (!isArrayLike(value)) {\r\n        return values(value);\r\n      }\r\n      return isObject(value) ? value : Object(value);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an object if it's not one.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to process.\r\n     * @returns {Object} Returns the object.\r\n     */\r\n    function toObject(value) {\r\n      return isObject(value) ? value : Object(value);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to property path array if it's not one.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to process.\r\n     * @returns {Array} Returns the property path array.\r\n     */\r\n    function toPath(value) {\r\n      if (isArray(value)) {\r\n        return value;\r\n      }\r\n      var result = [];\r\n      baseToString(value).replace(rePropName, function(match, number, quote, string) {\r\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `wrapper`.\r\n     *\r\n     * @private\r\n     * @param {Object} wrapper The wrapper to clone.\r\n     * @returns {Object} Returns the cloned wrapper.\r\n     */\r\n    function wrapperClone(wrapper) {\r\n      return wrapper instanceof LazyWrapper\r\n        ? wrapper.clone()\r\n        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an array of elements split into groups the length of `size`.\r\n     * If `collection` can't be split evenly, the final chunk will be the remaining\r\n     * elements.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to process.\r\n     * @param {number} [size=1] The length of each chunk.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the new array containing chunks.\r\n     * @example\r\n     *\r\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\r\n     * // => [['a', 'b'], ['c', 'd']]\r\n     *\r\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\r\n     * // => [['a', 'b', 'c'], ['d']]\r\n     */\r\n    function chunk(array, size, guard) {\r\n      if (guard ? isIterateeCall(array, size, guard) : size == null) {\r\n        size = 1;\r\n      } else {\r\n        size = nativeMax(nativeFloor(size) || 1, 1);\r\n      }\r\n      var index = 0,\r\n          length = array ? array.length : 0,\r\n          resIndex = -1,\r\n          result = Array(nativeCeil(length / size));\r\n\r\n      while (index < length) {\r\n        result[++resIndex] = baseSlice(array, index, (index += size));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array with all falsey values removed. The values `false`, `null`,\r\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to compact.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.compact([0, 1, false, 2, '', 3]);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function compact(array) {\r\n      var index = -1,\r\n          length = array ? array.length : 0,\r\n          resIndex = -1,\r\n          result = [];\r\n\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (value) {\r\n          result[++resIndex] = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unique `array` values not included in the other\r\n     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {...Array} [values] The arrays of values to exclude.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.difference([1, 2, 3], [4, 2]);\r\n     * // => [1, 3]\r\n     */\r\n    var difference = restParam(function(array, values) {\r\n      return (isObjectLike(array) && isArrayLike(array))\r\n        ? baseDifference(array, baseFlatten(values, false, true))\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to drop.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.drop([1, 2, 3]);\r\n     * // => [2, 3]\r\n     *\r\n     * _.drop([1, 2, 3], 2);\r\n     * // => [3]\r\n     *\r\n     * _.drop([1, 2, 3], 5);\r\n     * // => []\r\n     *\r\n     * _.drop([1, 2, 3], 0);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function drop(array, n, guard) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\r\n        n = 1;\r\n      }\r\n      return baseSlice(array, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements dropped from the end.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to drop.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.dropRight([1, 2, 3]);\r\n     * // => [1, 2]\r\n     *\r\n     * _.dropRight([1, 2, 3], 2);\r\n     * // => [1]\r\n     *\r\n     * _.dropRight([1, 2, 3], 5);\r\n     * // => []\r\n     *\r\n     * _.dropRight([1, 2, 3], 0);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function dropRight(array, n, guard) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\r\n        n = 1;\r\n      }\r\n      n = length - (+n || 0);\r\n      return baseSlice(array, 0, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` excluding elements dropped from the end.\r\n     * Elements are dropped until `predicate` returns falsey. The predicate is\r\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that match the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.dropRightWhile([1, 2, 3], function(n) {\r\n     *   return n > 1;\r\n     * });\r\n     * // => [1]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\r\n     * // => ['barney', 'fred']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\r\n     * // => ['barney']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\r\n     * // => ['barney', 'fred', 'pebbles']\r\n     */\r\n    function dropRightWhile(array, predicate, thisArg) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` excluding elements dropped from the beginning.\r\n     * Elements are dropped until `predicate` returns falsey. The predicate is\r\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.dropWhile([1, 2, 3], function(n) {\r\n     *   return n < 3;\r\n     * });\r\n     * // => [3]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');\r\n     * // => ['fred', 'pebbles']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.dropWhile(users, 'active', false), 'user');\r\n     * // => ['pebbles']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.dropWhile(users, 'active'), 'user');\r\n     * // => ['barney', 'fred', 'pebbles']\r\n     */\r\n    function dropWhile(array, predicate, thisArg) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Fills elements of `array` with `value` from `start` up to, but not\r\n     * including, `end`.\r\n     *\r\n     * **Note:** This method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to fill.\r\n     * @param {*} value The value to fill `array` with.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3];\r\n     *\r\n     * _.fill(array, 'a');\r\n     * console.log(array);\r\n     * // => ['a', 'a', 'a']\r\n     *\r\n     * _.fill(Array(3), 2);\r\n     * // => [2, 2, 2]\r\n     *\r\n     * _.fill([4, 6, 8], '*', 1, 2);\r\n     * // => [4, '*', 8]\r\n     */\r\n    function fill(array, value, start, end) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\r\n        start = 0;\r\n        end = length;\r\n      }\r\n      return baseFill(array, value, start, end);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.find` except that it returns the index of the first\r\n     * element `predicate` returns truthy for instead of the element itself.\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {number} Returns the index of the found element, else `-1`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * _.findIndex(users, function(chr) {\r\n     *   return chr.user == 'barney';\r\n     * });\r\n     * // => 0\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\r\n     * // => 1\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.findIndex(users, 'active', false);\r\n     * // => 0\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.findIndex(users, 'active');\r\n     * // => 2\r\n     */\r\n    var findIndex = createFindIndex();\r\n\r\n    /**\r\n     * This method is like `_.findIndex` except that it iterates over elements\r\n     * of `collection` from right to left.\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {number} Returns the index of the found element, else `-1`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * _.findLastIndex(users, function(chr) {\r\n     *   return chr.user == 'pebbles';\r\n     * });\r\n     * // => 2\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\r\n     * // => 0\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.findLastIndex(users, 'active', false);\r\n     * // => 2\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.findLastIndex(users, 'active');\r\n     * // => 0\r\n     */\r\n    var findLastIndex = createFindIndex(true);\r\n\r\n    /**\r\n     * Gets the first element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias head\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {*} Returns the first element of `array`.\r\n     * @example\r\n     *\r\n     * _.first([1, 2, 3]);\r\n     * // => 1\r\n     *\r\n     * _.first([]);\r\n     * // => undefined\r\n     */\r\n    function first(array) {\r\n      return array ? array[0] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Flattens a nested array. If `isDeep` is `true` the array is recursively\r\n     * flattened, otherwise it is only flattened a single level.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to flatten.\r\n     * @param {boolean} [isDeep] Specify a deep flatten.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * _.flatten([1, [2, 3, [4]]]);\r\n     * // => [1, 2, 3, [4]]\r\n     *\r\n     * // using `isDeep`\r\n     * _.flatten([1, [2, 3, [4]]], true);\r\n     * // => [1, 2, 3, 4]\r\n     */\r\n    function flatten(array, isDeep, guard) {\r\n      var length = array ? array.length : 0;\r\n      if (guard && isIterateeCall(array, isDeep, guard)) {\r\n        isDeep = false;\r\n      }\r\n      return length ? baseFlatten(array, isDeep) : [];\r\n    }\r\n\r\n    /**\r\n     * Recursively flattens a nested array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to recursively flatten.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * _.flattenDeep([1, [2, 3, [4]]]);\r\n     * // => [1, 2, 3, 4]\r\n     */\r\n    function flattenDeep(array) {\r\n      var length = array ? array.length : 0;\r\n      return length ? baseFlatten(array, true) : [];\r\n    }\r\n\r\n    /**\r\n     * Gets the index at which the first occurrence of `value` is found in `array`\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\r\n     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\r\n     * performs a faster binary search.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to search.\r\n     * @param {*} value The value to search for.\r\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\r\n     *  to perform a binary search on a sorted array.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.indexOf([1, 2, 1, 2], 2);\r\n     * // => 1\r\n     *\r\n     * // using `fromIndex`\r\n     * _.indexOf([1, 2, 1, 2], 2, 2);\r\n     * // => 3\r\n     *\r\n     * // performing a binary search\r\n     * _.indexOf([1, 1, 2, 2], 2, true);\r\n     * // => 2\r\n     */\r\n    function indexOf(array, value, fromIndex) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      if (typeof fromIndex == 'number') {\r\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\r\n      } else if (fromIndex) {\r\n        var index = binaryIndex(array, value);\r\n        if (index < length &&\r\n            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {\r\n          return index;\r\n        }\r\n        return -1;\r\n      }\r\n      return baseIndexOf(array, value, fromIndex || 0);\r\n    }\r\n\r\n    /**\r\n     * Gets all but the last element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.initial([1, 2, 3]);\r\n     * // => [1, 2]\r\n     */\r\n    function initial(array) {\r\n      return dropRight(array, 1);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unique values that are included in all of the provided\r\n     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of shared values.\r\n     * @example\r\n     * _.intersection([1, 2], [4, 2], [2, 1]);\r\n     * // => [2]\r\n     */\r\n    var intersection = restParam(function(arrays) {\r\n      var othLength = arrays.length,\r\n          othIndex = othLength,\r\n          caches = Array(length),\r\n          indexOf = getIndexOf(),\r\n          isCommon = indexOf == baseIndexOf,\r\n          result = [];\r\n\r\n      while (othIndex--) {\r\n        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];\r\n        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;\r\n      }\r\n      var array = arrays[0],\r\n          index = -1,\r\n          length = array ? array.length : 0,\r\n          seen = caches[0];\r\n\r\n      outer:\r\n      while (++index < length) {\r\n        value = array[index];\r\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\r\n          var othIndex = othLength;\r\n          while (--othIndex) {\r\n            var cache = caches[othIndex];\r\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {\r\n              continue outer;\r\n            }\r\n          }\r\n          if (seen) {\r\n            seen.push(value);\r\n          }\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Gets the last element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {*} Returns the last element of `array`.\r\n     * @example\r\n     *\r\n     * _.last([1, 2, 3]);\r\n     * // => 3\r\n     */\r\n    function last(array) {\r\n      var length = array ? array.length : 0;\r\n      return length ? array[length - 1] : undefined;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.indexOf` except that it iterates over elements of\r\n     * `array` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to search.\r\n     * @param {*} value The value to search for.\r\n     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\r\n     *  or `true` to perform a binary search on a sorted array.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.lastIndexOf([1, 2, 1, 2], 2);\r\n     * // => 3\r\n     *\r\n     * // using `fromIndex`\r\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\r\n     * // => 1\r\n     *\r\n     * // performing a binary search\r\n     * _.lastIndexOf([1, 1, 2, 2], 2, true);\r\n     * // => 3\r\n     */\r\n    function lastIndexOf(array, value, fromIndex) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      var index = length;\r\n      if (typeof fromIndex == 'number') {\r\n        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\r\n      } else if (fromIndex) {\r\n        index = binaryIndex(array, value, true) - 1;\r\n        var other = array[index];\r\n        if (value === value ? (value === other) : (other !== other)) {\r\n          return index;\r\n        }\r\n        return -1;\r\n      }\r\n      if (value !== value) {\r\n        return indexOfNaN(array, index, true);\r\n      }\r\n      while (index--) {\r\n        if (array[index] === value) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * Removes all provided values from `array` using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * **Note:** Unlike `_.without`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {...*} [values] The values to remove.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3, 1, 2, 3];\r\n     *\r\n     * _.pull(array, 2, 3);\r\n     * console.log(array);\r\n     * // => [1, 1]\r\n     */\r\n    function pull() {\r\n      var args = arguments,\r\n          array = args[0];\r\n\r\n      if (!(array && array.length)) {\r\n        return array;\r\n      }\r\n      var index = 0,\r\n          indexOf = getIndexOf(),\r\n          length = args.length;\r\n\r\n      while (++index < length) {\r\n        var fromIndex = 0,\r\n            value = args[index];\r\n\r\n        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\r\n          splice.call(array, fromIndex, 1);\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * Removes elements from `array` corresponding to the given indexes and returns\r\n     * an array of the removed elements. Indexes may be specified as an array of\r\n     * indexes or as individual arguments.\r\n     *\r\n     * **Note:** Unlike `_.at`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\r\n     *  specified as individual indexes or arrays of indexes.\r\n     * @returns {Array} Returns the new array of removed elements.\r\n     * @example\r\n     *\r\n     * var array = [5, 10, 15, 20];\r\n     * var evens = _.pullAt(array, 1, 3);\r\n     *\r\n     * console.log(array);\r\n     * // => [5, 15]\r\n     *\r\n     * console.log(evens);\r\n     * // => [10, 20]\r\n     */\r\n    var pullAt = restParam(function(array, indexes) {\r\n      indexes = baseFlatten(indexes);\r\n\r\n      var result = baseAt(array, indexes);\r\n      basePullAt(array, indexes.sort(baseCompareAscending));\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Removes all elements from `array` that `predicate` returns truthy for\r\n     * and returns an array of the removed elements. The predicate is bound to\r\n     * `thisArg` and invoked with three arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the new array of removed elements.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3, 4];\r\n     * var evens = _.remove(array, function(n) {\r\n     *   return n % 2 == 0;\r\n     * });\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 3]\r\n     *\r\n     * console.log(evens);\r\n     * // => [2, 4]\r\n     */\r\n    function remove(array, predicate, thisArg) {\r\n      var result = [];\r\n      if (!(array && array.length)) {\r\n        return result;\r\n      }\r\n      var index = -1,\r\n          indexes = [],\r\n          length = array.length;\r\n\r\n      predicate = getCallback(predicate, thisArg, 3);\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (predicate(value, index, array)) {\r\n          result.push(value);\r\n          indexes.push(index);\r\n        }\r\n      }\r\n      basePullAt(array, indexes);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets all but the first element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias tail\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.rest([1, 2, 3]);\r\n     * // => [2, 3]\r\n     */\r\n    function rest(array) {\r\n      return drop(array, 1);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\r\n     *\r\n     * **Note:** This method is used instead of `Array#slice` to support node\r\n     * lists in IE < 9 and to ensure dense arrays are returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to slice.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function slice(array, start, end) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\r\n        start = 0;\r\n        end = length;\r\n      }\r\n      return baseSlice(array, start, end);\r\n    }\r\n\r\n    /**\r\n     * Uses a binary search to determine the lowest index at which `value` should\r\n     * be inserted into `array` in order to maintain its sort order. If an iteratee\r\n     * function is provided it is invoked for `value` and each element of `array`\r\n     * to compute their sort ranking. The iteratee is bound to `thisArg` and\r\n     * invoked with one argument; (value).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * _.sortedIndex([30, 50], 40);\r\n     * // => 1\r\n     *\r\n     * _.sortedIndex([4, 4, 5, 5], 5);\r\n     * // => 2\r\n     *\r\n     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\r\n     *\r\n     * // using an iteratee function\r\n     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\r\n     *   return this.data[word];\r\n     * }, dict);\r\n     * // => 1\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\r\n     * // => 1\r\n     */\r\n    var sortedIndex = createSortedIndex();\r\n\r\n    /**\r\n     * This method is like `_.sortedIndex` except that it returns the highest\r\n     * index at which `value` should be inserted into `array` in order to\r\n     * maintain its sort order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * _.sortedLastIndex([4, 4, 5, 5], 5);\r\n     * // => 4\r\n     */\r\n    var sortedLastIndex = createSortedIndex(true);\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements taken from the beginning.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to take.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.take([1, 2, 3]);\r\n     * // => [1]\r\n     *\r\n     * _.take([1, 2, 3], 2);\r\n     * // => [1, 2]\r\n     *\r\n     * _.take([1, 2, 3], 5);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * _.take([1, 2, 3], 0);\r\n     * // => []\r\n     */\r\n    function take(array, n, guard) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\r\n        n = 1;\r\n      }\r\n      return baseSlice(array, 0, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements taken from the end.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to take.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.takeRight([1, 2, 3]);\r\n     * // => [3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 2);\r\n     * // => [2, 3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 5);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 0);\r\n     * // => []\r\n     */\r\n    function takeRight(array, n, guard) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\r\n        n = 1;\r\n      }\r\n      n = length - (+n || 0);\r\n      return baseSlice(array, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with elements taken from the end. Elements are\r\n     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\r\n     * and invoked with three arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.takeRightWhile([1, 2, 3], function(n) {\r\n     *   return n > 1;\r\n     * });\r\n     * // => [2, 3]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\r\n     * // => ['pebbles']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\r\n     * // => ['fred', 'pebbles']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\r\n     * // => []\r\n     */\r\n    function takeRightWhile(array, predicate, thisArg) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with elements taken from the beginning. Elements\r\n     * are taken until `predicate` returns falsey. The predicate is bound to\r\n     * `thisArg` and invoked with three arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.takeWhile([1, 2, 3], function(n) {\r\n     *   return n < 3;\r\n     * });\r\n     * // => [1, 2]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false},\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');\r\n     * // => ['barney']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.takeWhile(users, 'active', false), 'user');\r\n     * // => ['barney', 'fred']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.takeWhile(users, 'active'), 'user');\r\n     * // => []\r\n     */\r\n    function takeWhile(array, predicate, thisArg) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getCallback(predicate, thisArg, 3))\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unique values, in order, from all of the provided arrays\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of combined values.\r\n     * @example\r\n     *\r\n     * _.union([1, 2], [4, 2], [2, 1]);\r\n     * // => [1, 2, 4]\r\n     */\r\n    var union = restParam(function(arrays) {\r\n      return baseUniq(baseFlatten(arrays, false, true));\r\n    });\r\n\r\n    /**\r\n     * Creates a duplicate-free version of an array, using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons, in which only the first occurence of each element\r\n     * is kept. Providing `true` for `isSorted` performs a faster search algorithm\r\n     * for sorted arrays. If an iteratee function is provided it is invoked for\r\n     * each element in the array to generate the criterion by which uniqueness\r\n     * is computed. The `iteratee` is bound to `thisArg` and invoked with three\r\n     * arguments: (value, index, array).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias unique\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {boolean} [isSorted] Specify the array is sorted.\r\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the new duplicate-value-free array.\r\n     * @example\r\n     *\r\n     * _.uniq([2, 1, 2]);\r\n     * // => [2, 1]\r\n     *\r\n     * // using `isSorted`\r\n     * _.uniq([1, 1, 2], true);\r\n     * // => [1, 2]\r\n     *\r\n     * // using an iteratee function\r\n     * _.uniq([1, 2.5, 1.5, 2], function(n) {\r\n     *   return this.floor(n);\r\n     * }, Math);\r\n     * // => [1, 2.5]\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\r\n     * // => [{ 'x': 1 }, { 'x': 2 }]\r\n     */\r\n    function uniq(array, isSorted, iteratee, thisArg) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (isSorted != null && typeof isSorted != 'boolean') {\r\n        thisArg = iteratee;\r\n        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\r\n        isSorted = false;\r\n      }\r\n      var callback = getCallback();\r\n      if (!(iteratee == null && callback === baseCallback)) {\r\n        iteratee = callback(iteratee, thisArg, 3);\r\n      }\r\n      return (isSorted && getIndexOf() == baseIndexOf)\r\n        ? sortedUniq(array, iteratee)\r\n        : baseUniq(array, iteratee);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.zip` except that it accepts an array of grouped\r\n     * elements and creates an array regrouping the elements to their pre-zip\r\n     * configuration.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array of grouped elements to process.\r\n     * @returns {Array} Returns the new array of regrouped elements.\r\n     * @example\r\n     *\r\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\r\n     * // => [['fred', 30, true], ['barney', 40, false]]\r\n     *\r\n     * _.unzip(zipped);\r\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\r\n     */\r\n    function unzip(array) {\r\n      if (!(array && array.length)) {\r\n        return [];\r\n      }\r\n      var index = -1,\r\n          length = 0;\r\n\r\n      array = arrayFilter(array, function(group) {\r\n        if (isArrayLike(group)) {\r\n          length = nativeMax(group.length, length);\r\n          return true;\r\n        }\r\n      });\r\n      var result = Array(length);\r\n      while (++index < length) {\r\n        result[index] = arrayMap(array, baseProperty(index));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.unzip` except that it accepts an iteratee to specify\r\n     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`\r\n     * and invoked with four arguments: (accumulator, value, index, group).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array of grouped elements to process.\r\n     * @param {Function} [iteratee] The function to combine regrouped values.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the new array of regrouped elements.\r\n     * @example\r\n     *\r\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\r\n     * // => [[1, 10, 100], [2, 20, 200]]\r\n     *\r\n     * _.unzipWith(zipped, _.add);\r\n     * // => [3, 30, 300]\r\n     */\r\n    function unzipWith(array, iteratee, thisArg) {\r\n      var length = array ? array.length : 0;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      var result = unzip(array);\r\n      if (iteratee == null) {\r\n        return result;\r\n      }\r\n      iteratee = bindCallback(iteratee, thisArg, 4);\r\n      return arrayMap(result, function(group) {\r\n        return arrayReduce(group, iteratee, undefined, true);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates an array excluding all provided values using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {Array} array The array to filter.\r\n     * @param {...*} [values] The values to exclude.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.without([1, 2, 1, 3], 1, 2);\r\n     * // => [3]\r\n     */\r\n    var without = restParam(function(array, values) {\r\n      return isArrayLike(array)\r\n        ? baseDifference(array, values)\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\r\n     * of the provided arrays.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of values.\r\n     * @example\r\n     *\r\n     * _.xor([1, 2], [4, 2]);\r\n     * // => [1, 4]\r\n     */\r\n    function xor() {\r\n      var index = -1,\r\n          length = arguments.length;\r\n\r\n      while (++index < length) {\r\n        var array = arguments[index];\r\n        if (isArrayLike(array)) {\r\n          var result = result\r\n            ? arrayPush(baseDifference(result, array), baseDifference(array, result))\r\n            : array;\r\n        }\r\n      }\r\n      return result ? baseUniq(result) : [];\r\n    }\r\n\r\n    /**\r\n     * Creates an array of grouped elements, the first of which contains the first\r\n     * elements of the given arrays, the second of which contains the second elements\r\n     * of the given arrays, and so on.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to process.\r\n     * @returns {Array} Returns the new array of grouped elements.\r\n     * @example\r\n     *\r\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\r\n     * // => [['fred', 30, true], ['barney', 40, false]]\r\n     */\r\n    var zip = restParam(unzip);\r\n\r\n    /**\r\n     * The inverse of `_.pairs`; this method returns an object composed from arrays\r\n     * of property names and values. Provide either a single two dimensional array,\r\n     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names\r\n     * and one of corresponding values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias object\r\n     * @category Array\r\n     * @param {Array} props The property names.\r\n     * @param {Array} [values=[]] The property values.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * _.zipObject([['fred', 30], ['barney', 40]]);\r\n     * // => { 'fred': 30, 'barney': 40 }\r\n     *\r\n     * _.zipObject(['fred', 'barney'], [30, 40]);\r\n     * // => { 'fred': 30, 'barney': 40 }\r\n     */\r\n    function zipObject(props, values) {\r\n      var index = -1,\r\n          length = props ? props.length : 0,\r\n          result = {};\r\n\r\n      if (length && !values && !isArray(props[0])) {\r\n        values = [];\r\n      }\r\n      while (++index < length) {\r\n        var key = props[index];\r\n        if (values) {\r\n          result[key] = values[index];\r\n        } else if (key) {\r\n          result[key[0]] = key[1];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.zip` except that it accepts an iteratee to specify\r\n     * how grouped values should be combined. The `iteratee` is bound to `thisArg`\r\n     * and invoked with four arguments: (accumulator, value, index, group).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to process.\r\n     * @param {Function} [iteratee] The function to combine grouped values.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the new array of grouped elements.\r\n     * @example\r\n     *\r\n     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);\r\n     * // => [111, 222]\r\n     */\r\n    var zipWith = restParam(function(arrays) {\r\n      var length = arrays.length,\r\n          iteratee = length > 2 ? arrays[length - 2] : undefined,\r\n          thisArg = length > 1 ? arrays[length - 1] : undefined;\r\n\r\n      if (length > 2 && typeof iteratee == 'function') {\r\n        length -= 2;\r\n      } else {\r\n        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;\r\n        thisArg = undefined;\r\n      }\r\n      arrays.length = length;\r\n      return unzipWith(arrays, iteratee, thisArg);\r\n    });\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a `lodash` object that wraps `value` with explicit method\r\n     * chaining enabled.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @param {*} value The value to wrap.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36 },\r\n     *   { 'user': 'fred',    'age': 40 },\r\n     *   { 'user': 'pebbles', 'age': 1 }\r\n     * ];\r\n     *\r\n     * var youngest = _.chain(users)\r\n     *   .sortBy('age')\r\n     *   .map(function(chr) {\r\n     *     return chr.user + ' is ' + chr.age;\r\n     *   })\r\n     *   .first()\r\n     *   .value();\r\n     * // => 'pebbles is 1'\r\n     */\r\n    function chain(value) {\r\n      var result = lodash(value);\r\n      result.__chain__ = true;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method invokes `interceptor` and returns `value`. The interceptor is\r\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\r\n     * this method is to \"tap into\" a method chain in order to perform operations\r\n     * on intermediate results within the chain.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @param {*} value The value to provide to `interceptor`.\r\n     * @param {Function} interceptor The function to invoke.\r\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\r\n     * @returns {*} Returns `value`.\r\n     * @example\r\n     *\r\n     * _([1, 2, 3])\r\n     *  .tap(function(array) {\r\n     *    array.pop();\r\n     *  })\r\n     *  .reverse()\r\n     *  .value();\r\n     * // => [2, 1]\r\n     */\r\n    function tap(value, interceptor, thisArg) {\r\n      interceptor.call(thisArg, value);\r\n      return value;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @param {*} value The value to provide to `interceptor`.\r\n     * @param {Function} interceptor The function to invoke.\r\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\r\n     * @returns {*} Returns the result of `interceptor`.\r\n     * @example\r\n     *\r\n     * _('  abc  ')\r\n     *  .chain()\r\n     *  .trim()\r\n     *  .thru(function(value) {\r\n     *    return [value];\r\n     *  })\r\n     *  .value();\r\n     * // => ['abc']\r\n     */\r\n    function thru(value, interceptor, thisArg) {\r\n      return interceptor.call(thisArg, value);\r\n    }\r\n\r\n    /**\r\n     * Enables explicit method chaining on the wrapper object.\r\n     *\r\n     * @name chain\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * // without explicit chaining\r\n     * _(users).first();\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     *\r\n     * // with explicit chaining\r\n     * _(users).chain()\r\n     *   .first()\r\n     *   .pick('user')\r\n     *   .value();\r\n     * // => { 'user': 'barney' }\r\n     */\r\n    function wrapperChain() {\r\n      return chain(this);\r\n    }\r\n\r\n    /**\r\n     * Executes the chained sequence and returns the wrapped result.\r\n     *\r\n     * @name commit\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var array = [1, 2];\r\n     * var wrapped = _(array).push(3);\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 2]\r\n     *\r\n     * wrapped = wrapped.commit();\r\n     * console.log(array);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * wrapped.last();\r\n     * // => 3\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function wrapperCommit() {\r\n      return new LodashWrapper(this.value(), this.__chain__);\r\n    }\r\n\r\n    /**\r\n     * Creates a new array joining a wrapped array with any additional arrays\r\n     * and/or values.\r\n     *\r\n     * @name concat\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @param {...*} [values] The values to concatenate.\r\n     * @returns {Array} Returns the new concatenated array.\r\n     * @example\r\n     *\r\n     * var array = [1];\r\n     * var wrapped = _(array).concat(2, [3], [[4]]);\r\n     *\r\n     * console.log(wrapped.value());\r\n     * // => [1, 2, 3, [4]]\r\n     *\r\n     * console.log(array);\r\n     * // => [1]\r\n     */\r\n    var wrapperConcat = restParam(function(values) {\r\n      values = baseFlatten(values);\r\n      return this.thru(function(array) {\r\n        return arrayConcat(isArray(array) ? array : [toObject(array)], values);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\r\n     *\r\n     * @name plant\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var array = [1, 2];\r\n     * var wrapped = _(array).map(function(value) {\r\n     *   return Math.pow(value, 2);\r\n     * });\r\n     *\r\n     * var other = [3, 4];\r\n     * var otherWrapped = wrapped.plant(other);\r\n     *\r\n     * otherWrapped.value();\r\n     * // => [9, 16]\r\n     *\r\n     * wrapped.value();\r\n     * // => [1, 4]\r\n     */\r\n    function wrapperPlant(value) {\r\n      var result,\r\n          parent = this;\r\n\r\n      while (parent instanceof baseLodash) {\r\n        var clone = wrapperClone(parent);\r\n        if (result) {\r\n          previous.__wrapped__ = clone;\r\n        } else {\r\n          result = clone;\r\n        }\r\n        var previous = clone;\r\n        parent = parent.__wrapped__;\r\n      }\r\n      previous.__wrapped__ = value;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Reverses the wrapped array so the first element becomes the last, the\r\n     * second element becomes the second to last, and so on.\r\n     *\r\n     * **Note:** This method mutates the wrapped array.\r\n     *\r\n     * @name reverse\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3];\r\n     *\r\n     * _(array).reverse().value()\r\n     * // => [3, 2, 1]\r\n     *\r\n     * console.log(array);\r\n     * // => [3, 2, 1]\r\n     */\r\n    function wrapperReverse() {\r\n      var value = this.__wrapped__;\r\n\r\n      var interceptor = function(value) {\r\n        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();\r\n      };\r\n      if (value instanceof LazyWrapper) {\r\n        var wrapped = value;\r\n        if (this.__actions__.length) {\r\n          wrapped = new LazyWrapper(this);\r\n        }\r\n        wrapped = wrapped.reverse();\r\n        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\r\n        return new LodashWrapper(wrapped, this.__chain__);\r\n      }\r\n      return this.thru(interceptor);\r\n    }\r\n\r\n    /**\r\n     * Produces the result of coercing the unwrapped value to a string.\r\n     *\r\n     * @name toString\r\n     * @memberOf _\r\n     * @category Chain\r\n     * @returns {string} Returns the coerced string value.\r\n     * @example\r\n     *\r\n     * _([1, 2, 3]).toString();\r\n     * // => '1,2,3'\r\n     */\r\n    function wrapperToString() {\r\n      return (this.value() + '');\r\n    }\r\n\r\n    /**\r\n     * Executes the chained sequence to extract the unwrapped value.\r\n     *\r\n     * @name value\r\n     * @memberOf _\r\n     * @alias run, toJSON, valueOf\r\n     * @category Chain\r\n     * @returns {*} Returns the resolved unwrapped value.\r\n     * @example\r\n     *\r\n     * _([1, 2, 3]).value();\r\n     * // => [1, 2, 3]\r\n     */\r\n    function wrapperValue() {\r\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an array of elements corresponding to the given keys, or indexes,\r\n     * of `collection`. Keys may be specified as individual arguments or as arrays\r\n     * of keys.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {...(number|number[]|string|string[])} [props] The property names\r\n     *  or indexes of elements to pick, specified individually or in arrays.\r\n     * @returns {Array} Returns the new array of picked elements.\r\n     * @example\r\n     *\r\n     * _.at(['a', 'b', 'c'], [0, 2]);\r\n     * // => ['a', 'c']\r\n     *\r\n     * _.at(['barney', 'fred', 'pebbles'], 0, 2);\r\n     * // => ['barney', 'pebbles']\r\n     */\r\n    var at = restParam(function(collection, props) {\r\n      return baseAt(collection, baseFlatten(props));\r\n    });\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` through `iteratee`. The corresponding value\r\n     * of each key is the number of times the key was returned by `iteratee`.\r\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\r\n     *   return Math.floor(n);\r\n     * });\r\n     * // => { '4': 1, '6': 2 }\r\n     *\r\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\r\n     *   return this.floor(n);\r\n     * }, Math);\r\n     * // => { '4': 1, '6': 2 }\r\n     *\r\n     * _.countBy(['one', 'two', 'three'], 'length');\r\n     * // => { '3': 2, '5': 1 }\r\n     */\r\n    var countBy = createAggregator(function(result, value, key) {\r\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\r\n    });\r\n\r\n    /**\r\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\r\n     * The predicate is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias all\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.every([true, 1, null, 'yes'], Boolean);\r\n     * // => false\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'active': false },\r\n     *   { 'user': 'fred',   'active': false }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.every(users, { 'user': 'barney', 'active': false });\r\n     * // => false\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.every(users, 'active', false);\r\n     * // => true\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.every(users, 'active');\r\n     * // => false\r\n     */\r\n    function every(collection, predicate, thisArg) {\r\n      var func = isArray(collection) ? arrayEvery : baseEvery;\r\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\r\n        predicate = undefined;\r\n      }\r\n      if (typeof predicate != 'function' || thisArg !== undefined) {\r\n        predicate = getCallback(predicate, thisArg, 3);\r\n      }\r\n      return func(collection, predicate);\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection`, returning an array of all elements\r\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\r\n     * invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias select\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the new filtered array.\r\n     * @example\r\n     *\r\n     * _.filter([4, 5, 6], function(n) {\r\n     *   return n % 2 == 0;\r\n     * });\r\n     * // => [4, 6]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': true },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\r\n     * // => ['barney']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.filter(users, 'active', false), 'user');\r\n     * // => ['fred']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.filter(users, 'active'), 'user');\r\n     * // => ['barney']\r\n     */\r\n    function filter(collection, predicate, thisArg) {\r\n      var func = isArray(collection) ? arrayFilter : baseFilter;\r\n      predicate = getCallback(predicate, thisArg, 3);\r\n      return func(collection, predicate);\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection`, returning the first element\r\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\r\n     * invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias detect\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {*} Returns the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36, 'active': true },\r\n     *   { 'user': 'fred',    'age': 40, 'active': false },\r\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\r\n     * ];\r\n     *\r\n     * _.result(_.find(users, function(chr) {\r\n     *   return chr.age < 40;\r\n     * }), 'user');\r\n     * // => 'barney'\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\r\n     * // => 'pebbles'\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.result(_.find(users, 'active', false), 'user');\r\n     * // => 'fred'\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.result(_.find(users, 'active'), 'user');\r\n     * // => 'barney'\r\n     */\r\n    var find = createFind(baseEach);\r\n\r\n    /**\r\n     * This method is like `_.find` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {*} Returns the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * _.findLast([1, 2, 3, 4], function(n) {\r\n     *   return n % 2 == 1;\r\n     * });\r\n     * // => 3\r\n     */\r\n    var findLast = createFind(baseEachRight, true);\r\n\r\n    /**\r\n     * Performs a deep comparison between each element in `collection` and the\r\n     * source object, returning the first element that has equivalent property\r\n     * values.\r\n     *\r\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\r\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\r\n     * their own, not inherited, enumerable properties. For comparing a single\r\n     * own or inherited property value see `_.matchesProperty`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {*} Returns the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': true },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\r\n     * // => 'barney'\r\n     *\r\n     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\r\n     * // => 'fred'\r\n     */\r\n    function findWhere(collection, source) {\r\n      return find(collection, baseMatches(source));\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\r\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection). Iteratee functions may exit iteration early\r\n     * by explicitly returning `false`.\r\n     *\r\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\r\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\r\n     * may be used for object iteration.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias each\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array|Object|string} Returns `collection`.\r\n     * @example\r\n     *\r\n     * _([1, 2]).forEach(function(n) {\r\n     *   console.log(n);\r\n     * }).value();\r\n     * // => logs each value from left to right and returns the array\r\n     *\r\n     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\r\n     *   console.log(n, key);\r\n     * });\r\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\r\n     */\r\n    var forEach = createForEach(arrayEach, baseEach);\r\n\r\n    /**\r\n     * This method is like `_.forEach` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias eachRight\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array|Object|string} Returns `collection`.\r\n     * @example\r\n     *\r\n     * _([1, 2]).forEachRight(function(n) {\r\n     *   console.log(n);\r\n     * }).value();\r\n     * // => logs each value from right to left and returns the array\r\n     */\r\n    var forEachRight = createForEach(arrayEachRight, baseEachRight);\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` through `iteratee`. The corresponding value\r\n     * of each key is an array of the elements responsible for generating the key.\r\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\r\n     *   return Math.floor(n);\r\n     * });\r\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\r\n     *\r\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\r\n     *   return this.floor(n);\r\n     * }, Math);\r\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.groupBy(['one', 'two', 'three'], 'length');\r\n     * // => { '3': ['one', 'two'], '5': ['three'] }\r\n     */\r\n    var groupBy = createAggregator(function(result, value, key) {\r\n      if (hasOwnProperty.call(result, key)) {\r\n        result[key].push(value);\r\n      } else {\r\n        result[key] = [value];\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Checks if `value` is in `collection` using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\r\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\r\n     * from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias contains, include\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {*} target The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\r\n     * // => true\r\n     *\r\n     * _.includes('pebbles', 'eb');\r\n     * // => true\r\n     */\r\n    function includes(collection, target, fromIndex, guard) {\r\n      var length = collection ? getLength(collection) : 0;\r\n      if (!isLength(length)) {\r\n        collection = values(collection);\r\n        length = collection.length;\r\n      }\r\n      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\r\n        fromIndex = 0;\r\n      } else {\r\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\r\n      }\r\n      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\r\n        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\r\n        : (!!length && getIndexOf(collection, target, fromIndex) > -1);\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` through `iteratee`. The corresponding value\r\n     * of each key is the last element responsible for generating the key. The\r\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * var keyData = [\r\n     *   { 'dir': 'left', 'code': 97 },\r\n     *   { 'dir': 'right', 'code': 100 }\r\n     * ];\r\n     *\r\n     * _.indexBy(keyData, 'dir');\r\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\r\n     *\r\n     * _.indexBy(keyData, function(object) {\r\n     *   return String.fromCharCode(object.code);\r\n     * });\r\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\r\n     *\r\n     * _.indexBy(keyData, function(object) {\r\n     *   return this.fromCharCode(object.code);\r\n     * }, String);\r\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\r\n     */\r\n    var indexBy = createAggregator(function(result, value, key) {\r\n      result[key] = value;\r\n    });\r\n\r\n    /**\r\n     * Invokes the method at `path` of each element in `collection`, returning\r\n     * an array of the results of each invoked method. Any additional arguments\r\n     * are provided to each invoked method. If `methodName` is a function it is\r\n     * invoked for, and `this` bound to, each element in `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Array|Function|string} path The path of the method to invoke or\r\n     *  the function invoked per iteration.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {Array} Returns the array of results.\r\n     * @example\r\n     *\r\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\r\n     * // => [[1, 5, 7], [1, 2, 3]]\r\n     *\r\n     * _.invoke([123, 456], String.prototype.split, '');\r\n     * // => [['1', '2', '3'], ['4', '5', '6']]\r\n     */\r\n    var invoke = restParam(function(collection, path, args) {\r\n      var index = -1,\r\n          isFunc = typeof path == 'function',\r\n          isProp = isKey(path),\r\n          result = isArrayLike(collection) ? Array(collection.length) : [];\r\n\r\n      baseEach(collection, function(value) {\r\n        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\r\n        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);\r\n      });\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Creates an array of values by running each element in `collection` through\r\n     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\r\n     * arguments: (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * Many lodash methods are guarded to work as iteratees for methods like\r\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\r\n     *\r\n     * The guarded methods are:\r\n     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\r\n     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\r\n     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\r\n     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\r\n     * `sum`, `uniq`, and `words`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias collect\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the new mapped array.\r\n     * @example\r\n     *\r\n     * function timesThree(n) {\r\n     *   return n * 3;\r\n     * }\r\n     *\r\n     * _.map([1, 2], timesThree);\r\n     * // => [3, 6]\r\n     *\r\n     * _.map({ 'a': 1, 'b': 2 }, timesThree);\r\n     * // => [3, 6] (iteration order is not guaranteed)\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney' },\r\n     *   { 'user': 'fred' }\r\n     * ];\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.map(users, 'user');\r\n     * // => ['barney', 'fred']\r\n     */\r\n    function map(collection, iteratee, thisArg) {\r\n      var func = isArray(collection) ? arrayMap : baseMap;\r\n      iteratee = getCallback(iteratee, thisArg, 3);\r\n      return func(collection, iteratee);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of elements split into two groups, the first of which\r\n     * contains elements `predicate` returns truthy for, while the second of which\r\n     * contains elements `predicate` returns falsey for. The predicate is bound\r\n     * to `thisArg` and invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the array of grouped elements.\r\n     * @example\r\n     *\r\n     * _.partition([1, 2, 3], function(n) {\r\n     *   return n % 2;\r\n     * });\r\n     * // => [[1, 3], [2]]\r\n     *\r\n     * _.partition([1.2, 2.3, 3.4], function(n) {\r\n     *   return this.floor(n) % 2;\r\n     * }, Math);\r\n     * // => [[1.2, 3.4], [2.3]]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36, 'active': false },\r\n     *   { 'user': 'fred',    'age': 40, 'active': true },\r\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\r\n     * ];\r\n     *\r\n     * var mapper = function(array) {\r\n     *   return _.pluck(array, 'user');\r\n     * };\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\r\n     * // => [['pebbles'], ['barney', 'fred']]\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.map(_.partition(users, 'active', false), mapper);\r\n     * // => [['barney', 'pebbles'], ['fred']]\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.map(_.partition(users, 'active'), mapper);\r\n     * // => [['fred'], ['barney', 'pebbles']]\r\n     */\r\n    var partition = createAggregator(function(result, value, key) {\r\n      result[key ? 0 : 1].push(value);\r\n    }, function() { return [[], []]; });\r\n\r\n    /**\r\n     * Gets the property value of `path` from all elements in `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Array|string} path The path of the property to pluck.\r\n     * @returns {Array} Returns the property values.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * _.pluck(users, 'user');\r\n     * // => ['barney', 'fred']\r\n     *\r\n     * var userIndex = _.indexBy(users, 'user');\r\n     * _.pluck(userIndex, 'age');\r\n     * // => [36, 40] (iteration order is not guaranteed)\r\n     */\r\n    function pluck(collection, path) {\r\n      return map(collection, property(path));\r\n    }\r\n\r\n    /**\r\n     * Reduces `collection` to a value which is the accumulated result of running\r\n     * each element in `collection` through `iteratee`, where each successive\r\n     * invocation is supplied the return value of the previous. If `accumulator`\r\n     * is not provided the first element of `collection` is used as the initial\r\n     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\r\n     * (accumulator, value, index|key, collection).\r\n     *\r\n     * Many lodash methods are guarded to work as iteratees for methods like\r\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\r\n     *\r\n     * The guarded methods are:\r\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\r\n     * and `sortByOrder`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias foldl, inject\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @example\r\n     *\r\n     * _.reduce([1, 2], function(total, n) {\r\n     *   return total + n;\r\n     * });\r\n     * // => 3\r\n     *\r\n     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\r\n     *   result[key] = n * 3;\r\n     *   return result;\r\n     * }, {});\r\n     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\r\n     */\r\n    var reduce = createReduce(arrayReduce, baseEach);\r\n\r\n    /**\r\n     * This method is like `_.reduce` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias foldr\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @example\r\n     *\r\n     * var array = [[0, 1], [2, 3], [4, 5]];\r\n     *\r\n     * _.reduceRight(array, function(flattened, other) {\r\n     *   return flattened.concat(other);\r\n     * }, []);\r\n     * // => [4, 5, 2, 3, 0, 1]\r\n     */\r\n    var reduceRight = createReduce(arrayReduceRight, baseEachRight);\r\n\r\n    /**\r\n     * The opposite of `_.filter`; this method returns the elements of `collection`\r\n     * that `predicate` does **not** return truthy for.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Array} Returns the new filtered array.\r\n     * @example\r\n     *\r\n     * _.reject([1, 2, 3, 4], function(n) {\r\n     *   return n % 2 == 0;\r\n     * });\r\n     * // => [1, 3]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': false },\r\n     *   { 'user': 'fred',   'age': 40, 'active': true }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\r\n     * // => ['barney']\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.pluck(_.reject(users, 'active', false), 'user');\r\n     * // => ['fred']\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.reject(users, 'active'), 'user');\r\n     * // => ['barney']\r\n     */\r\n    function reject(collection, predicate, thisArg) {\r\n      var func = isArray(collection) ? arrayFilter : baseFilter;\r\n      predicate = getCallback(predicate, thisArg, 3);\r\n      return func(collection, function(value, index, collection) {\r\n        return !predicate(value, index, collection);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Gets a random element or `n` random elements from a collection.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to sample.\r\n     * @param {number} [n] The number of elements to sample.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {*} Returns the random sample(s).\r\n     * @example\r\n     *\r\n     * _.sample([1, 2, 3, 4]);\r\n     * // => 2\r\n     *\r\n     * _.sample([1, 2, 3, 4], 2);\r\n     * // => [3, 1]\r\n     */\r\n    function sample(collection, n, guard) {\r\n      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\r\n        collection = toIterable(collection);\r\n        var length = collection.length;\r\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\r\n      }\r\n      var index = -1,\r\n          result = toArray(collection),\r\n          length = result.length,\r\n          lastIndex = length - 1;\r\n\r\n      n = nativeMin(n < 0 ? 0 : (+n || 0), length);\r\n      while (++index < n) {\r\n        var rand = baseRandom(index, lastIndex),\r\n            value = result[rand];\r\n\r\n        result[rand] = result[index];\r\n        result[index] = value;\r\n      }\r\n      result.length = n;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of shuffled values, using a version of the\r\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to shuffle.\r\n     * @returns {Array} Returns the new shuffled array.\r\n     * @example\r\n     *\r\n     * _.shuffle([1, 2, 3, 4]);\r\n     * // => [4, 1, 3, 2]\r\n     */\r\n    function shuffle(collection) {\r\n      return sample(collection, POSITIVE_INFINITY);\r\n    }\r\n\r\n    /**\r\n     * Gets the size of `collection` by returning its length for array-like\r\n     * values or the number of own enumerable properties for objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @returns {number} Returns the size of `collection`.\r\n     * @example\r\n     *\r\n     * _.size([1, 2, 3]);\r\n     * // => 3\r\n     *\r\n     * _.size({ 'a': 1, 'b': 2 });\r\n     * // => 2\r\n     *\r\n     * _.size('pebbles');\r\n     * // => 7\r\n     */\r\n    function size(collection) {\r\n      var length = collection ? getLength(collection) : 0;\r\n      return isLength(length) ? length : keys(collection).length;\r\n    }\r\n\r\n    /**\r\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\r\n     * The function returns as soon as it finds a passing value and does not iterate\r\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\r\n     * with three arguments: (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias any\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.some([null, 0, 'yes', false], Boolean);\r\n     * // => true\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'active': true },\r\n     *   { 'user': 'fred',   'active': false }\r\n     * ];\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.some(users, { 'user': 'barney', 'active': false });\r\n     * // => false\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.some(users, 'active', false);\r\n     * // => true\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.some(users, 'active');\r\n     * // => true\r\n     */\r\n    function some(collection, predicate, thisArg) {\r\n      var func = isArray(collection) ? arraySome : baseSome;\r\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\r\n        predicate = undefined;\r\n      }\r\n      if (typeof predicate != 'function' || thisArg !== undefined) {\r\n        predicate = getCallback(predicate, thisArg, 3);\r\n      }\r\n      return func(collection, predicate);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of elements, sorted in ascending order by the results of\r\n     * running each element in a collection through `iteratee`. This method performs\r\n     * a stable sort, that is, it preserves the original sort order of equal elements.\r\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the new sorted array.\r\n     * @example\r\n     *\r\n     * _.sortBy([1, 2, 3], function(n) {\r\n     *   return Math.sin(n);\r\n     * });\r\n     * // => [3, 1, 2]\r\n     *\r\n     * _.sortBy([1, 2, 3], function(n) {\r\n     *   return this.sin(n);\r\n     * }, Math);\r\n     * // => [3, 1, 2]\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'fred' },\r\n     *   { 'user': 'pebbles' },\r\n     *   { 'user': 'barney' }\r\n     * ];\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.pluck(_.sortBy(users, 'user'), 'user');\r\n     * // => ['barney', 'fred', 'pebbles']\r\n     */\r\n    function sortBy(collection, iteratee, thisArg) {\r\n      if (collection == null) {\r\n        return [];\r\n      }\r\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\r\n        iteratee = undefined;\r\n      }\r\n      var index = -1;\r\n      iteratee = getCallback(iteratee, thisArg, 3);\r\n\r\n      var result = baseMap(collection, function(value, key, collection) {\r\n        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\r\n      });\r\n      return baseSortBy(result, compareAscending);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sortBy` except that it can sort by multiple iteratees\r\n     * or property names.\r\n     *\r\n     * If a property name is provided for an iteratee the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If an object is provided for an iteratee the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees\r\n     *  The iteratees to sort by, specified as individual values or arrays of values.\r\n     * @returns {Array} Returns the new sorted array.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'fred',   'age': 48 },\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 42 },\r\n     *   { 'user': 'barney', 'age': 34 }\r\n     * ];\r\n     *\r\n     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\r\n     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\r\n     *\r\n     * _.map(_.sortByAll(users, 'user', function(chr) {\r\n     *   return Math.floor(chr.age / 10);\r\n     * }), _.values);\r\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\r\n     */\r\n    var sortByAll = restParam(function(collection, iteratees) {\r\n      if (collection == null) {\r\n        return [];\r\n      }\r\n      var guard = iteratees[2];\r\n      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {\r\n        iteratees.length = 1;\r\n      }\r\n      return baseSortByOrder(collection, baseFlatten(iteratees), []);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.sortByAll` except that it allows specifying the\r\n     * sort orders of the iteratees to sort by. If `orders` is unspecified, all\r\n     * values are sorted in ascending order. Otherwise, a value is sorted in\r\n     * ascending order if its corresponding order is \"asc\", and descending if \"desc\".\r\n     *\r\n     * If a property name is provided for an iteratee the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If an object is provided for an iteratee the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\r\n     * @param {boolean[]} [orders] The sort orders of `iteratees`.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\r\n     * @returns {Array} Returns the new sorted array.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'fred',   'age': 48 },\r\n     *   { 'user': 'barney', 'age': 34 },\r\n     *   { 'user': 'fred',   'age': 42 },\r\n     *   { 'user': 'barney', 'age': 36 }\r\n     * ];\r\n     *\r\n     * // sort by `user` in ascending order and by `age` in descending order\r\n     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);\r\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\r\n     */\r\n    function sortByOrder(collection, iteratees, orders, guard) {\r\n      if (collection == null) {\r\n        return [];\r\n      }\r\n      if (guard && isIterateeCall(iteratees, orders, guard)) {\r\n        orders = undefined;\r\n      }\r\n      if (!isArray(iteratees)) {\r\n        iteratees = iteratees == null ? [] : [iteratees];\r\n      }\r\n      if (!isArray(orders)) {\r\n        orders = orders == null ? [] : [orders];\r\n      }\r\n      return baseSortByOrder(collection, iteratees, orders);\r\n    }\r\n\r\n    /**\r\n     * Performs a deep comparison between each element in `collection` and the\r\n     * source object, returning an array of all elements that have equivalent\r\n     * property values.\r\n     *\r\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\r\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\r\n     * their own, not inherited, enumerable properties. For comparing a single\r\n     * own or inherited property value see `_.matchesProperty`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to search.\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {Array} Returns the new filtered array.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\r\n     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\r\n     * ];\r\n     *\r\n     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\r\n     * // => ['barney']\r\n     *\r\n     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\r\n     * // => ['fred']\r\n     */\r\n    function where(collection, source) {\r\n      return filter(collection, baseMatches(source));\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\r\n     * (1 January 1970 00:00:00 UTC).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Date\r\n     * @example\r\n     *\r\n     * _.defer(function(stamp) {\r\n     *   console.log(_.now() - stamp);\r\n     * }, _.now());\r\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\r\n     */\r\n    var now = nativeNow || function() {\r\n      return new Date().getTime();\r\n    };\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * The opposite of `_.before`; this method creates a function that invokes\r\n     * `func` once it is called `n` or more times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {number} n The number of calls before `func` is invoked.\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * var saves = ['profile', 'settings'];\r\n     *\r\n     * var done = _.after(saves.length, function() {\r\n     *   console.log('done saving!');\r\n     * });\r\n     *\r\n     * _.forEach(saves, function(type) {\r\n     *   asyncSave({ 'type': type, 'complete': done });\r\n     * });\r\n     * // => logs 'done saving!' after the two async saves have completed\r\n     */\r\n    function after(n, func) {\r\n      if (typeof func != 'function') {\r\n        if (typeof n == 'function') {\r\n          var temp = n;\r\n          n = func;\r\n          func = temp;\r\n        } else {\r\n          throw new TypeError(FUNC_ERROR_TEXT);\r\n        }\r\n      }\r\n      n = nativeIsFinite(n = +n) ? n : 0;\r\n      return function() {\r\n        if (--n < 1) {\r\n          return func.apply(this, arguments);\r\n        }\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that accepts up to `n` arguments ignoring any\r\n     * additional arguments.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to cap arguments for.\r\n     * @param {number} [n=func.length] The arity cap.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\r\n     * // => [6, 8, 10]\r\n     */\r\n    function ary(func, n, guard) {\r\n      if (guard && isIterateeCall(func, n, guard)) {\r\n        n = undefined;\r\n      }\r\n      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\r\n      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func`, with the `this` binding and arguments\r\n     * of the created function, while it is called less than `n` times. Subsequent\r\n     * calls to the created function return the result of the last `func` invocation.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {number} n The number of calls at which `func` is no longer invoked.\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * jQuery('#add').on('click', _.before(5, addContactToList));\r\n     * // => allows adding up to 4 contacts to the list\r\n     */\r\n    function before(n, func) {\r\n      var result;\r\n      if (typeof func != 'function') {\r\n        if (typeof n == 'function') {\r\n          var temp = n;\r\n          n = func;\r\n          func = temp;\r\n        } else {\r\n          throw new TypeError(FUNC_ERROR_TEXT);\r\n        }\r\n      }\r\n      return function() {\r\n        if (--n > 0) {\r\n          result = func.apply(this, arguments);\r\n        }\r\n        if (n <= 1) {\r\n          func = undefined;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\r\n     * and prepends any additional `_.bind` arguments to those provided to the\r\n     * bound function.\r\n     *\r\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\r\n     * may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\r\n     * property of bound functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to bind.\r\n     * @param {*} thisArg The `this` binding of `func`.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new bound function.\r\n     * @example\r\n     *\r\n     * var greet = function(greeting, punctuation) {\r\n     *   return greeting + ' ' + this.user + punctuation;\r\n     * };\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     *\r\n     * var bound = _.bind(greet, object, 'hi');\r\n     * bound('!');\r\n     * // => 'hi fred!'\r\n     *\r\n     * // using placeholders\r\n     * var bound = _.bind(greet, object, _, '!');\r\n     * bound('hi');\r\n     * // => 'hi fred!'\r\n     */\r\n    var bind = restParam(function(func, thisArg, partials) {\r\n      var bitmask = BIND_FLAG;\r\n      if (partials.length) {\r\n        var holders = replaceHolders(partials, bind.placeholder);\r\n        bitmask |= PARTIAL_FLAG;\r\n      }\r\n      return createWrapper(func, bitmask, thisArg, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * Binds methods of an object to the object itself, overwriting the existing\r\n     * method. Method names may be specified as individual arguments or as arrays\r\n     * of method names. If no method names are provided all enumerable function\r\n     * properties, own and inherited, of `object` are bound.\r\n     *\r\n     * **Note:** This method does not set the \"length\" property of bound functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Object} object The object to bind and assign the bound methods to.\r\n     * @param {...(string|string[])} [methodNames] The object method names to bind,\r\n     *  specified as individual method names or arrays of method names.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var view = {\r\n     *   'label': 'docs',\r\n     *   'onClick': function() {\r\n     *     console.log('clicked ' + this.label);\r\n     *   }\r\n     * };\r\n     *\r\n     * _.bindAll(view);\r\n     * jQuery('#docs').on('click', view.onClick);\r\n     * // => logs 'clicked docs' when the element is clicked\r\n     */\r\n    var bindAll = restParam(function(object, methodNames) {\r\n      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\r\n\r\n      var index = -1,\r\n          length = methodNames.length;\r\n\r\n      while (++index < length) {\r\n        var key = methodNames[index];\r\n        object[key] = createWrapper(object[key], BIND_FLAG, object);\r\n      }\r\n      return object;\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes the method at `object[key]` and prepends\r\n     * any additional `_.bindKey` arguments to those provided to the bound function.\r\n     *\r\n     * This method differs from `_.bind` by allowing bound functions to reference\r\n     * methods that may be redefined or don't yet exist.\r\n     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\r\n     * for more details.\r\n     *\r\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Object} object The object the method belongs to.\r\n     * @param {string} key The key of the method.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new bound function.\r\n     * @example\r\n     *\r\n     * var object = {\r\n     *   'user': 'fred',\r\n     *   'greet': function(greeting, punctuation) {\r\n     *     return greeting + ' ' + this.user + punctuation;\r\n     *   }\r\n     * };\r\n     *\r\n     * var bound = _.bindKey(object, 'greet', 'hi');\r\n     * bound('!');\r\n     * // => 'hi fred!'\r\n     *\r\n     * object.greet = function(greeting, punctuation) {\r\n     *   return greeting + 'ya ' + this.user + punctuation;\r\n     * };\r\n     *\r\n     * bound('!');\r\n     * // => 'hiya fred!'\r\n     *\r\n     * // using placeholders\r\n     * var bound = _.bindKey(object, 'greet', _, '!');\r\n     * bound('hi');\r\n     * // => 'hiya fred!'\r\n     */\r\n    var bindKey = restParam(function(object, key, partials) {\r\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\r\n      if (partials.length) {\r\n        var holders = replaceHolders(partials, bindKey.placeholder);\r\n        bitmask |= PARTIAL_FLAG;\r\n      }\r\n      return createWrapper(key, bitmask, object, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that accepts one or more arguments of `func` that when\r\n     * called either invokes `func` returning its result, if all `func` arguments\r\n     * have been provided, or returns a function that accepts one or more of the\r\n     * remaining `func` arguments, and so on. The arity of `func` may be specified\r\n     * if `func.length` is not sufficient.\r\n     *\r\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\r\n     * may be used as a placeholder for provided arguments.\r\n     *\r\n     * **Note:** This method does not set the \"length\" property of curried functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to curry.\r\n     * @param {number} [arity=func.length] The arity of `func`.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Function} Returns the new curried function.\r\n     * @example\r\n     *\r\n     * var abc = function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * };\r\n     *\r\n     * var curried = _.curry(abc);\r\n     *\r\n     * curried(1)(2)(3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2)(3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2, 3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * // using placeholders\r\n     * curried(1)(_, 3)(2);\r\n     * // => [1, 2, 3]\r\n     */\r\n    var curry = createCurry(CURRY_FLAG);\r\n\r\n    /**\r\n     * This method is like `_.curry` except that arguments are applied to `func`\r\n     * in the manner of `_.partialRight` instead of `_.partial`.\r\n     *\r\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for provided arguments.\r\n     *\r\n     * **Note:** This method does not set the \"length\" property of curried functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to curry.\r\n     * @param {number} [arity=func.length] The arity of `func`.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Function} Returns the new curried function.\r\n     * @example\r\n     *\r\n     * var abc = function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * };\r\n     *\r\n     * var curried = _.curryRight(abc);\r\n     *\r\n     * curried(3)(2)(1);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(2, 3)(1);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2, 3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * // using placeholders\r\n     * curried(3)(1, _)(2);\r\n     * // => [1, 2, 3]\r\n     */\r\n    var curryRight = createCurry(CURRY_RIGHT_FLAG);\r\n\r\n    /**\r\n     * Creates a debounced function that delays invoking `func` until after `wait`\r\n     * milliseconds have elapsed since the last time the debounced function was\r\n     * invoked. The debounced function comes with a `cancel` method to cancel\r\n     * delayed invocations. Provide an options object to indicate that `func`\r\n     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\r\n     * Subsequent calls to the debounced function return the result of the last\r\n     * `func` invocation.\r\n     *\r\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\r\n     * on the trailing edge of the timeout only if the the debounced function is\r\n     * invoked more than once during the `wait` timeout.\r\n     *\r\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\r\n     * for details over the differences between `_.debounce` and `_.throttle`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to debounce.\r\n     * @param {number} [wait=0] The number of milliseconds to delay.\r\n     * @param {Object} [options] The options object.\r\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\r\n     *  edge of the timeout.\r\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\r\n     *  delayed before it is invoked.\r\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\r\n     *  edge of the timeout.\r\n     * @returns {Function} Returns the new debounced function.\r\n     * @example\r\n     *\r\n     * // avoid costly calculations while the window size is in flux\r\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\r\n     *\r\n     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\r\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\r\n     *   'leading': true,\r\n     *   'trailing': false\r\n     * }));\r\n     *\r\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\r\n     * var source = new EventSource('/stream');\r\n     * jQuery(source).on('message', _.debounce(batchLog, 250, {\r\n     *   'maxWait': 1000\r\n     * }));\r\n     *\r\n     * // cancel a debounced call\r\n     * var todoChanges = _.debounce(batchLog, 1000);\r\n     * Object.observe(models.todo, todoChanges);\r\n     *\r\n     * Object.observe(models, function(changes) {\r\n     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\r\n     *     todoChanges.cancel();\r\n     *   }\r\n     * }, ['delete']);\r\n     *\r\n     * // ...at some point `models.todo` is changed\r\n     * models.todo.completed = true;\r\n     *\r\n     * // ...before 1 second has passed `models.todo` is deleted\r\n     * // which cancels the debounced `todoChanges` call\r\n     * delete models.todo;\r\n     */\r\n    function debounce(func, wait, options) {\r\n      var args,\r\n          maxTimeoutId,\r\n          result,\r\n          stamp,\r\n          thisArg,\r\n          timeoutId,\r\n          trailingCall,\r\n          lastCalled = 0,\r\n          maxWait = false,\r\n          trailing = true;\r\n\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      wait = wait < 0 ? 0 : (+wait || 0);\r\n      if (options === true) {\r\n        var leading = true;\r\n        trailing = false;\r\n      } else if (isObject(options)) {\r\n        leading = !!options.leading;\r\n        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n      }\r\n\r\n      function cancel() {\r\n        if (timeoutId) {\r\n          clearTimeout(timeoutId);\r\n        }\r\n        if (maxTimeoutId) {\r\n          clearTimeout(maxTimeoutId);\r\n        }\r\n        lastCalled = 0;\r\n        maxTimeoutId = timeoutId = trailingCall = undefined;\r\n      }\r\n\r\n      function complete(isCalled, id) {\r\n        if (id) {\r\n          clearTimeout(id);\r\n        }\r\n        maxTimeoutId = timeoutId = trailingCall = undefined;\r\n        if (isCalled) {\r\n          lastCalled = now();\r\n          result = func.apply(thisArg, args);\r\n          if (!timeoutId && !maxTimeoutId) {\r\n            args = thisArg = undefined;\r\n          }\r\n        }\r\n      }\r\n\r\n      function delayed() {\r\n        var remaining = wait - (now() - stamp);\r\n        if (remaining <= 0 || remaining > wait) {\r\n          complete(trailingCall, maxTimeoutId);\r\n        } else {\r\n          timeoutId = setTimeout(delayed, remaining);\r\n        }\r\n      }\r\n\r\n      function maxDelayed() {\r\n        complete(trailing, timeoutId);\r\n      }\r\n\r\n      function debounced() {\r\n        args = arguments;\r\n        stamp = now();\r\n        thisArg = this;\r\n        trailingCall = trailing && (timeoutId || !leading);\r\n\r\n        if (maxWait === false) {\r\n          var leadingCall = leading && !timeoutId;\r\n        } else {\r\n          if (!maxTimeoutId && !leading) {\r\n            lastCalled = stamp;\r\n          }\r\n          var remaining = maxWait - (stamp - lastCalled),\r\n              isCalled = remaining <= 0 || remaining > maxWait;\r\n\r\n          if (isCalled) {\r\n            if (maxTimeoutId) {\r\n              maxTimeoutId = clearTimeout(maxTimeoutId);\r\n            }\r\n            lastCalled = stamp;\r\n            result = func.apply(thisArg, args);\r\n          }\r\n          else if (!maxTimeoutId) {\r\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\r\n          }\r\n        }\r\n        if (isCalled && timeoutId) {\r\n          timeoutId = clearTimeout(timeoutId);\r\n        }\r\n        else if (!timeoutId && wait !== maxWait) {\r\n          timeoutId = setTimeout(delayed, wait);\r\n        }\r\n        if (leadingCall) {\r\n          isCalled = true;\r\n          result = func.apply(thisArg, args);\r\n        }\r\n        if (isCalled && !timeoutId && !maxTimeoutId) {\r\n          args = thisArg = undefined;\r\n        }\r\n        return result;\r\n      }\r\n      debounced.cancel = cancel;\r\n      return debounced;\r\n    }\r\n\r\n    /**\r\n     * Defers invoking the `func` until the current call stack has cleared. Any\r\n     * additional arguments are provided to `func` when it is invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to defer.\r\n     * @param {...*} [args] The arguments to invoke the function with.\r\n     * @returns {number} Returns the timer id.\r\n     * @example\r\n     *\r\n     * _.defer(function(text) {\r\n     *   console.log(text);\r\n     * }, 'deferred');\r\n     * // logs 'deferred' after one or more milliseconds\r\n     */\r\n    var defer = restParam(function(func, args) {\r\n      return baseDelay(func, 1, args);\r\n    });\r\n\r\n    /**\r\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\r\n     * provided to `func` when it is invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to delay.\r\n     * @param {number} wait The number of milliseconds to delay invocation.\r\n     * @param {...*} [args] The arguments to invoke the function with.\r\n     * @returns {number} Returns the timer id.\r\n     * @example\r\n     *\r\n     * _.delay(function(text) {\r\n     *   console.log(text);\r\n     * }, 1000, 'later');\r\n     * // => logs 'later' after one second\r\n     */\r\n    var delay = restParam(function(func, wait, args) {\r\n      return baseDelay(func, wait, args);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that returns the result of invoking the provided\r\n     * functions with the `this` binding of the created function, where each\r\n     * successive invocation is supplied the return value of the previous.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {...Function} [funcs] Functions to invoke.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var addSquare = _.flow(_.add, square);\r\n     * addSquare(1, 2);\r\n     * // => 9\r\n     */\r\n    var flow = createFlow();\r\n\r\n    /**\r\n     * This method is like `_.flow` except that it creates a function that\r\n     * invokes the provided functions from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias backflow, compose\r\n     * @category Function\r\n     * @param {...Function} [funcs] Functions to invoke.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var addSquare = _.flowRight(square, _.add);\r\n     * addSquare(1, 2);\r\n     * // => 9\r\n     */\r\n    var flowRight = createFlow(true);\r\n\r\n    /**\r\n     * Creates a function that memoizes the result of `func`. If `resolver` is\r\n     * provided it determines the cache key for storing the result based on the\r\n     * arguments provided to the memoized function. By default, the first argument\r\n     * provided to the memoized function is coerced to a string and used as the\r\n     * cache key. The `func` is invoked with the `this` binding of the memoized\r\n     * function.\r\n     *\r\n     * **Note:** The cache is exposed as the `cache` property on the memoized\r\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\r\n     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\r\n     * method interface of `get`, `has`, and `set`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to have its output memoized.\r\n     * @param {Function} [resolver] The function to resolve the cache key.\r\n     * @returns {Function} Returns the new memoizing function.\r\n     * @example\r\n     *\r\n     * var upperCase = _.memoize(function(string) {\r\n     *   return string.toUpperCase();\r\n     * });\r\n     *\r\n     * upperCase('fred');\r\n     * // => 'FRED'\r\n     *\r\n     * // modifying the result cache\r\n     * upperCase.cache.set('fred', 'BARNEY');\r\n     * upperCase('fred');\r\n     * // => 'BARNEY'\r\n     *\r\n     * // replacing `_.memoize.Cache`\r\n     * var object = { 'user': 'fred' };\r\n     * var other = { 'user': 'barney' };\r\n     * var identity = _.memoize(_.identity);\r\n     *\r\n     * identity(object);\r\n     * // => { 'user': 'fred' }\r\n     * identity(other);\r\n     * // => { 'user': 'fred' }\r\n     *\r\n     * _.memoize.Cache = WeakMap;\r\n     * var identity = _.memoize(_.identity);\r\n     *\r\n     * identity(object);\r\n     * // => { 'user': 'fred' }\r\n     * identity(other);\r\n     * // => { 'user': 'barney' }\r\n     */\r\n    function memoize(func, resolver) {\r\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      var memoized = function() {\r\n        var args = arguments,\r\n            key = resolver ? resolver.apply(this, args) : args[0],\r\n            cache = memoized.cache;\r\n\r\n        if (cache.has(key)) {\r\n          return cache.get(key);\r\n        }\r\n        var result = func.apply(this, args);\r\n        memoized.cache = cache.set(key, result);\r\n        return result;\r\n      };\r\n      memoized.cache = new memoize.Cache;\r\n      return memoized;\r\n    }\r\n\r\n    /**\r\n     * Creates a function that runs each argument through a corresponding\r\n     * transform function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to wrap.\r\n     * @param {...(Function|Function[])} [transforms] The functions to transform\r\n     * arguments, specified as individual functions or arrays of functions.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * function doubled(n) {\r\n     *   return n * 2;\r\n     * }\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var modded = _.modArgs(function(x, y) {\r\n     *   return [x, y];\r\n     * }, square, doubled);\r\n     *\r\n     * modded(1, 2);\r\n     * // => [1, 4]\r\n     *\r\n     * modded(5, 10);\r\n     * // => [25, 20]\r\n     */\r\n    var modArgs = restParam(function(func, transforms) {\r\n      transforms = baseFlatten(transforms);\r\n      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      var length = transforms.length;\r\n      return restParam(function(args) {\r\n        var index = nativeMin(args.length, length);\r\n        while (index--) {\r\n          args[index] = transforms[index](args[index]);\r\n        }\r\n        return func.apply(this, args);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * Creates a function that negates the result of the predicate `func`. The\r\n     * `func` predicate is invoked with the `this` binding and arguments of the\r\n     * created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} predicate The predicate to negate.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * function isEven(n) {\r\n     *   return n % 2 == 0;\r\n     * }\r\n     *\r\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\r\n     * // => [1, 3, 5]\r\n     */\r\n    function negate(predicate) {\r\n      if (typeof predicate != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      return function() {\r\n        return !predicate.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\r\n     * to the function return the value of the first call. The `func` is invoked\r\n     * with the `this` binding and arguments of the created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * var initialize = _.once(createApplication);\r\n     * initialize();\r\n     * initialize();\r\n     * // `initialize` invokes `createApplication` once\r\n     */\r\n    function once(func) {\r\n      return before(2, func);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with `partial` arguments prepended\r\n     * to those provided to the new function. This method is like `_.bind` except\r\n     * it does **not** alter the `this` binding.\r\n     *\r\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** This method does not set the \"length\" property of partially\r\n     * applied functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to partially apply arguments to.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new partially applied function.\r\n     * @example\r\n     *\r\n     * var greet = function(greeting, name) {\r\n     *   return greeting + ' ' + name;\r\n     * };\r\n     *\r\n     * var sayHelloTo = _.partial(greet, 'hello');\r\n     * sayHelloTo('fred');\r\n     * // => 'hello fred'\r\n     *\r\n     * // using placeholders\r\n     * var greetFred = _.partial(greet, _, 'fred');\r\n     * greetFred('hi');\r\n     * // => 'hi fred'\r\n     */\r\n    var partial = createPartial(PARTIAL_FLAG);\r\n\r\n    /**\r\n     * This method is like `_.partial` except that partially applied arguments\r\n     * are appended to those provided to the new function.\r\n     *\r\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** This method does not set the \"length\" property of partially\r\n     * applied functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to partially apply arguments to.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new partially applied function.\r\n     * @example\r\n     *\r\n     * var greet = function(greeting, name) {\r\n     *   return greeting + ' ' + name;\r\n     * };\r\n     *\r\n     * var greetFred = _.partialRight(greet, 'fred');\r\n     * greetFred('hi');\r\n     * // => 'hi fred'\r\n     *\r\n     * // using placeholders\r\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\r\n     * sayHelloTo('fred');\r\n     * // => 'hello fred'\r\n     */\r\n    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with arguments arranged according\r\n     * to the specified indexes where the argument value at the first index is\r\n     * provided as the first argument, the argument value at the second index is\r\n     * provided as the second argument, and so on.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to rearrange arguments for.\r\n     * @param {...(number|number[])} indexes The arranged argument indexes,\r\n     *  specified as individual indexes or arrays of indexes.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var rearged = _.rearg(function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * }, 2, 0, 1);\r\n     *\r\n     * rearged('b', 'c', 'a')\r\n     * // => ['a', 'b', 'c']\r\n     *\r\n     * var map = _.rearg(_.map, [1, 0]);\r\n     * map(function(n) {\r\n     *   return n * 3;\r\n     * }, [1, 2, 3]);\r\n     * // => [3, 6, 9]\r\n     */\r\n    var rearg = restParam(function(func, indexes) {\r\n      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of the\r\n     * created function and arguments from `start` and beyond provided as an array.\r\n     *\r\n     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var say = _.restParam(function(what, names) {\r\n     *   return what + ' ' + _.initial(names).join(', ') +\r\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\r\n     * });\r\n     *\r\n     * say('hello', 'fred', 'barney', 'pebbles');\r\n     * // => 'hello fred, barney, & pebbles'\r\n     */\r\n    function restParam(func, start) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\r\n      return function() {\r\n        var args = arguments,\r\n            index = -1,\r\n            length = nativeMax(args.length - start, 0),\r\n            rest = Array(length);\r\n\r\n        while (++index < length) {\r\n          rest[index] = args[start + index];\r\n        }\r\n        switch (start) {\r\n          case 0: return func.call(this, rest);\r\n          case 1: return func.call(this, args[0], rest);\r\n          case 2: return func.call(this, args[0], args[1], rest);\r\n        }\r\n        var otherArgs = Array(start + 1);\r\n        index = -1;\r\n        while (++index < start) {\r\n          otherArgs[index] = args[index];\r\n        }\r\n        otherArgs[start] = rest;\r\n        return func.apply(this, otherArgs);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of the created\r\n     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\r\n     *\r\n     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to spread arguments over.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var say = _.spread(function(who, what) {\r\n     *   return who + ' says ' + what;\r\n     * });\r\n     *\r\n     * say(['fred', 'hello']);\r\n     * // => 'fred says hello'\r\n     *\r\n     * // with a Promise\r\n     * var numbers = Promise.all([\r\n     *   Promise.resolve(40),\r\n     *   Promise.resolve(36)\r\n     * ]);\r\n     *\r\n     * numbers.then(_.spread(function(x, y) {\r\n     *   return x + y;\r\n     * }));\r\n     * // => a Promise of 76\r\n     */\r\n    function spread(func) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      return function(array) {\r\n        return func.apply(this, array);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a throttled function that only invokes `func` at most once per\r\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\r\n     * method to cancel delayed invocations. Provide an options object to indicate\r\n     * that `func` should be invoked on the leading and/or trailing edge of the\r\n     * `wait` timeout. Subsequent calls to the throttled function return the\r\n     * result of the last `func` call.\r\n     *\r\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\r\n     * on the trailing edge of the timeout only if the the throttled function is\r\n     * invoked more than once during the `wait` timeout.\r\n     *\r\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\r\n     * for details over the differences between `_.throttle` and `_.debounce`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to throttle.\r\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\r\n     * @param {Object} [options] The options object.\r\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\r\n     *  edge of the timeout.\r\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\r\n     *  edge of the timeout.\r\n     * @returns {Function} Returns the new throttled function.\r\n     * @example\r\n     *\r\n     * // avoid excessively updating the position while scrolling\r\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\r\n     *\r\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\r\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\r\n     *   'trailing': false\r\n     * }));\r\n     *\r\n     * // cancel a trailing throttled call\r\n     * jQuery(window).on('popstate', throttled.cancel);\r\n     */\r\n    function throttle(func, wait, options) {\r\n      var leading = true,\r\n          trailing = true;\r\n\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      if (options === false) {\r\n        leading = false;\r\n      } else if (isObject(options)) {\r\n        leading = 'leading' in options ? !!options.leading : leading;\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n      }\r\n      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\r\n    }\r\n\r\n    /**\r\n     * Creates a function that provides `value` to the wrapper function as its\r\n     * first argument. Any additional arguments provided to the function are\r\n     * appended to those provided to the wrapper function. The wrapper is invoked\r\n     * with the `this` binding of the created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {*} value The value to wrap.\r\n     * @param {Function} wrapper The wrapper function.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var p = _.wrap(_.escape, function(func, text) {\r\n     *   return '<p>' + func(text) + '</p>';\r\n     * });\r\n     *\r\n     * p('fred, barney, & pebbles');\r\n     * // => '<p>fred, barney, &amp; pebbles</p>'\r\n     */\r\n    function wrap(value, wrapper) {\r\n      wrapper = wrapper == null ? identity : wrapper;\r\n      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\r\n     * otherwise they are assigned by reference. If `customizer` is provided it is\r\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\r\n     * cloning is handled by the method instead. The `customizer` is bound to\r\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\r\n     *\r\n     * **Note:** This method is loosely based on the\r\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\r\n     * The enumerable properties of `arguments` objects and objects created by\r\n     * constructors other than `Object` are cloned to plain `Object` objects. An\r\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\r\n     * Maps, Sets, and WeakMaps.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @param {Function} [customizer] The function to customize cloning values.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {*} Returns the cloned value.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney' },\r\n     *   { 'user': 'fred' }\r\n     * ];\r\n     *\r\n     * var shallow = _.clone(users);\r\n     * shallow[0] === users[0];\r\n     * // => true\r\n     *\r\n     * var deep = _.clone(users, true);\r\n     * deep[0] === users[0];\r\n     * // => false\r\n     *\r\n     * // using a customizer callback\r\n     * var el = _.clone(document.body, function(value) {\r\n     *   if (_.isElement(value)) {\r\n     *     return value.cloneNode(false);\r\n     *   }\r\n     * });\r\n     *\r\n     * el === document.body\r\n     * // => false\r\n     * el.nodeName\r\n     * // => BODY\r\n     * el.childNodes.length;\r\n     * // => 0\r\n     */\r\n    function clone(value, isDeep, customizer, thisArg) {\r\n      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\r\n        isDeep = false;\r\n      }\r\n      else if (typeof isDeep == 'function') {\r\n        thisArg = customizer;\r\n        customizer = isDeep;\r\n        isDeep = false;\r\n      }\r\n      return typeof customizer == 'function'\r\n        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))\r\n        : baseClone(value, isDeep);\r\n    }\r\n\r\n    /**\r\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\r\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\r\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\r\n     * and invoked with two argument; (value [, index|key, object]).\r\n     *\r\n     * **Note:** This method is loosely based on the\r\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\r\n     * The enumerable properties of `arguments` objects and objects created by\r\n     * constructors other than `Object` are cloned to plain `Object` objects. An\r\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\r\n     * Maps, Sets, and WeakMaps.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to deep clone.\r\n     * @param {Function} [customizer] The function to customize cloning values.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {*} Returns the deep cloned value.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney' },\r\n     *   { 'user': 'fred' }\r\n     * ];\r\n     *\r\n     * var deep = _.cloneDeep(users);\r\n     * deep[0] === users[0];\r\n     * // => false\r\n     *\r\n     * // using a customizer callback\r\n     * var el = _.cloneDeep(document.body, function(value) {\r\n     *   if (_.isElement(value)) {\r\n     *     return value.cloneNode(true);\r\n     *   }\r\n     * });\r\n     *\r\n     * el === document.body\r\n     * // => false\r\n     * el.nodeName\r\n     * // => BODY\r\n     * el.childNodes.length;\r\n     * // => 20\r\n     */\r\n    function cloneDeep(value, customizer, thisArg) {\r\n      return typeof customizer == 'function'\r\n        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))\r\n        : baseClone(value, true);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is greater than `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\r\n     * @example\r\n     *\r\n     * _.gt(3, 1);\r\n     * // => true\r\n     *\r\n     * _.gt(3, 3);\r\n     * // => false\r\n     *\r\n     * _.gt(1, 3);\r\n     * // => false\r\n     */\r\n    function gt(value, other) {\r\n      return value > other;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is greater than or equal to `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\r\n     * @example\r\n     *\r\n     * _.gte(3, 1);\r\n     * // => true\r\n     *\r\n     * _.gte(3, 3);\r\n     * // => true\r\n     *\r\n     * _.gte(1, 3);\r\n     * // => false\r\n     */\r\n    function gte(value, other) {\r\n      return value >= other;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as an `arguments` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isArguments(function() { return arguments; }());\r\n     * // => true\r\n     *\r\n     * _.isArguments([1, 2, 3]);\r\n     * // => false\r\n     */\r\n    function isArguments(value) {\r\n      return isObjectLike(value) && isArrayLike(value) &&\r\n        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as an `Array` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isArray([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isArray(function() { return arguments; }());\r\n     * // => false\r\n     */\r\n    var isArray = nativeIsArray || function(value) {\r\n      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\r\n    };\r\n\r\n    /**\r\n     * Checks if `value` is classified as a boolean primitive or object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isBoolean(false);\r\n     * // => true\r\n     *\r\n     * _.isBoolean(null);\r\n     * // => false\r\n     */\r\n    function isBoolean(value) {\r\n      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Date` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isDate(new Date);\r\n     * // => true\r\n     *\r\n     * _.isDate('Mon April 23 2012');\r\n     * // => false\r\n     */\r\n    function isDate(value) {\r\n      return isObjectLike(value) && objToString.call(value) == dateTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a DOM element.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\r\n     * @example\r\n     *\r\n     * _.isElement(document.body);\r\n     * // => true\r\n     *\r\n     * _.isElement('<body>');\r\n     * // => false\r\n     */\r\n    function isElement(value) {\r\n      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is empty. A value is considered empty unless it is an\r\n     * `arguments` object, array, string, or jQuery-like collection with a length\r\n     * greater than `0` or an object with own enumerable properties.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {Array|Object|string} value The value to inspect.\r\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\r\n     * @example\r\n     *\r\n     * _.isEmpty(null);\r\n     * // => true\r\n     *\r\n     * _.isEmpty(true);\r\n     * // => true\r\n     *\r\n     * _.isEmpty(1);\r\n     * // => true\r\n     *\r\n     * _.isEmpty([1, 2, 3]);\r\n     * // => false\r\n     *\r\n     * _.isEmpty({ 'a': 1 });\r\n     * // => false\r\n     */\r\n    function isEmpty(value) {\r\n      if (value == null) {\r\n        return true;\r\n      }\r\n      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\r\n          (isObjectLike(value) && isFunction(value.splice)))) {\r\n        return !value.length;\r\n      }\r\n      return !keys(value).length;\r\n    }\r\n\r\n    /**\r\n     * Performs a deep comparison between two values to determine if they are\r\n     * equivalent. If `customizer` is provided it is invoked to compare values.\r\n     * If `customizer` returns `undefined` comparisons are handled by the method\r\n     * instead. The `customizer` is bound to `thisArg` and invoked with three\r\n     * arguments: (value, other [, index|key]).\r\n     *\r\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\r\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\r\n     * their own, not inherited, enumerable properties. Functions and DOM nodes\r\n     * are **not** supported. Provide a customizer function to extend support\r\n     * for comparing other values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias eq\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @param {Function} [customizer] The function to customize value comparisons.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     * var other = { 'user': 'fred' };\r\n     *\r\n     * object == other;\r\n     * // => false\r\n     *\r\n     * _.isEqual(object, other);\r\n     * // => true\r\n     *\r\n     * // using a customizer callback\r\n     * var array = ['hello', 'goodbye'];\r\n     * var other = ['hi', 'goodbye'];\r\n     *\r\n     * _.isEqual(array, other, function(value, other) {\r\n     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {\r\n     *     return true;\r\n     *   }\r\n     * });\r\n     * // => true\r\n     */\r\n    function isEqual(value, other, customizer, thisArg) {\r\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\r\n      var result = customizer ? customizer(value, other) : undefined;\r\n      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\r\n     * `SyntaxError`, `TypeError`, or `URIError` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\r\n     * @example\r\n     *\r\n     * _.isError(new Error);\r\n     * // => true\r\n     *\r\n     * _.isError(Error);\r\n     * // => false\r\n     */\r\n    function isError(value) {\r\n      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a finite primitive number.\r\n     *\r\n     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\r\n     * @example\r\n     *\r\n     * _.isFinite(10);\r\n     * // => true\r\n     *\r\n     * _.isFinite('10');\r\n     * // => false\r\n     *\r\n     * _.isFinite(true);\r\n     * // => false\r\n     *\r\n     * _.isFinite(Object(10));\r\n     * // => false\r\n     *\r\n     * _.isFinite(Infinity);\r\n     * // => false\r\n     */\r\n    function isFinite(value) {\r\n      return typeof value == 'number' && nativeIsFinite(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Function` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isFunction(_);\r\n     * // => true\r\n     *\r\n     * _.isFunction(/abc/);\r\n     * // => false\r\n     */\r\n    function isFunction(value) {\r\n      // The use of `Object#toString` avoids issues with the `typeof` operator\r\n      // in older versions of Chrome and Safari which return 'function' for regexes\r\n      // and Safari 8 equivalents which return 'object' for typed array constructors.\r\n      return isObject(value) && objToString.call(value) == funcTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\r\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n     * @example\r\n     *\r\n     * _.isObject({});\r\n     * // => true\r\n     *\r\n     * _.isObject([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isObject(1);\r\n     * // => false\r\n     */\r\n    function isObject(value) {\r\n      // Avoid a V8 JIT bug in Chrome 19-20.\r\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\r\n      var type = typeof value;\r\n      return !!value && (type == 'object' || type == 'function');\r\n    }\r\n\r\n    /**\r\n     * Performs a deep comparison between `object` and `source` to determine if\r\n     * `object` contains equivalent property values. If `customizer` is provided\r\n     * it is invoked to compare values. If `customizer` returns `undefined`\r\n     * comparisons are handled by the method instead. The `customizer` is bound\r\n     * to `thisArg` and invoked with three arguments: (value, other, index|key).\r\n     *\r\n     * **Note:** This method supports comparing properties of arrays, booleans,\r\n     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\r\n     * and DOM nodes are **not** supported. Provide a customizer function to extend\r\n     * support for comparing other values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property values to match.\r\n     * @param {Function} [customizer] The function to customize value comparisons.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred', 'age': 40 };\r\n     *\r\n     * _.isMatch(object, { 'age': 40 });\r\n     * // => true\r\n     *\r\n     * _.isMatch(object, { 'age': 36 });\r\n     * // => false\r\n     *\r\n     * // using a customizer callback\r\n     * var object = { 'greeting': 'hello' };\r\n     * var source = { 'greeting': 'hi' };\r\n     *\r\n     * _.isMatch(object, source, function(value, other) {\r\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\r\n     * });\r\n     * // => true\r\n     */\r\n    function isMatch(object, source, customizer, thisArg) {\r\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\r\n      return baseIsMatch(object, getMatchData(source), customizer);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `NaN`.\r\n     *\r\n     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\r\n     * which returns `true` for `undefined` and other non-numeric values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNaN(NaN);\r\n     * // => true\r\n     *\r\n     * _.isNaN(new Number(NaN));\r\n     * // => true\r\n     *\r\n     * isNaN(undefined);\r\n     * // => true\r\n     *\r\n     * _.isNaN(undefined);\r\n     * // => false\r\n     */\r\n    function isNaN(value) {\r\n      // An `NaN` primitive is the only value that is not equal to itself.\r\n      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\r\n      return isNumber(value) && value != +value;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a native function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNative(Array.prototype.push);\r\n     * // => true\r\n     *\r\n     * _.isNative(_);\r\n     * // => false\r\n     */\r\n    function isNative(value) {\r\n      if (value == null) {\r\n        return false;\r\n      }\r\n      if (isFunction(value)) {\r\n        return reIsNative.test(fnToString.call(value));\r\n      }\r\n      return isObjectLike(value) && reIsHostCtor.test(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `null`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNull(null);\r\n     * // => true\r\n     *\r\n     * _.isNull(void 0);\r\n     * // => false\r\n     */\r\n    function isNull(value) {\r\n      return value === null;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Number` primitive or object.\r\n     *\r\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\r\n     * as numbers, use the `_.isFinite` method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNumber(8.4);\r\n     * // => true\r\n     *\r\n     * _.isNumber(NaN);\r\n     * // => true\r\n     *\r\n     * _.isNumber('8.4');\r\n     * // => false\r\n     */\r\n    function isNumber(value) {\r\n      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a plain object, that is, an object created by the\r\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\r\n     *\r\n     * **Note:** This method assumes objects created by the `Object` constructor\r\n     * have no inherited enumerable properties.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     * }\r\n     *\r\n     * _.isPlainObject(new Foo);\r\n     * // => false\r\n     *\r\n     * _.isPlainObject([1, 2, 3]);\r\n     * // => false\r\n     *\r\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\r\n     * // => true\r\n     *\r\n     * _.isPlainObject(Object.create(null));\r\n     * // => true\r\n     */\r\n    function isPlainObject(value) {\r\n      var Ctor;\r\n\r\n      // Exit early for non `Object` objects.\r\n      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\r\n          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\r\n        return false;\r\n      }\r\n      // IE < 9 iterates inherited properties before own properties. If the first\r\n      // iterated property is an object's own property then there are no inherited\r\n      // enumerable properties.\r\n      var result;\r\n      // In most environments an object's own properties are iterated before\r\n      // its inherited properties. If the last iterated property is an object's\r\n      // own property then there are no inherited enumerable properties.\r\n      baseForIn(value, function(subValue, key) {\r\n        result = key;\r\n      });\r\n      return result === undefined || hasOwnProperty.call(value, result);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `RegExp` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isRegExp(/abc/);\r\n     * // => true\r\n     *\r\n     * _.isRegExp('/abc/');\r\n     * // => false\r\n     */\r\n    function isRegExp(value) {\r\n      return isObject(value) && objToString.call(value) == regexpTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `String` primitive or object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isString('abc');\r\n     * // => true\r\n     *\r\n     * _.isString(1);\r\n     * // => false\r\n     */\r\n    function isString(value) {\r\n      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a typed array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\r\n     * @example\r\n     *\r\n     * _.isTypedArray(new Uint8Array);\r\n     * // => true\r\n     *\r\n     * _.isTypedArray([]);\r\n     * // => false\r\n     */\r\n    function isTypedArray(value) {\r\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `undefined`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isUndefined(void 0);\r\n     * // => true\r\n     *\r\n     * _.isUndefined(null);\r\n     * // => false\r\n     */\r\n    function isUndefined(value) {\r\n      return value === undefined;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is less than `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\r\n     * @example\r\n     *\r\n     * _.lt(1, 3);\r\n     * // => true\r\n     *\r\n     * _.lt(3, 3);\r\n     * // => false\r\n     *\r\n     * _.lt(3, 1);\r\n     * // => false\r\n     */\r\n    function lt(value, other) {\r\n      return value < other;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is less than or equal to `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\r\n     * @example\r\n     *\r\n     * _.lte(1, 3);\r\n     * // => true\r\n     *\r\n     * _.lte(3, 3);\r\n     * // => true\r\n     *\r\n     * _.lte(3, 1);\r\n     * // => false\r\n     */\r\n    function lte(value, other) {\r\n      return value <= other;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {Array} Returns the converted array.\r\n     * @example\r\n     *\r\n     * (function() {\r\n     *   return _.toArray(arguments).slice(1);\r\n     * }(1, 2, 3));\r\n     * // => [2, 3]\r\n     */\r\n    function toArray(value) {\r\n      var length = value ? getLength(value) : 0;\r\n      if (!isLength(length)) {\r\n        return values(value);\r\n      }\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      return arrayCopy(value);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a plain object flattening inherited enumerable\r\n     * properties of `value` to own properties of the plain object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {Object} Returns the converted plain object.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.assign({ 'a': 1 }, new Foo);\r\n     * // => { 'a': 1, 'b': 2 }\r\n     *\r\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\r\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\r\n     */\r\n    function toPlainObject(value) {\r\n      return baseCopy(value, keysIn(value));\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Recursively merges own enumerable properties of the source object(s), that\r\n     * don't resolve to `undefined` into the destination object. Subsequent sources\r\n     * overwrite property assignments of previous sources. If `customizer` is\r\n     * provided it is invoked to produce the merged values of the destination and\r\n     * source properties. If `customizer` returns `undefined` merging is handled\r\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\r\n     * with five arguments: (objectValue, sourceValue, key, object, source).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\r\n     * };\r\n     *\r\n     * var ages = {\r\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\r\n     * };\r\n     *\r\n     * _.merge(users, ages);\r\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\r\n     *\r\n     * // using a customizer callback\r\n     * var object = {\r\n     *   'fruits': ['apple'],\r\n     *   'vegetables': ['beet']\r\n     * };\r\n     *\r\n     * var other = {\r\n     *   'fruits': ['banana'],\r\n     *   'vegetables': ['carrot']\r\n     * };\r\n     *\r\n     * _.merge(object, other, function(a, b) {\r\n     *   if (_.isArray(a)) {\r\n     *     return a.concat(b);\r\n     *   }\r\n     * });\r\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\r\n     */\r\n    var merge = createAssigner(baseMerge);\r\n\r\n    /**\r\n     * Assigns own enumerable properties of source object(s) to the destination\r\n     * object. Subsequent sources overwrite property assignments of previous sources.\r\n     * If `customizer` is provided it is invoked to produce the assigned values.\r\n     * The `customizer` is bound to `thisArg` and invoked with five arguments:\r\n     * (objectValue, sourceValue, key, object, source).\r\n     *\r\n     * **Note:** This method mutates `object` and is based on\r\n     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias extend\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @param {*} [thisArg] The `this` binding of `customizer`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\r\n     * // => { 'user': 'fred', 'age': 40 }\r\n     *\r\n     * // using a customizer callback\r\n     * var defaults = _.partialRight(_.assign, function(value, other) {\r\n     *   return _.isUndefined(value) ? other : value;\r\n     * });\r\n     *\r\n     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     */\r\n    var assign = createAssigner(function(object, source, customizer) {\r\n      return customizer\r\n        ? assignWith(object, source, customizer)\r\n        : baseAssign(object, source);\r\n    });\r\n\r\n    /**\r\n     * Creates an object that inherits from the given `prototype` object. If a\r\n     * `properties` object is provided its own enumerable properties are assigned\r\n     * to the created object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} prototype The object to inherit from.\r\n     * @param {Object} [properties] The properties to assign to the object.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * function Shape() {\r\n     *   this.x = 0;\r\n     *   this.y = 0;\r\n     * }\r\n     *\r\n     * function Circle() {\r\n     *   Shape.call(this);\r\n     * }\r\n     *\r\n     * Circle.prototype = _.create(Shape.prototype, {\r\n     *   'constructor': Circle\r\n     * });\r\n     *\r\n     * var circle = new Circle;\r\n     * circle instanceof Circle;\r\n     * // => true\r\n     *\r\n     * circle instanceof Shape;\r\n     * // => true\r\n     */\r\n    function create(prototype, properties, guard) {\r\n      var result = baseCreate(prototype);\r\n      if (guard && isIterateeCall(prototype, properties, guard)) {\r\n        properties = undefined;\r\n      }\r\n      return properties ? baseAssign(result, properties) : result;\r\n    }\r\n\r\n    /**\r\n     * Assigns own enumerable properties of source object(s) to the destination\r\n     * object for all destination properties that resolve to `undefined`. Once a\r\n     * property is set, additional values of the same property are ignored.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     */\r\n    var defaults = createDefaults(assign, assignDefaults);\r\n\r\n    /**\r\n     * This method is like `_.defaults` except that it recursively assigns\r\n     * default properties.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\r\n     * // => { 'user': { 'name': 'barney', 'age': 36 } }\r\n     *\r\n     */\r\n    var defaultsDeep = createDefaults(merge, mergeDefaults);\r\n\r\n    /**\r\n     * This method is like `_.find` except that it returns the key of the first\r\n     * element `predicate` returns truthy for instead of the element itself.\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'barney':  { 'age': 36, 'active': true },\r\n     *   'fred':    { 'age': 40, 'active': false },\r\n     *   'pebbles': { 'age': 1,  'active': true }\r\n     * };\r\n     *\r\n     * _.findKey(users, function(chr) {\r\n     *   return chr.age < 40;\r\n     * });\r\n     * // => 'barney' (iteration order is not guaranteed)\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.findKey(users, { 'age': 1, 'active': true });\r\n     * // => 'pebbles'\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.findKey(users, 'active', false);\r\n     * // => 'fred'\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.findKey(users, 'active');\r\n     * // => 'barney'\r\n     */\r\n    var findKey = createFindKey(baseForOwn);\r\n\r\n    /**\r\n     * This method is like `_.findKey` except that it iterates over elements of\r\n     * a collection in the opposite order.\r\n     *\r\n     * If a property name is provided for `predicate` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `predicate` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to search.\r\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'barney':  { 'age': 36, 'active': true },\r\n     *   'fred':    { 'age': 40, 'active': false },\r\n     *   'pebbles': { 'age': 1,  'active': true }\r\n     * };\r\n     *\r\n     * _.findLastKey(users, function(chr) {\r\n     *   return chr.age < 40;\r\n     * });\r\n     * // => returns `pebbles` assuming `_.findKey` returns `barney`\r\n     *\r\n     * // using the `_.matches` callback shorthand\r\n     * _.findLastKey(users, { 'age': 36, 'active': true });\r\n     * // => 'barney'\r\n     *\r\n     * // using the `_.matchesProperty` callback shorthand\r\n     * _.findLastKey(users, 'active', false);\r\n     * // => 'fred'\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.findLastKey(users, 'active');\r\n     * // => 'pebbles'\r\n     */\r\n    var findLastKey = createFindKey(baseForOwnRight);\r\n\r\n    /**\r\n     * Iterates over own and inherited enumerable properties of an object invoking\r\n     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\r\n     * with three arguments: (value, key, object). Iteratee functions may exit\r\n     * iteration early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forIn(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\r\n     */\r\n    var forIn = createForIn(baseFor);\r\n\r\n    /**\r\n     * This method is like `_.forIn` except that it iterates over properties of\r\n     * `object` in the opposite order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forInRight(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\r\n     */\r\n    var forInRight = createForIn(baseForRight);\r\n\r\n    /**\r\n     * Iterates over own enumerable properties of an object invoking `iteratee`\r\n     * for each property. The `iteratee` is bound to `thisArg` and invoked with\r\n     * three arguments: (value, key, object). Iteratee functions may exit iteration\r\n     * early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forOwn(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => logs 'a' and 'b' (iteration order is not guaranteed)\r\n     */\r\n    var forOwn = createForOwn(baseForOwn);\r\n\r\n    /**\r\n     * This method is like `_.forOwn` except that it iterates over properties of\r\n     * `object` in the opposite order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forOwnRight(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'\r\n     */\r\n    var forOwnRight = createForOwn(baseForOwnRight);\r\n\r\n    /**\r\n     * Creates an array of function property names from all enumerable properties,\r\n     * own and inherited, of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias methods\r\n     * @category Object\r\n     * @param {Object} object The object to inspect.\r\n     * @returns {Array} Returns the new array of property names.\r\n     * @example\r\n     *\r\n     * _.functions(_);\r\n     * // => ['after', 'ary', 'assign', ...]\r\n     */\r\n    function functions(object) {\r\n      return baseFunctions(object, keysIn(object));\r\n    }\r\n\r\n    /**\r\n     * Gets the property value at `path` of `object`. If the resolved value is\r\n     * `undefined` the `defaultValue` is used in its place.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\r\n     * @returns {*} Returns the resolved value.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n     *\r\n     * _.get(object, 'a[0].b.c');\r\n     * // => 3\r\n     *\r\n     * _.get(object, ['a', '0', 'b', 'c']);\r\n     * // => 3\r\n     *\r\n     * _.get(object, 'a.b.c', 'default');\r\n     * // => 'default'\r\n     */\r\n    function get(object, path, defaultValue) {\r\n      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');\r\n      return result === undefined ? defaultValue : result;\r\n    }\r\n\r\n    /**\r\n     * Checks if `path` is a direct property.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path to check.\r\n     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': { 'b': { 'c': 3 } } };\r\n     *\r\n     * _.has(object, 'a');\r\n     * // => true\r\n     *\r\n     * _.has(object, 'a.b.c');\r\n     * // => true\r\n     *\r\n     * _.has(object, ['a', 'b', 'c']);\r\n     * // => true\r\n     */\r\n    function has(object, path) {\r\n      if (object == null) {\r\n        return false;\r\n      }\r\n      var result = hasOwnProperty.call(object, path);\r\n      if (!result && !isKey(path)) {\r\n        path = toPath(path);\r\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n        if (object == null) {\r\n          return false;\r\n        }\r\n        path = last(path);\r\n        result = hasOwnProperty.call(object, path);\r\n      }\r\n      return result || (isLength(object.length) && isIndex(path, object.length) &&\r\n        (isArray(object) || isArguments(object)));\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of the inverted keys and values of `object`.\r\n     * If `object` contains duplicate values, subsequent values overwrite property\r\n     * assignments of previous values unless `multiValue` is `true`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to invert.\r\n     * @param {boolean} [multiValue] Allow multiple values per key.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Object} Returns the new inverted object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\r\n     *\r\n     * _.invert(object);\r\n     * // => { '1': 'c', '2': 'b' }\r\n     *\r\n     * // with `multiValue`\r\n     * _.invert(object, true);\r\n     * // => { '1': ['a', 'c'], '2': ['b'] }\r\n     */\r\n    function invert(object, multiValue, guard) {\r\n      if (guard && isIterateeCall(object, multiValue, guard)) {\r\n        multiValue = undefined;\r\n      }\r\n      var index = -1,\r\n          props = keys(object),\r\n          length = props.length,\r\n          result = {};\r\n\r\n      while (++index < length) {\r\n        var key = props[index],\r\n            value = object[key];\r\n\r\n        if (multiValue) {\r\n          if (hasOwnProperty.call(result, value)) {\r\n            result[value].push(key);\r\n          } else {\r\n            result[value] = [key];\r\n          }\r\n        }\r\n        else {\r\n          result[value] = key;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own enumerable property names of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects. See the\r\n     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\r\n     * for more details.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.keys(new Foo);\r\n     * // => ['a', 'b'] (iteration order is not guaranteed)\r\n     *\r\n     * _.keys('hi');\r\n     * // => ['0', '1']\r\n     */\r\n    var keys = !nativeKeys ? shimKeys : function(object) {\r\n      var Ctor = object == null ? undefined : object.constructor;\r\n      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\r\n          (typeof object != 'function' && isArrayLike(object))) {\r\n        return shimKeys(object);\r\n      }\r\n      return isObject(object) ? nativeKeys(object) : [];\r\n    };\r\n\r\n    /**\r\n     * Creates an array of the own and inherited enumerable property names of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.keysIn(new Foo);\r\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\r\n     */\r\n    function keysIn(object) {\r\n      if (object == null) {\r\n        return [];\r\n      }\r\n      if (!isObject(object)) {\r\n        object = Object(object);\r\n      }\r\n      var length = object.length;\r\n      length = (length && isLength(length) &&\r\n        (isArray(object) || isArguments(object)) && length) || 0;\r\n\r\n      var Ctor = object.constructor,\r\n          index = -1,\r\n          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\r\n          result = Array(length),\r\n          skipIndexes = length > 0;\r\n\r\n      while (++index < length) {\r\n        result[index] = (index + '');\r\n      }\r\n      for (var key in object) {\r\n        if (!(skipIndexes && isIndex(key, length)) &&\r\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The opposite of `_.mapValues`; this method creates an object with the\r\n     * same values as `object` and keys generated by running each own enumerable\r\n     * property of `object` through `iteratee`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns the new mapped object.\r\n     * @example\r\n     *\r\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\r\n     *   return key + value;\r\n     * });\r\n     * // => { 'a1': 1, 'b2': 2 }\r\n     */\r\n    var mapKeys = createObjectMapper(true);\r\n\r\n    /**\r\n     * Creates an object with the same keys as `object` and values generated by\r\n     * running each own enumerable property of `object` through `iteratee`. The\r\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\r\n     * (value, key, object).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\r\n     *  per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Object} Returns the new mapped object.\r\n     * @example\r\n     *\r\n     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {\r\n     *   return n * 3;\r\n     * });\r\n     * // => { 'a': 3, 'b': 6 }\r\n     *\r\n     * var users = {\r\n     *   'fred':    { 'user': 'fred',    'age': 40 },\r\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\r\n     * };\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.mapValues(users, 'age');\r\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\r\n     */\r\n    var mapValues = createObjectMapper();\r\n\r\n    /**\r\n     * The opposite of `_.pick`; this method creates an object composed of the\r\n     * own and inherited enumerable properties of `object` that are not omitted.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\r\n     *  iteration or property names to omit, specified as individual property\r\n     *  names or arrays of property names.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred', 'age': 40 };\r\n     *\r\n     * _.omit(object, 'age');\r\n     * // => { 'user': 'fred' }\r\n     *\r\n     * _.omit(object, _.isNumber);\r\n     * // => { 'user': 'fred' }\r\n     */\r\n    var omit = restParam(function(object, props) {\r\n      if (object == null) {\r\n        return {};\r\n      }\r\n      if (typeof props[0] != 'function') {\r\n        var props = arrayMap(baseFlatten(props), String);\r\n        return pickByArray(object, baseDifference(keysIn(object), props));\r\n      }\r\n      var predicate = bindCallback(props[0], props[1], 3);\r\n      return pickByCallback(object, function(value, key, object) {\r\n        return !predicate(value, key, object);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * Creates a two dimensional array of the key-value pairs for `object`,\r\n     * e.g. `[[key1, value1], [key2, value2]]`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the new array of key-value pairs.\r\n     * @example\r\n     *\r\n     * _.pairs({ 'barney': 36, 'fred': 40 });\r\n     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\r\n     */\r\n    function pairs(object) {\r\n      object = toObject(object);\r\n\r\n      var index = -1,\r\n          props = keys(object),\r\n          length = props.length,\r\n          result = Array(length);\r\n\r\n      while (++index < length) {\r\n        var key = props[index];\r\n        result[index] = [key, object[key]];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of the picked `object` properties. Property\r\n     * names may be specified as individual arguments or as arrays of property\r\n     * names. If `predicate` is provided it is invoked for each property of `object`\r\n     * picking the properties `predicate` returns truthy for. The predicate is\r\n     * bound to `thisArg` and invoked with three arguments: (value, key, object).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\r\n     *  iteration or property names to pick, specified as individual property\r\n     *  names or arrays of property names.\r\n     * @param {*} [thisArg] The `this` binding of `predicate`.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred', 'age': 40 };\r\n     *\r\n     * _.pick(object, 'user');\r\n     * // => { 'user': 'fred' }\r\n     *\r\n     * _.pick(object, _.isString);\r\n     * // => { 'user': 'fred' }\r\n     */\r\n    var pick = restParam(function(object, props) {\r\n      if (object == null) {\r\n        return {};\r\n      }\r\n      return typeof props[0] == 'function'\r\n        ? pickByCallback(object, bindCallback(props[0], props[1], 3))\r\n        : pickByArray(object, baseFlatten(props));\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.get` except that if the resolved value is a function\r\n     * it is invoked with the `this` binding of its parent object and its result\r\n     * is returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the property to resolve.\r\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\r\n     * @returns {*} Returns the resolved value.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\r\n     *\r\n     * _.result(object, 'a[0].b.c1');\r\n     * // => 3\r\n     *\r\n     * _.result(object, 'a[0].b.c2');\r\n     * // => 4\r\n     *\r\n     * _.result(object, 'a.b.c', 'default');\r\n     * // => 'default'\r\n     *\r\n     * _.result(object, 'a.b.c', _.constant('default'));\r\n     * // => 'default'\r\n     */\r\n    function result(object, path, defaultValue) {\r\n      var result = object == null ? undefined : object[path];\r\n      if (result === undefined) {\r\n        if (object != null && !isKey(path, object)) {\r\n          path = toPath(path);\r\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n          result = object == null ? undefined : object[last(path)];\r\n        }\r\n        result = result === undefined ? defaultValue : result;\r\n      }\r\n      return isFunction(result) ? result.call(object) : result;\r\n    }\r\n\r\n    /**\r\n     * Sets the property value of `path` on `object`. If a portion of `path`\r\n     * does not exist it is created.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to augment.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n     *\r\n     * _.set(object, 'a[0].b.c', 4);\r\n     * console.log(object.a[0].b.c);\r\n     * // => 4\r\n     *\r\n     * _.set(object, 'x[0].y.z', 5);\r\n     * console.log(object.x[0].y.z);\r\n     * // => 5\r\n     */\r\n    function set(object, path, value) {\r\n      if (object == null) {\r\n        return object;\r\n      }\r\n      var pathKey = (path + '');\r\n      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\r\n\r\n      var index = -1,\r\n          length = path.length,\r\n          lastIndex = length - 1,\r\n          nested = object;\r\n\r\n      while (nested != null && ++index < length) {\r\n        var key = path[index];\r\n        if (isObject(nested)) {\r\n          if (index == lastIndex) {\r\n            nested[key] = value;\r\n          } else if (nested[key] == null) {\r\n            nested[key] = isIndex(path[index + 1]) ? [] : {};\r\n          }\r\n        }\r\n        nested = nested[key];\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * An alternative to `_.reduce`; this method transforms `object` to a new\r\n     * `accumulator` object which is the result of running each of its own enumerable\r\n     * properties through `iteratee`, with each invocation potentially mutating\r\n     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\r\n     * with four arguments: (accumulator, value, key, object). Iteratee functions\r\n     * may exit iteration early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Array|Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The custom accumulator value.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @example\r\n     *\r\n     * _.transform([2, 3, 4], function(result, n) {\r\n     *   result.push(n *= n);\r\n     *   return n % 2 == 0;\r\n     * });\r\n     * // => [4, 9]\r\n     *\r\n     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\r\n     *   result[key] = n * 3;\r\n     * });\r\n     * // => { 'a': 3, 'b': 6 }\r\n     */\r\n    function transform(object, iteratee, accumulator, thisArg) {\r\n      var isArr = isArray(object) || isTypedArray(object);\r\n      iteratee = getCallback(iteratee, thisArg, 4);\r\n\r\n      if (accumulator == null) {\r\n        if (isArr || isObject(object)) {\r\n          var Ctor = object.constructor;\r\n          if (isArr) {\r\n            accumulator = isArray(object) ? new Ctor : [];\r\n          } else {\r\n            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\r\n          }\r\n        } else {\r\n          accumulator = {};\r\n        }\r\n      }\r\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\r\n        return iteratee(accumulator, value, index, object);\r\n      });\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own enumerable property values of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property values.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.values(new Foo);\r\n     * // => [1, 2] (iteration order is not guaranteed)\r\n     *\r\n     * _.values('hi');\r\n     * // => ['h', 'i']\r\n     */\r\n    function values(object) {\r\n      return baseValues(object, keys(object));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own and inherited enumerable property values\r\n     * of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property values.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.valuesIn(new Foo);\r\n     * // => [1, 2, 3] (iteration order is not guaranteed)\r\n     */\r\n    function valuesIn(object) {\r\n      return baseValues(object, keysIn(object));\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Checks if `n` is between `start` and up to but not including, `end`. If\r\n     * `end` is not specified it is set to `start` with `start` then set to `0`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Number\r\n     * @param {number} n The number to check.\r\n     * @param {number} [start=0] The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\r\n     * @example\r\n     *\r\n     * _.inRange(3, 2, 4);\r\n     * // => true\r\n     *\r\n     * _.inRange(4, 8);\r\n     * // => true\r\n     *\r\n     * _.inRange(4, 2);\r\n     * // => false\r\n     *\r\n     * _.inRange(2, 2);\r\n     * // => false\r\n     *\r\n     * _.inRange(1.2, 2);\r\n     * // => true\r\n     *\r\n     * _.inRange(5.2, 4);\r\n     * // => false\r\n     */\r\n    function inRange(value, start, end) {\r\n      start = +start || 0;\r\n      if (end === undefined) {\r\n        end = start;\r\n        start = 0;\r\n      } else {\r\n        end = +end || 0;\r\n      }\r\n      return value >= nativeMin(start, end) && value < nativeMax(start, end);\r\n    }\r\n\r\n    /**\r\n     * Produces a random number between `min` and `max` (inclusive). If only one\r\n     * argument is provided a number between `0` and the given number is returned.\r\n     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\r\n     * number is returned instead of an integer.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Number\r\n     * @param {number} [min=0] The minimum possible value.\r\n     * @param {number} [max=1] The maximum possible value.\r\n     * @param {boolean} [floating] Specify returning a floating-point number.\r\n     * @returns {number} Returns the random number.\r\n     * @example\r\n     *\r\n     * _.random(0, 5);\r\n     * // => an integer between 0 and 5\r\n     *\r\n     * _.random(5);\r\n     * // => also an integer between 0 and 5\r\n     *\r\n     * _.random(5, true);\r\n     * // => a floating-point number between 0 and 5\r\n     *\r\n     * _.random(1.2, 5.2);\r\n     * // => a floating-point number between 1.2 and 5.2\r\n     */\r\n    function random(min, max, floating) {\r\n      if (floating && isIterateeCall(min, max, floating)) {\r\n        max = floating = undefined;\r\n      }\r\n      var noMin = min == null,\r\n          noMax = max == null;\r\n\r\n      if (floating == null) {\r\n        if (noMax && typeof min == 'boolean') {\r\n          floating = min;\r\n          min = 1;\r\n        }\r\n        else if (typeof max == 'boolean') {\r\n          floating = max;\r\n          noMax = true;\r\n        }\r\n      }\r\n      if (noMin && noMax) {\r\n        max = 1;\r\n        noMax = false;\r\n      }\r\n      min = +min || 0;\r\n      if (noMax) {\r\n        max = min;\r\n        min = 0;\r\n      } else {\r\n        max = +max || 0;\r\n      }\r\n      if (floating || min % 1 || max % 1) {\r\n        var rand = nativeRandom();\r\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\r\n      }\r\n      return baseRandom(min, max);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the camel cased string.\r\n     * @example\r\n     *\r\n     * _.camelCase('Foo Bar');\r\n     * // => 'fooBar'\r\n     *\r\n     * _.camelCase('--foo-bar');\r\n     * // => 'fooBar'\r\n     *\r\n     * _.camelCase('__foo_bar__');\r\n     * // => 'fooBar'\r\n     */\r\n    var camelCase = createCompounder(function(result, word, index) {\r\n      word = word.toLowerCase();\r\n      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\r\n    });\r\n\r\n    /**\r\n     * Capitalizes the first character of `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to capitalize.\r\n     * @returns {string} Returns the capitalized string.\r\n     * @example\r\n     *\r\n     * _.capitalize('fred');\r\n     * // => 'Fred'\r\n     */\r\n    function capitalize(string) {\r\n      string = baseToString(string);\r\n      return string && (string.charAt(0).toUpperCase() + string.slice(1));\r\n    }\r\n\r\n    /**\r\n     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\r\n     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to deburr.\r\n     * @returns {string} Returns the deburred string.\r\n     * @example\r\n     *\r\n     * _.deburr('dj vu');\r\n     * // => 'deja vu'\r\n     */\r\n    function deburr(string) {\r\n      string = baseToString(string);\r\n      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\r\n    }\r\n\r\n    /**\r\n     * Checks if `string` ends with the given target string.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to search.\r\n     * @param {string} [target] The string to search for.\r\n     * @param {number} [position=string.length] The position to search from.\r\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\r\n     * @example\r\n     *\r\n     * _.endsWith('abc', 'c');\r\n     * // => true\r\n     *\r\n     * _.endsWith('abc', 'b');\r\n     * // => false\r\n     *\r\n     * _.endsWith('abc', 'b', 2);\r\n     * // => true\r\n     */\r\n    function endsWith(string, target, position) {\r\n      string = baseToString(string);\r\n      target = (target + '');\r\n\r\n      var length = string.length;\r\n      position = position === undefined\r\n        ? length\r\n        : nativeMin(position < 0 ? 0 : (+position || 0), length);\r\n\r\n      position -= target.length;\r\n      return position >= 0 && string.indexOf(target, position) == position;\r\n    }\r\n\r\n    /**\r\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\r\n     * their corresponding HTML entities.\r\n     *\r\n     * **Note:** No other characters are escaped. To escape additional characters\r\n     * use a third-party library like [_he_](https://mths.be/he).\r\n     *\r\n     * Though the \">\" character is escaped for symmetry, characters like\r\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\r\n     * unless they're part of a tag or unquoted attribute value.\r\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\r\n     * (under \"semi-related fun fact\") for more details.\r\n     *\r\n     * Backticks are escaped because in Internet Explorer < 9, they can break out\r\n     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\r\n     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\r\n     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\r\n     * for more details.\r\n     *\r\n     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\r\n     * to reduce XSS vectors.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to escape.\r\n     * @returns {string} Returns the escaped string.\r\n     * @example\r\n     *\r\n     * _.escape('fred, barney, & pebbles');\r\n     * // => 'fred, barney, &amp; pebbles'\r\n     */\r\n    function escape(string) {\r\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\r\n      string = baseToString(string);\r\n      return (string && reHasUnescapedHtml.test(string))\r\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\r\n     * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to escape.\r\n     * @returns {string} Returns the escaped string.\r\n     * @example\r\n     *\r\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\r\n     * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\r\n     */\r\n    function escapeRegExp(string) {\r\n      string = baseToString(string);\r\n      return (string && reHasRegExpChars.test(string))\r\n        ? string.replace(reRegExpChars, escapeRegExpChar)\r\n        : (string || '(?:)');\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the kebab cased string.\r\n     * @example\r\n     *\r\n     * _.kebabCase('Foo Bar');\r\n     * // => 'foo-bar'\r\n     *\r\n     * _.kebabCase('fooBar');\r\n     * // => 'foo-bar'\r\n     *\r\n     * _.kebabCase('__foo_bar__');\r\n     * // => 'foo-bar'\r\n     */\r\n    var kebabCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? '-' : '') + word.toLowerCase();\r\n    });\r\n\r\n    /**\r\n     * Pads `string` on the left and right sides if it's shorter than `length`.\r\n     * Padding characters are truncated if they can't be evenly divided by `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.pad('abc', 8);\r\n     * // => '  abc   '\r\n     *\r\n     * _.pad('abc', 8, '_-');\r\n     * // => '_-abc_-_'\r\n     *\r\n     * _.pad('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    function pad(string, length, chars) {\r\n      string = baseToString(string);\r\n      length = +length;\r\n\r\n      var strLength = string.length;\r\n      if (strLength >= length || !nativeIsFinite(length)) {\r\n        return string;\r\n      }\r\n      var mid = (length - strLength) / 2,\r\n          leftLength = nativeFloor(mid),\r\n          rightLength = nativeCeil(mid);\r\n\r\n      chars = createPadding('', rightLength, chars);\r\n      return chars.slice(0, leftLength) + string + chars;\r\n    }\r\n\r\n    /**\r\n     * Pads `string` on the left side if it's shorter than `length`. Padding\r\n     * characters are truncated if they exceed `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.padLeft('abc', 6);\r\n     * // => '   abc'\r\n     *\r\n     * _.padLeft('abc', 6, '_-');\r\n     * // => '_-_abc'\r\n     *\r\n     * _.padLeft('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    var padLeft = createPadDir();\r\n\r\n    /**\r\n     * Pads `string` on the right side if it's shorter than `length`. Padding\r\n     * characters are truncated if they exceed `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.padRight('abc', 6);\r\n     * // => 'abc   '\r\n     *\r\n     * _.padRight('abc', 6, '_-');\r\n     * // => 'abc_-_'\r\n     *\r\n     * _.padRight('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    var padRight = createPadDir(true);\r\n\r\n    /**\r\n     * Converts `string` to an integer of the specified radix. If `radix` is\r\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\r\n     * in which case a `radix` of `16` is used.\r\n     *\r\n     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\r\n     * of `parseInt`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} string The string to convert.\r\n     * @param {number} [radix] The radix to interpret `value` by.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.parseInt('08');\r\n     * // => 8\r\n     *\r\n     * _.map(['6', '08', '10'], _.parseInt);\r\n     * // => [6, 8, 10]\r\n     */\r\n    function parseInt(string, radix, guard) {\r\n      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\r\n      // Chrome fails to trim leading <BOM> whitespace characters.\r\n      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\r\n      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\r\n        radix = 0;\r\n      } else if (radix) {\r\n        radix = +radix;\r\n      }\r\n      string = trim(string);\r\n      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\r\n    }\r\n\r\n    /**\r\n     * Repeats the given string `n` times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to repeat.\r\n     * @param {number} [n=0] The number of times to repeat the string.\r\n     * @returns {string} Returns the repeated string.\r\n     * @example\r\n     *\r\n     * _.repeat('*', 3);\r\n     * // => '***'\r\n     *\r\n     * _.repeat('abc', 2);\r\n     * // => 'abcabc'\r\n     *\r\n     * _.repeat('abc', 0);\r\n     * // => ''\r\n     */\r\n    function repeat(string, n) {\r\n      var result = '';\r\n      string = baseToString(string);\r\n      n = +n;\r\n      if (n < 1 || !string || !nativeIsFinite(n)) {\r\n        return result;\r\n      }\r\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\r\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\r\n      do {\r\n        if (n % 2) {\r\n          result += string;\r\n        }\r\n        n = nativeFloor(n / 2);\r\n        string += string;\r\n      } while (n);\r\n\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the snake cased string.\r\n     * @example\r\n     *\r\n     * _.snakeCase('Foo Bar');\r\n     * // => 'foo_bar'\r\n     *\r\n     * _.snakeCase('fooBar');\r\n     * // => 'foo_bar'\r\n     *\r\n     * _.snakeCase('--foo-bar');\r\n     * // => 'foo_bar'\r\n     */\r\n    var snakeCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? '_' : '') + word.toLowerCase();\r\n    });\r\n\r\n    /**\r\n     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the start cased string.\r\n     * @example\r\n     *\r\n     * _.startCase('--foo-bar');\r\n     * // => 'Foo Bar'\r\n     *\r\n     * _.startCase('fooBar');\r\n     * // => 'Foo Bar'\r\n     *\r\n     * _.startCase('__foo_bar__');\r\n     * // => 'Foo Bar'\r\n     */\r\n    var startCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\r\n    });\r\n\r\n    /**\r\n     * Checks if `string` starts with the given target string.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to search.\r\n     * @param {string} [target] The string to search for.\r\n     * @param {number} [position=0] The position to search from.\r\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\r\n     * @example\r\n     *\r\n     * _.startsWith('abc', 'a');\r\n     * // => true\r\n     *\r\n     * _.startsWith('abc', 'b');\r\n     * // => false\r\n     *\r\n     * _.startsWith('abc', 'b', 1);\r\n     * // => true\r\n     */\r\n    function startsWith(string, target, position) {\r\n      string = baseToString(string);\r\n      position = position == null\r\n        ? 0\r\n        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\r\n\r\n      return string.lastIndexOf(target, position) == position;\r\n    }\r\n\r\n    /**\r\n     * Creates a compiled template function that can interpolate data properties\r\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\r\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\r\n     * properties may be accessed as free variables in the template. If a setting\r\n     * object is provided it takes precedence over `_.templateSettings` values.\r\n     *\r\n     * **Note:** In the development build `_.template` utilizes\r\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\r\n     * for easier debugging.\r\n     *\r\n     * For more information on precompiling templates see\r\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\r\n     *\r\n     * For more information on Chrome extension sandboxes see\r\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The template string.\r\n     * @param {Object} [options] The options object.\r\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\r\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\r\n     * @param {Object} [options.imports] An object to import into the template as free variables.\r\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\r\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\r\n     * @param {string} [options.variable] The data object variable name.\r\n     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\r\n     * @returns {Function} Returns the compiled template function.\r\n     * @example\r\n     *\r\n     * // using the \"interpolate\" delimiter to create a compiled template\r\n     * var compiled = _.template('hello <%= user %>!');\r\n     * compiled({ 'user': 'fred' });\r\n     * // => 'hello fred!'\r\n     *\r\n     * // using the HTML \"escape\" delimiter to escape data property values\r\n     * var compiled = _.template('<b><%- value %></b>');\r\n     * compiled({ 'value': '<script>' });\r\n     * // => '<b>&lt;script&gt;</b>'\r\n     *\r\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\r\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\r\n     * compiled({ 'users': ['fred', 'barney'] });\r\n     * // => '<li>fred</li><li>barney</li>'\r\n     *\r\n     * // using the internal `print` function in \"evaluate\" delimiters\r\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\r\n     * compiled({ 'user': 'barney' });\r\n     * // => 'hello barney!'\r\n     *\r\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\r\n     * var compiled = _.template('hello ${ user }!');\r\n     * compiled({ 'user': 'pebbles' });\r\n     * // => 'hello pebbles!'\r\n     *\r\n     * // using custom template delimiters\r\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\r\n     * var compiled = _.template('hello {{ user }}!');\r\n     * compiled({ 'user': 'mustache' });\r\n     * // => 'hello mustache!'\r\n     *\r\n     * // using backslashes to treat delimiters as plain text\r\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\r\n     * compiled({ 'value': 'ignored' });\r\n     * // => '<%- value %>'\r\n     *\r\n     * // using the `imports` option to import `jQuery` as `jq`\r\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\r\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\r\n     * compiled({ 'users': ['fred', 'barney'] });\r\n     * // => '<li>fred</li><li>barney</li>'\r\n     *\r\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\r\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\r\n     * compiled(data);\r\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\r\n     *\r\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\r\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\r\n     * compiled.source;\r\n     * // => function(data) {\r\n     * //   var __t, __p = '';\r\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\r\n     * //   return __p;\r\n     * // }\r\n     *\r\n     * // using the `source` property to inline compiled templates for meaningful\r\n     * // line numbers in error messages and a stack trace\r\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\r\n     *   var JST = {\\\r\n     *     \"main\": ' + _.template(mainText).source + '\\\r\n     *   };\\\r\n     * ');\r\n     */\r\n    function template(string, options, otherOptions) {\r\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\r\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\r\n      var settings = lodash.templateSettings;\r\n\r\n      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\r\n        options = otherOptions = undefined;\r\n      }\r\n      string = baseToString(string);\r\n      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\r\n\r\n      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\r\n          importsKeys = keys(imports),\r\n          importsValues = baseValues(imports, importsKeys);\r\n\r\n      var isEscaping,\r\n          isEvaluating,\r\n          index = 0,\r\n          interpolate = options.interpolate || reNoMatch,\r\n          source = \"__p += '\";\r\n\r\n      // Compile the regexp to match each delimiter.\r\n      var reDelimiters = RegExp(\r\n        (options.escape || reNoMatch).source + '|' +\r\n        interpolate.source + '|' +\r\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\r\n        (options.evaluate || reNoMatch).source + '|$'\r\n      , 'g');\r\n\r\n      // Use a sourceURL for easier debugging.\r\n      var sourceURL = '//# sourceURL=' +\r\n        ('sourceURL' in options\r\n          ? options.sourceURL\r\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\r\n        ) + '\\n';\r\n\r\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\r\n        interpolateValue || (interpolateValue = esTemplateValue);\r\n\r\n        // Escape characters that can't be included in string literals.\r\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\r\n\r\n        // Replace delimiters with snippets.\r\n        if (escapeValue) {\r\n          isEscaping = true;\r\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\r\n        }\r\n        if (evaluateValue) {\r\n          isEvaluating = true;\r\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\r\n        }\r\n        if (interpolateValue) {\r\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\r\n        }\r\n        index = offset + match.length;\r\n\r\n        // The JS engine embedded in Adobe products requires returning the `match`\r\n        // string in order to produce the correct `offset` value.\r\n        return match;\r\n      });\r\n\r\n      source += \"';\\n\";\r\n\r\n      // If `variable` is not specified wrap a with-statement around the generated\r\n      // code to add the data object to the top of the scope chain.\r\n      var variable = options.variable;\r\n      if (!variable) {\r\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\r\n      }\r\n      // Cleanup code by stripping empty strings.\r\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\r\n        .replace(reEmptyStringMiddle, '$1')\r\n        .replace(reEmptyStringTrailing, '$1;');\r\n\r\n      // Frame code as the function body.\r\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\r\n        (variable\r\n          ? ''\r\n          : 'obj || (obj = {});\\n'\r\n        ) +\r\n        \"var __t, __p = ''\" +\r\n        (isEscaping\r\n           ? ', __e = _.escape'\r\n           : ''\r\n        ) +\r\n        (isEvaluating\r\n          ? ', __j = Array.prototype.join;\\n' +\r\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\r\n          : ';\\n'\r\n        ) +\r\n        source +\r\n        'return __p\\n}';\r\n\r\n      var result = attempt(function() {\r\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\r\n      });\r\n\r\n      // Provide the compiled function's source by its `toString` method or\r\n      // the `source` property as a convenience for inlining compiled templates.\r\n      result.source = source;\r\n      if (isError(result)) {\r\n        throw result;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Removes leading and trailing whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trim('  abc  ');\r\n     * // => 'abc'\r\n     *\r\n     * _.trim('-_-abc-_-', '_-');\r\n     * // => 'abc'\r\n     *\r\n     * _.map(['  foo  ', '  bar  '], _.trim);\r\n     * // => ['foo', 'bar']\r\n     */\r\n    function trim(string, chars, guard) {\r\n      var value = string;\r\n      string = baseToString(string);\r\n      if (!string) {\r\n        return string;\r\n      }\r\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\r\n        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\r\n      }\r\n      chars = (chars + '');\r\n      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\r\n    }\r\n\r\n    /**\r\n     * Removes leading whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trimLeft('  abc  ');\r\n     * // => 'abc  '\r\n     *\r\n     * _.trimLeft('-_-abc-_-', '_-');\r\n     * // => 'abc-_-'\r\n     */\r\n    function trimLeft(string, chars, guard) {\r\n      var value = string;\r\n      string = baseToString(string);\r\n      if (!string) {\r\n        return string;\r\n      }\r\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\r\n        return string.slice(trimmedLeftIndex(string));\r\n      }\r\n      return string.slice(charsLeftIndex(string, (chars + '')));\r\n    }\r\n\r\n    /**\r\n     * Removes trailing whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trimRight('  abc  ');\r\n     * // => '  abc'\r\n     *\r\n     * _.trimRight('-_-abc-_-', '_-');\r\n     * // => '-_-abc'\r\n     */\r\n    function trimRight(string, chars, guard) {\r\n      var value = string;\r\n      string = baseToString(string);\r\n      if (!string) {\r\n        return string;\r\n      }\r\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\r\n        return string.slice(0, trimmedRightIndex(string) + 1);\r\n      }\r\n      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\r\n    }\r\n\r\n    /**\r\n     * Truncates `string` if it's longer than the given maximum string length.\r\n     * The last characters of the truncated string are replaced with the omission\r\n     * string which defaults to \"...\".\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to truncate.\r\n     * @param {Object|number} [options] The options object or maximum string length.\r\n     * @param {number} [options.length=30] The maximum string length.\r\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\r\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {string} Returns the truncated string.\r\n     * @example\r\n     *\r\n     * _.trunc('hi-diddly-ho there, neighborino');\r\n     * // => 'hi-diddly-ho there, neighbo...'\r\n     *\r\n     * _.trunc('hi-diddly-ho there, neighborino', 24);\r\n     * // => 'hi-diddly-ho there, n...'\r\n     *\r\n     * _.trunc('hi-diddly-ho there, neighborino', {\r\n     *   'length': 24,\r\n     *   'separator': ' '\r\n     * });\r\n     * // => 'hi-diddly-ho there,...'\r\n     *\r\n     * _.trunc('hi-diddly-ho there, neighborino', {\r\n     *   'length': 24,\r\n     *   'separator': /,? +/\r\n     * });\r\n     * // => 'hi-diddly-ho there...'\r\n     *\r\n     * _.trunc('hi-diddly-ho there, neighborino', {\r\n     *   'omission': ' [...]'\r\n     * });\r\n     * // => 'hi-diddly-ho there, neig [...]'\r\n     */\r\n    function trunc(string, options, guard) {\r\n      if (guard && isIterateeCall(string, options, guard)) {\r\n        options = undefined;\r\n      }\r\n      var length = DEFAULT_TRUNC_LENGTH,\r\n          omission = DEFAULT_TRUNC_OMISSION;\r\n\r\n      if (options != null) {\r\n        if (isObject(options)) {\r\n          var separator = 'separator' in options ? options.separator : separator;\r\n          length = 'length' in options ? (+options.length || 0) : length;\r\n          omission = 'omission' in options ? baseToString(options.omission) : omission;\r\n        } else {\r\n          length = +options || 0;\r\n        }\r\n      }\r\n      string = baseToString(string);\r\n      if (length >= string.length) {\r\n        return string;\r\n      }\r\n      var end = length - omission.length;\r\n      if (end < 1) {\r\n        return omission;\r\n      }\r\n      var result = string.slice(0, end);\r\n      if (separator == null) {\r\n        return result + omission;\r\n      }\r\n      if (isRegExp(separator)) {\r\n        if (string.slice(end).search(separator)) {\r\n          var match,\r\n              newEnd,\r\n              substring = string.slice(0, end);\r\n\r\n          if (!separator.global) {\r\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\r\n          }\r\n          separator.lastIndex = 0;\r\n          while ((match = separator.exec(substring))) {\r\n            newEnd = match.index;\r\n          }\r\n          result = result.slice(0, newEnd == null ? end : newEnd);\r\n        }\r\n      } else if (string.indexOf(separator, end) != end) {\r\n        var index = result.lastIndexOf(separator);\r\n        if (index > -1) {\r\n          result = result.slice(0, index);\r\n        }\r\n      }\r\n      return result + omission;\r\n    }\r\n\r\n    /**\r\n     * The inverse of `_.escape`; this method converts the HTML entities\r\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\r\n     * corresponding characters.\r\n     *\r\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\r\n     * entities use a third-party library like [_he_](https://mths.be/he).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to unescape.\r\n     * @returns {string} Returns the unescaped string.\r\n     * @example\r\n     *\r\n     * _.unescape('fred, barney, &amp; pebbles');\r\n     * // => 'fred, barney, & pebbles'\r\n     */\r\n    function unescape(string) {\r\n      string = baseToString(string);\r\n      return (string && reHasEscapedHtml.test(string))\r\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Splits `string` into an array of its words.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to inspect.\r\n     * @param {RegExp|string} [pattern] The pattern to match words.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Array} Returns the words of `string`.\r\n     * @example\r\n     *\r\n     * _.words('fred, barney, & pebbles');\r\n     * // => ['fred', 'barney', 'pebbles']\r\n     *\r\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\r\n     * // => ['fred', 'barney', '&', 'pebbles']\r\n     */\r\n    function words(string, pattern, guard) {\r\n      if (guard && isIterateeCall(string, pattern, guard)) {\r\n        pattern = undefined;\r\n      }\r\n      string = baseToString(string);\r\n      return string.match(pattern || reWords) || [];\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Attempts to invoke `func`, returning either the result or the caught error\r\n     * object. Any additional arguments are provided to `func` when it is invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Function} func The function to attempt.\r\n     * @returns {*} Returns the `func` result or error object.\r\n     * @example\r\n     *\r\n     * // avoid throwing errors for invalid selectors\r\n     * var elements = _.attempt(function(selector) {\r\n     *   return document.querySelectorAll(selector);\r\n     * }, '>_>');\r\n     *\r\n     * if (_.isError(elements)) {\r\n     *   elements = [];\r\n     * }\r\n     */\r\n    var attempt = restParam(function(func, args) {\r\n      try {\r\n        return func.apply(undefined, args);\r\n      } catch(e) {\r\n        return isError(e) ? e : new Error(e);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\r\n     * and arguments of the created function. If `func` is a property name the\r\n     * created callback returns the property value for a given element. If `func`\r\n     * is an object the created callback returns `true` for elements that contain\r\n     * the equivalent object properties, otherwise it returns `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @alias iteratee\r\n     * @category Utility\r\n     * @param {*} [func=_.identity] The value to convert to a callback.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\r\n     * @returns {Function} Returns the callback.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * // wrap to create custom callback shorthands\r\n     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\r\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\r\n     *   if (!match) {\r\n     *     return callback(func, thisArg);\r\n     *   }\r\n     *   return function(object) {\r\n     *     return match[2] == 'gt'\r\n     *       ? object[match[1]] > match[3]\r\n     *       : object[match[1]] < match[3];\r\n     *   };\r\n     * });\r\n     *\r\n     * _.filter(users, 'age__gt36');\r\n     * // => [{ 'user': 'fred', 'age': 40 }]\r\n     */\r\n    function callback(func, thisArg, guard) {\r\n      if (guard && isIterateeCall(func, thisArg, guard)) {\r\n        thisArg = undefined;\r\n      }\r\n      return isObjectLike(func)\r\n        ? matches(func)\r\n        : baseCallback(func, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that returns `value`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {*} value The value to return from the new function.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     * var getter = _.constant(object);\r\n     *\r\n     * getter() === object;\r\n     * // => true\r\n     */\r\n    function constant(value) {\r\n      return function() {\r\n        return value;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * This method returns the first argument provided to it.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {*} value Any value.\r\n     * @returns {*} Returns `value`.\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     *\r\n     * _.identity(object) === object;\r\n     * // => true\r\n     */\r\n    function identity(value) {\r\n      return value;\r\n    }\r\n\r\n    /**\r\n     * Creates a function that performs a deep comparison between a given object\r\n     * and `source`, returning `true` if the given object has equivalent property\r\n     * values, else `false`.\r\n     *\r\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\r\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\r\n     * their own, not inherited, enumerable properties. For comparing a single\r\n     * own or inherited property value see `_.matchesProperty`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': true },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\r\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\r\n     */\r\n    function matches(source) {\r\n      return baseMatches(baseClone(source, true));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that compares the property value of `path` on a given\r\n     * object to `value`.\r\n     *\r\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\r\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\r\n     * their own, not inherited, enumerable properties.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @param {*} srcValue The value to match.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney' },\r\n     *   { 'user': 'fred' }\r\n     * ];\r\n     *\r\n     * _.find(users, _.matchesProperty('user', 'fred'));\r\n     * // => { 'user': 'fred' }\r\n     */\r\n    function matchesProperty(path, srcValue) {\r\n      return baseMatchesProperty(path, baseClone(srcValue, true));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes the method at `path` on a given object.\r\n     * Any additional arguments are provided to the invoked method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Array|string} path The path of the method to invoke.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': { 'b': { 'c': _.constant(2) } } },\r\n     *   { 'a': { 'b': { 'c': _.constant(1) } } }\r\n     * ];\r\n     *\r\n     * _.map(objects, _.method('a.b.c'));\r\n     * // => [2, 1]\r\n     *\r\n     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\r\n     * // => [1, 2]\r\n     */\r\n    var method = restParam(function(path, args) {\r\n      return function(object) {\r\n        return invokePath(object, path, args);\r\n      };\r\n    });\r\n\r\n    /**\r\n     * The opposite of `_.method`; this method creates a function that invokes\r\n     * the method at a given path on `object`. Any additional arguments are\r\n     * provided to the invoked method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Object} object The object to query.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var array = _.times(3, _.constant),\r\n     *     object = { 'a': array, 'b': array, 'c': array };\r\n     *\r\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\r\n     * // => [2, 0]\r\n     *\r\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\r\n     * // => [2, 0]\r\n     */\r\n    var methodOf = restParam(function(object, args) {\r\n      return function(path) {\r\n        return invokePath(object, path, args);\r\n      };\r\n    });\r\n\r\n    /**\r\n     * Adds all own enumerable function properties of a source object to the\r\n     * destination object. If `object` is a function then methods are added to\r\n     * its prototype as well.\r\n     *\r\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\r\n     * avoid conflicts caused by modifying the original.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Function|Object} [object=lodash] The destination object.\r\n     * @param {Object} source The object of functions to add.\r\n     * @param {Object} [options] The options object.\r\n     * @param {boolean} [options.chain=true] Specify whether the functions added\r\n     *  are chainable.\r\n     * @returns {Function|Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function vowels(string) {\r\n     *   return _.filter(string, function(v) {\r\n     *     return /[aeiou]/i.test(v);\r\n     *   });\r\n     * }\r\n     *\r\n     * _.mixin({ 'vowels': vowels });\r\n     * _.vowels('fred');\r\n     * // => ['e']\r\n     *\r\n     * _('fred').vowels().value();\r\n     * // => ['e']\r\n     *\r\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\r\n     * _('fred').vowels();\r\n     * // => ['e']\r\n     */\r\n    function mixin(object, source, options) {\r\n      if (options == null) {\r\n        var isObj = isObject(source),\r\n            props = isObj ? keys(source) : undefined,\r\n            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;\r\n\r\n        if (!(methodNames ? methodNames.length : isObj)) {\r\n          methodNames = false;\r\n          options = source;\r\n          source = object;\r\n          object = this;\r\n        }\r\n      }\r\n      if (!methodNames) {\r\n        methodNames = baseFunctions(source, keys(source));\r\n      }\r\n      var chain = true,\r\n          index = -1,\r\n          isFunc = isFunction(object),\r\n          length = methodNames.length;\r\n\r\n      if (options === false) {\r\n        chain = false;\r\n      } else if (isObject(options) && 'chain' in options) {\r\n        chain = options.chain;\r\n      }\r\n      while (++index < length) {\r\n        var methodName = methodNames[index],\r\n            func = source[methodName];\r\n\r\n        object[methodName] = func;\r\n        if (isFunc) {\r\n          object.prototype[methodName] = (function(func) {\r\n            return function() {\r\n              var chainAll = this.__chain__;\r\n              if (chain || chainAll) {\r\n                var result = object(this.__wrapped__),\r\n                    actions = result.__actions__ = arrayCopy(this.__actions__);\r\n\r\n                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\r\n                result.__chain__ = chainAll;\r\n                return result;\r\n              }\r\n              return func.apply(object, arrayPush([this.value()], arguments));\r\n            };\r\n          }(func));\r\n        }\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * Reverts the `_` variable to its previous value and returns a reference to\r\n     * the `lodash` function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @returns {Function} Returns the `lodash` function.\r\n     * @example\r\n     *\r\n     * var lodash = _.noConflict();\r\n     */\r\n    function noConflict() {\r\n      root._ = oldDash;\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * A no-operation function that returns `undefined` regardless of the\r\n     * arguments it receives.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @example\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     *\r\n     * _.noop(object) === undefined;\r\n     * // => true\r\n     */\r\n    function noop() {\r\n      // No operation performed.\r\n    }\r\n\r\n    /**\r\n     * Creates a function that returns the property value at `path` on a\r\n     * given object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': { 'b': { 'c': 2 } } },\r\n     *   { 'a': { 'b': { 'c': 1 } } }\r\n     * ];\r\n     *\r\n     * _.map(objects, _.property('a.b.c'));\r\n     * // => [2, 1]\r\n     *\r\n     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\r\n     * // => [1, 2]\r\n     */\r\n    function property(path) {\r\n      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\r\n    }\r\n\r\n    /**\r\n     * The opposite of `_.property`; this method creates a function that returns\r\n     * the property value at a given path on `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {Object} object The object to query.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var array = [0, 1, 2],\r\n     *     object = { 'a': array, 'b': array, 'c': array };\r\n     *\r\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\r\n     * // => [2, 0]\r\n     *\r\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\r\n     * // => [2, 0]\r\n     */\r\n    function propertyOf(object) {\r\n      return function(path) {\r\n        return baseGet(object, toPath(path), path + '');\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates an array of numbers (positive and/or negative) progressing from\r\n     * `start` up to, but not including, `end`. If `end` is not specified it is\r\n     * set to `start` with `start` then set to `0`. If `end` is less than `start`\r\n     * a zero-length range is created unless a negative `step` is specified.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {number} [start=0] The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @param {number} [step=1] The value to increment or decrement by.\r\n     * @returns {Array} Returns the new array of numbers.\r\n     * @example\r\n     *\r\n     * _.range(4);\r\n     * // => [0, 1, 2, 3]\r\n     *\r\n     * _.range(1, 5);\r\n     * // => [1, 2, 3, 4]\r\n     *\r\n     * _.range(0, 20, 5);\r\n     * // => [0, 5, 10, 15]\r\n     *\r\n     * _.range(0, -4, -1);\r\n     * // => [0, -1, -2, -3]\r\n     *\r\n     * _.range(1, 4, 0);\r\n     * // => [1, 1, 1]\r\n     *\r\n     * _.range(0);\r\n     * // => []\r\n     */\r\n    function range(start, end, step) {\r\n      if (step && isIterateeCall(start, end, step)) {\r\n        end = step = undefined;\r\n      }\r\n      start = +start || 0;\r\n      step = step == null ? 1 : (+step || 0);\r\n\r\n      if (end == null) {\r\n        end = start;\r\n        start = 0;\r\n      } else {\r\n        end = +end || 0;\r\n      }\r\n      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\r\n      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\r\n      var index = -1,\r\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\r\n          result = Array(length);\r\n\r\n      while (++index < length) {\r\n        result[index] = start;\r\n        start += step;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Invokes the iteratee function `n` times, returning an array of the results\r\n     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\r\n     * one argument; (index).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {number} n The number of times to invoke `iteratee`.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {Array} Returns the array of results.\r\n     * @example\r\n     *\r\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\r\n     * // => [3, 6, 4]\r\n     *\r\n     * _.times(3, function(n) {\r\n     *   mage.castSpell(n);\r\n     * });\r\n     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\r\n     *\r\n     * _.times(3, function(n) {\r\n     *   this.cast(n);\r\n     * }, mage);\r\n     * // => also invokes `mage.castSpell(n)` three times\r\n     */\r\n    function times(n, iteratee, thisArg) {\r\n      n = nativeFloor(n);\r\n\r\n      // Exit early to avoid a JSC JIT bug in Safari 8\r\n      // where `Array(0)` is treated as `Array(1)`.\r\n      if (n < 1 || !nativeIsFinite(n)) {\r\n        return [];\r\n      }\r\n      var index = -1,\r\n          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\r\n\r\n      iteratee = bindCallback(iteratee, thisArg, 1);\r\n      while (++index < n) {\r\n        if (index < MAX_ARRAY_LENGTH) {\r\n          result[index] = iteratee(index);\r\n        } else {\r\n          iteratee(index);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Utility\r\n     * @param {string} [prefix] The value to prefix the ID with.\r\n     * @returns {string} Returns the unique ID.\r\n     * @example\r\n     *\r\n     * _.uniqueId('contact_');\r\n     * // => 'contact_104'\r\n     *\r\n     * _.uniqueId();\r\n     * // => '105'\r\n     */\r\n    function uniqueId(prefix) {\r\n      var id = ++idCounter;\r\n      return baseToString(prefix) + id;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Adds two numbers.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {number} augend The first number to add.\r\n     * @param {number} addend The second number to add.\r\n     * @returns {number} Returns the sum.\r\n     * @example\r\n     *\r\n     * _.add(6, 4);\r\n     * // => 10\r\n     */\r\n    function add(augend, addend) {\r\n      return (+augend || 0) + (+addend || 0);\r\n    }\r\n\r\n    /**\r\n     * Calculates `n` rounded up to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {number} n The number to round up.\r\n     * @param {number} [precision=0] The precision to round up to.\r\n     * @returns {number} Returns the rounded up number.\r\n     * @example\r\n     *\r\n     * _.ceil(4.006);\r\n     * // => 5\r\n     *\r\n     * _.ceil(6.004, 2);\r\n     * // => 6.01\r\n     *\r\n     * _.ceil(6040, -2);\r\n     * // => 6100\r\n     */\r\n    var ceil = createRound('ceil');\r\n\r\n    /**\r\n     * Calculates `n` rounded down to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {number} n The number to round down.\r\n     * @param {number} [precision=0] The precision to round down to.\r\n     * @returns {number} Returns the rounded down number.\r\n     * @example\r\n     *\r\n     * _.floor(4.006);\r\n     * // => 4\r\n     *\r\n     * _.floor(0.046, 2);\r\n     * // => 0.04\r\n     *\r\n     * _.floor(4060, -2);\r\n     * // => 4000\r\n     */\r\n    var floor = createRound('floor');\r\n\r\n    /**\r\n     * Gets the maximum value of `collection`. If `collection` is empty or falsey\r\n     * `-Infinity` is returned. If an iteratee function is provided it is invoked\r\n     * for each value in `collection` to generate the criterion by which the value\r\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\r\n     * arguments: (value, index, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {*} Returns the maximum value.\r\n     * @example\r\n     *\r\n     * _.max([4, 2, 8, 6]);\r\n     * // => 8\r\n     *\r\n     * _.max([]);\r\n     * // => -Infinity\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * _.max(users, function(chr) {\r\n     *   return chr.age;\r\n     * });\r\n     * // => { 'user': 'fred', 'age': 40 }\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.max(users, 'age');\r\n     * // => { 'user': 'fred', 'age': 40 }\r\n     */\r\n    var max = createExtremum(gt, NEGATIVE_INFINITY);\r\n\r\n    /**\r\n     * Gets the minimum value of `collection`. If `collection` is empty or falsey\r\n     * `Infinity` is returned. If an iteratee function is provided it is invoked\r\n     * for each value in `collection` to generate the criterion by which the value\r\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\r\n     * arguments: (value, index, collection).\r\n     *\r\n     * If a property name is provided for `iteratee` the created `_.property`\r\n     * style callback returns the property value of the given element.\r\n     *\r\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\r\n     * style callback returns `true` for elements that have a matching property\r\n     * value, else `false`.\r\n     *\r\n     * If an object is provided for `iteratee` the created `_.matches` style\r\n     * callback returns `true` for elements that have the properties of the given\r\n     * object, else `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {*} Returns the minimum value.\r\n     * @example\r\n     *\r\n     * _.min([4, 2, 8, 6]);\r\n     * // => 2\r\n     *\r\n     * _.min([]);\r\n     * // => Infinity\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * _.min(users, function(chr) {\r\n     *   return chr.age;\r\n     * });\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.min(users, 'age');\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     */\r\n    var min = createExtremum(lt, POSITIVE_INFINITY);\r\n\r\n    /**\r\n     * Calculates `n` rounded to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {number} n The number to round.\r\n     * @param {number} [precision=0] The precision to round to.\r\n     * @returns {number} Returns the rounded number.\r\n     * @example\r\n     *\r\n     * _.round(4.006);\r\n     * // => 4\r\n     *\r\n     * _.round(4.006, 2);\r\n     * // => 4.01\r\n     *\r\n     * _.round(4060, -2);\r\n     * // => 4100\r\n     */\r\n    var round = createRound('round');\r\n\r\n    /**\r\n     * Gets the sum of the values in `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {Array|Object|string} collection The collection to iterate over.\r\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\r\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\r\n     * @returns {number} Returns the sum.\r\n     * @example\r\n     *\r\n     * _.sum([4, 6]);\r\n     * // => 10\r\n     *\r\n     * _.sum({ 'a': 4, 'b': 6 });\r\n     * // => 10\r\n     *\r\n     * var objects = [\r\n     *   { 'n': 4 },\r\n     *   { 'n': 6 }\r\n     * ];\r\n     *\r\n     * _.sum(objects, function(object) {\r\n     *   return object.n;\r\n     * });\r\n     * // => 10\r\n     *\r\n     * // using the `_.property` callback shorthand\r\n     * _.sum(objects, 'n');\r\n     * // => 10\r\n     */\r\n    function sum(collection, iteratee, thisArg) {\r\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\r\n        iteratee = undefined;\r\n      }\r\n      iteratee = getCallback(iteratee, thisArg, 3);\r\n      return iteratee.length == 1\r\n        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)\r\n        : baseSum(collection, iteratee);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    // Ensure wrappers are instances of `baseLodash`.\r\n    lodash.prototype = baseLodash.prototype;\r\n\r\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\r\n    LodashWrapper.prototype.constructor = LodashWrapper;\r\n\r\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\r\n    LazyWrapper.prototype.constructor = LazyWrapper;\r\n\r\n    // Add functions to the `Map` cache.\r\n    MapCache.prototype['delete'] = mapDelete;\r\n    MapCache.prototype.get = mapGet;\r\n    MapCache.prototype.has = mapHas;\r\n    MapCache.prototype.set = mapSet;\r\n\r\n    // Add functions to the `Set` cache.\r\n    SetCache.prototype.push = cachePush;\r\n\r\n    // Assign cache to `_.memoize`.\r\n    memoize.Cache = MapCache;\r\n\r\n    // Add functions that return wrapped values when chaining.\r\n    lodash.after = after;\r\n    lodash.ary = ary;\r\n    lodash.assign = assign;\r\n    lodash.at = at;\r\n    lodash.before = before;\r\n    lodash.bind = bind;\r\n    lodash.bindAll = bindAll;\r\n    lodash.bindKey = bindKey;\r\n    lodash.callback = callback;\r\n    lodash.chain = chain;\r\n    lodash.chunk = chunk;\r\n    lodash.compact = compact;\r\n    lodash.constant = constant;\r\n    lodash.countBy = countBy;\r\n    lodash.create = create;\r\n    lodash.curry = curry;\r\n    lodash.curryRight = curryRight;\r\n    lodash.debounce = debounce;\r\n    lodash.defaults = defaults;\r\n    lodash.defaultsDeep = defaultsDeep;\r\n    lodash.defer = defer;\r\n    lodash.delay = delay;\r\n    lodash.difference = difference;\r\n    lodash.drop = drop;\r\n    lodash.dropRight = dropRight;\r\n    lodash.dropRightWhile = dropRightWhile;\r\n    lodash.dropWhile = dropWhile;\r\n    lodash.fill = fill;\r\n    lodash.filter = filter;\r\n    lodash.flatten = flatten;\r\n    lodash.flattenDeep = flattenDeep;\r\n    lodash.flow = flow;\r\n    lodash.flowRight = flowRight;\r\n    lodash.forEach = forEach;\r\n    lodash.forEachRight = forEachRight;\r\n    lodash.forIn = forIn;\r\n    lodash.forInRight = forInRight;\r\n    lodash.forOwn = forOwn;\r\n    lodash.forOwnRight = forOwnRight;\r\n    lodash.functions = functions;\r\n    lodash.groupBy = groupBy;\r\n    lodash.indexBy = indexBy;\r\n    lodash.initial = initial;\r\n    lodash.intersection = intersection;\r\n    lodash.invert = invert;\r\n    lodash.invoke = invoke;\r\n    lodash.keys = keys;\r\n    lodash.keysIn = keysIn;\r\n    lodash.map = map;\r\n    lodash.mapKeys = mapKeys;\r\n    lodash.mapValues = mapValues;\r\n    lodash.matches = matches;\r\n    lodash.matchesProperty = matchesProperty;\r\n    lodash.memoize = memoize;\r\n    lodash.merge = merge;\r\n    lodash.method = method;\r\n    lodash.methodOf = methodOf;\r\n    lodash.mixin = mixin;\r\n    lodash.modArgs = modArgs;\r\n    lodash.negate = negate;\r\n    lodash.omit = omit;\r\n    lodash.once = once;\r\n    lodash.pairs = pairs;\r\n    lodash.partial = partial;\r\n    lodash.partialRight = partialRight;\r\n    lodash.partition = partition;\r\n    lodash.pick = pick;\r\n    lodash.pluck = pluck;\r\n    lodash.property = property;\r\n    lodash.propertyOf = propertyOf;\r\n    lodash.pull = pull;\r\n    lodash.pullAt = pullAt;\r\n    lodash.range = range;\r\n    lodash.rearg = rearg;\r\n    lodash.reject = reject;\r\n    lodash.remove = remove;\r\n    lodash.rest = rest;\r\n    lodash.restParam = restParam;\r\n    lodash.set = set;\r\n    lodash.shuffle = shuffle;\r\n    lodash.slice = slice;\r\n    lodash.sortBy = sortBy;\r\n    lodash.sortByAll = sortByAll;\r\n    lodash.sortByOrder = sortByOrder;\r\n    lodash.spread = spread;\r\n    lodash.take = take;\r\n    lodash.takeRight = takeRight;\r\n    lodash.takeRightWhile = takeRightWhile;\r\n    lodash.takeWhile = takeWhile;\r\n    lodash.tap = tap;\r\n    lodash.throttle = throttle;\r\n    lodash.thru = thru;\r\n    lodash.times = times;\r\n    lodash.toArray = toArray;\r\n    lodash.toPlainObject = toPlainObject;\r\n    lodash.transform = transform;\r\n    lodash.union = union;\r\n    lodash.uniq = uniq;\r\n    lodash.unzip = unzip;\r\n    lodash.unzipWith = unzipWith;\r\n    lodash.values = values;\r\n    lodash.valuesIn = valuesIn;\r\n    lodash.where = where;\r\n    lodash.without = without;\r\n    lodash.wrap = wrap;\r\n    lodash.xor = xor;\r\n    lodash.zip = zip;\r\n    lodash.zipObject = zipObject;\r\n    lodash.zipWith = zipWith;\r\n\r\n    // Add aliases.\r\n    lodash.backflow = flowRight;\r\n    lodash.collect = map;\r\n    lodash.compose = flowRight;\r\n    lodash.each = forEach;\r\n    lodash.eachRight = forEachRight;\r\n    lodash.extend = assign;\r\n    lodash.iteratee = callback;\r\n    lodash.methods = functions;\r\n    lodash.object = zipObject;\r\n    lodash.select = filter;\r\n    lodash.tail = rest;\r\n    lodash.unique = uniq;\r\n\r\n    // Add functions to `lodash.prototype`.\r\n    mixin(lodash, lodash);\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    // Add functions that return unwrapped values when chaining.\r\n    lodash.add = add;\r\n    lodash.attempt = attempt;\r\n    lodash.camelCase = camelCase;\r\n    lodash.capitalize = capitalize;\r\n    lodash.ceil = ceil;\r\n    lodash.clone = clone;\r\n    lodash.cloneDeep = cloneDeep;\r\n    lodash.deburr = deburr;\r\n    lodash.endsWith = endsWith;\r\n    lodash.escape = escape;\r\n    lodash.escapeRegExp = escapeRegExp;\r\n    lodash.every = every;\r\n    lodash.find = find;\r\n    lodash.findIndex = findIndex;\r\n    lodash.findKey = findKey;\r\n    lodash.findLast = findLast;\r\n    lodash.findLastIndex = findLastIndex;\r\n    lodash.findLastKey = findLastKey;\r\n    lodash.findWhere = findWhere;\r\n    lodash.first = first;\r\n    lodash.floor = floor;\r\n    lodash.get = get;\r\n    lodash.gt = gt;\r\n    lodash.gte = gte;\r\n    lodash.has = has;\r\n    lodash.identity = identity;\r\n    lodash.includes = includes;\r\n    lodash.indexOf = indexOf;\r\n    lodash.inRange = inRange;\r\n    lodash.isArguments = isArguments;\r\n    lodash.isArray = isArray;\r\n    lodash.isBoolean = isBoolean;\r\n    lodash.isDate = isDate;\r\n    lodash.isElement = isElement;\r\n    lodash.isEmpty = isEmpty;\r\n    lodash.isEqual = isEqual;\r\n    lodash.isError = isError;\r\n    lodash.isFinite = isFinite;\r\n    lodash.isFunction = isFunction;\r\n    lodash.isMatch = isMatch;\r\n    lodash.isNaN = isNaN;\r\n    lodash.isNative = isNative;\r\n    lodash.isNull = isNull;\r\n    lodash.isNumber = isNumber;\r\n    lodash.isObject = isObject;\r\n    lodash.isPlainObject = isPlainObject;\r\n    lodash.isRegExp = isRegExp;\r\n    lodash.isString = isString;\r\n    lodash.isTypedArray = isTypedArray;\r\n    lodash.isUndefined = isUndefined;\r\n    lodash.kebabCase = kebabCase;\r\n    lodash.last = last;\r\n    lodash.lastIndexOf = lastIndexOf;\r\n    lodash.lt = lt;\r\n    lodash.lte = lte;\r\n    lodash.max = max;\r\n    lodash.min = min;\r\n    lodash.noConflict = noConflict;\r\n    lodash.noop = noop;\r\n    lodash.now = now;\r\n    lodash.pad = pad;\r\n    lodash.padLeft = padLeft;\r\n    lodash.padRight = padRight;\r\n    lodash.parseInt = parseInt;\r\n    lodash.random = random;\r\n    lodash.reduce = reduce;\r\n    lodash.reduceRight = reduceRight;\r\n    lodash.repeat = repeat;\r\n    lodash.result = result;\r\n    lodash.round = round;\r\n    lodash.runInContext = runInContext;\r\n    lodash.size = size;\r\n    lodash.snakeCase = snakeCase;\r\n    lodash.some = some;\r\n    lodash.sortedIndex = sortedIndex;\r\n    lodash.sortedLastIndex = sortedLastIndex;\r\n    lodash.startCase = startCase;\r\n    lodash.startsWith = startsWith;\r\n    lodash.sum = sum;\r\n    lodash.template = template;\r\n    lodash.trim = trim;\r\n    lodash.trimLeft = trimLeft;\r\n    lodash.trimRight = trimRight;\r\n    lodash.trunc = trunc;\r\n    lodash.unescape = unescape;\r\n    lodash.uniqueId = uniqueId;\r\n    lodash.words = words;\r\n\r\n    // Add aliases.\r\n    lodash.all = every;\r\n    lodash.any = some;\r\n    lodash.contains = includes;\r\n    lodash.eq = isEqual;\r\n    lodash.detect = find;\r\n    lodash.foldl = reduce;\r\n    lodash.foldr = reduceRight;\r\n    lodash.head = first;\r\n    lodash.include = includes;\r\n    lodash.inject = reduce;\r\n\r\n    mixin(lodash, (function() {\r\n      var source = {};\r\n      baseForOwn(lodash, function(func, methodName) {\r\n        if (!lodash.prototype[methodName]) {\r\n          source[methodName] = func;\r\n        }\r\n      });\r\n      return source;\r\n    }()), false);\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    // Add functions capable of returning wrapped and unwrapped values when chaining.\r\n    lodash.sample = sample;\r\n\r\n    lodash.prototype.sample = function(n) {\r\n      if (!this.__chain__ && n == null) {\r\n        return sample(this.value());\r\n      }\r\n      return this.thru(function(value) {\r\n        return sample(value, n);\r\n      });\r\n    };\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * The semantic version number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @type string\r\n     */\r\n    lodash.VERSION = VERSION;\r\n\r\n    // Assign default placeholders.\r\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\r\n      lodash[methodName].placeholder = lodash;\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\r\n    arrayEach(['drop', 'take'], function(methodName, index) {\r\n      LazyWrapper.prototype[methodName] = function(n) {\r\n        var filtered = this.__filtered__;\r\n        if (filtered && !index) {\r\n          return new LazyWrapper(this);\r\n        }\r\n        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);\r\n\r\n        var result = this.clone();\r\n        if (filtered) {\r\n          result.__takeCount__ = nativeMin(result.__takeCount__, n);\r\n        } else {\r\n          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\r\n        }\r\n        return result;\r\n      };\r\n\r\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\r\n        return this.reverse()[methodName](n).reverse();\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\r\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\r\n      var type = index + 1,\r\n          isFilter = type != LAZY_MAP_FLAG;\r\n\r\n      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\r\n        var result = this.clone();\r\n        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });\r\n        result.__filtered__ = result.__filtered__ || isFilter;\r\n        return result;\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.first` and `_.last`.\r\n    arrayEach(['first', 'last'], function(methodName, index) {\r\n      var takeName = 'take' + (index ? 'Right' : '');\r\n\r\n      LazyWrapper.prototype[methodName] = function() {\r\n        return this[takeName](1).value()[0];\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\r\n    arrayEach(['initial', 'rest'], function(methodName, index) {\r\n      var dropName = 'drop' + (index ? '' : 'Right');\r\n\r\n      LazyWrapper.prototype[methodName] = function() {\r\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\r\n    arrayEach(['pluck', 'where'], function(methodName, index) {\r\n      var operationName = index ? 'filter' : 'map',\r\n          createCallback = index ? baseMatches : property;\r\n\r\n      LazyWrapper.prototype[methodName] = function(value) {\r\n        return this[operationName](createCallback(value));\r\n      };\r\n    });\r\n\r\n    LazyWrapper.prototype.compact = function() {\r\n      return this.filter(identity);\r\n    };\r\n\r\n    LazyWrapper.prototype.reject = function(predicate, thisArg) {\r\n      predicate = getCallback(predicate, thisArg, 1);\r\n      return this.filter(function(value) {\r\n        return !predicate(value);\r\n      });\r\n    };\r\n\r\n    LazyWrapper.prototype.slice = function(start, end) {\r\n      start = start == null ? 0 : (+start || 0);\r\n\r\n      var result = this;\r\n      if (result.__filtered__ && (start > 0 || end < 0)) {\r\n        return new LazyWrapper(result);\r\n      }\r\n      if (start < 0) {\r\n        result = result.takeRight(-start);\r\n      } else if (start) {\r\n        result = result.drop(start);\r\n      }\r\n      if (end !== undefined) {\r\n        end = (+end || 0);\r\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\r\n      }\r\n      return result;\r\n    };\r\n\r\n    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {\r\n      return this.reverse().takeWhile(predicate, thisArg).reverse();\r\n    };\r\n\r\n    LazyWrapper.prototype.toArray = function() {\r\n      return this.take(POSITIVE_INFINITY);\r\n    };\r\n\r\n    // Add `LazyWrapper` methods to `lodash.prototype`.\r\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\r\n      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),\r\n          retUnwrapped = /^(?:first|last)$/.test(methodName),\r\n          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];\r\n\r\n      if (!lodashFunc) {\r\n        return;\r\n      }\r\n      lodash.prototype[methodName] = function() {\r\n        var args = retUnwrapped ? [1] : arguments,\r\n            chainAll = this.__chain__,\r\n            value = this.__wrapped__,\r\n            isHybrid = !!this.__actions__.length,\r\n            isLazy = value instanceof LazyWrapper,\r\n            iteratee = args[0],\r\n            useLazy = isLazy || isArray(value);\r\n\r\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\r\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\r\n          isLazy = useLazy = false;\r\n        }\r\n        var interceptor = function(value) {\r\n          return (retUnwrapped && chainAll)\r\n            ? lodashFunc(value, 1)[0]\r\n            : lodashFunc.apply(undefined, arrayPush([value], args));\r\n        };\r\n\r\n        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },\r\n            onlyLazy = isLazy && !isHybrid;\r\n\r\n        if (retUnwrapped && !chainAll) {\r\n          if (onlyLazy) {\r\n            value = value.clone();\r\n            value.__actions__.push(action);\r\n            return func.call(value);\r\n          }\r\n          return lodashFunc.call(undefined, this.value())[0];\r\n        }\r\n        if (!retUnwrapped && useLazy) {\r\n          value = onlyLazy ? value : new LazyWrapper(this);\r\n          var result = func.apply(value, args);\r\n          result.__actions__.push(action);\r\n          return new LodashWrapper(result, chainAll);\r\n        }\r\n        return this.thru(interceptor);\r\n      };\r\n    });\r\n\r\n    // Add `Array` and `String` methods to `lodash.prototype`.\r\n    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {\r\n      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],\r\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\r\n          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);\r\n\r\n      lodash.prototype[methodName] = function() {\r\n        var args = arguments;\r\n        if (retUnwrapped && !this.__chain__) {\r\n          return func.apply(this.value(), args);\r\n        }\r\n        return this[chainName](function(value) {\r\n          return func.apply(value, args);\r\n        });\r\n      };\r\n    });\r\n\r\n    // Map minified function names to their real names.\r\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\r\n      var lodashFunc = lodash[methodName];\r\n      if (lodashFunc) {\r\n        var key = lodashFunc.name,\r\n            names = realNames[key] || (realNames[key] = []);\r\n\r\n        names.push({ 'name': methodName, 'func': lodashFunc });\r\n      }\r\n    });\r\n\r\n    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\r\n\r\n    // Add functions to the lazy wrapper.\r\n    LazyWrapper.prototype.clone = lazyClone;\r\n    LazyWrapper.prototype.reverse = lazyReverse;\r\n    LazyWrapper.prototype.value = lazyValue;\r\n\r\n    // Add chaining functions to the `lodash` wrapper.\r\n    lodash.prototype.chain = wrapperChain;\r\n    lodash.prototype.commit = wrapperCommit;\r\n    lodash.prototype.concat = wrapperConcat;\r\n    lodash.prototype.plant = wrapperPlant;\r\n    lodash.prototype.reverse = wrapperReverse;\r\n    lodash.prototype.toString = wrapperToString;\r\n    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\r\n\r\n    // Add function aliases to the `lodash` wrapper.\r\n    lodash.prototype.collect = lodash.prototype.map;\r\n    lodash.prototype.head = lodash.prototype.first;\r\n    lodash.prototype.select = lodash.prototype.filter;\r\n    lodash.prototype.tail = lodash.prototype.rest;\r\n\r\n    return lodash;\r\n  }\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  // Export lodash.\r\n  var _ = runInContext();\r\n\r\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\r\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\r\n    // Expose lodash to the global object when an AMD loader is present to avoid\r\n    // errors in cases where lodash is loaded by a script tag and not intended\r\n    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\r\n    // more details.\r\n    root._ = _;\r\n\r\n    // Define as an anonymous module so, through path mapping, it can be\r\n    // referenced as the \"underscore\" module.\r\n    define(function() {\r\n      return _;\r\n    });\r\n  }\r\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\r\n  else if (freeExports && freeModule) {\r\n    // Export for Node.js or RingoJS.\r\n    if (moduleExports) {\r\n      (freeModule.exports = _)._ = _;\r\n    }\r\n    // Export for Rhino with CommonJS support.\r\n    else {\r\n      freeExports._ = _;\r\n    }\r\n  }\r\n  else {\r\n    // Export for a browser or Rhino.\r\n    root._ = _;\r\n  }\r\n}.call(this));\r\n"

/***/ }),

/***/ 258:
/***/ (function(module, exports) {

module.exports = "/*! tether 1.4.0 */\r\n\r\n(function(root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(factory);\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = factory(require, exports, module);\r\n  } else {\r\n    root.Tether = factory();\r\n  }\r\n}(this, function(require, exports, module) {\r\n\r\n'use strict';\r\n\r\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\r\n\r\nvar TetherBase = undefined;\r\nif (typeof TetherBase === 'undefined') {\r\n  TetherBase = { modules: [] };\r\n}\r\n\r\nvar zeroElement = null;\r\n\r\n// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\r\n// if the element lies within a nested document (<frame> or <iframe>-like).\r\nfunction getActualBoundingClientRect(node) {\r\n  var boundingRect = node.getBoundingClientRect();\r\n\r\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\r\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\r\n  var rect = {};\r\n  for (var k in boundingRect) {\r\n    rect[k] = boundingRect[k];\r\n  }\r\n\r\n  if (node.ownerDocument !== document) {\r\n    var _frameElement = node.ownerDocument.defaultView.frameElement;\r\n    if (_frameElement) {\r\n      var frameRect = getActualBoundingClientRect(_frameElement);\r\n      rect.top += frameRect.top;\r\n      rect.bottom += frameRect.top;\r\n      rect.left += frameRect.left;\r\n      rect.right += frameRect.left;\r\n    }\r\n  }\r\n\r\n  return rect;\r\n}\r\n\r\nfunction getScrollParents(el) {\r\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\r\n  var computedStyle = getComputedStyle(el) || {};\r\n  var position = computedStyle.position;\r\n  var parents = [];\r\n\r\n  if (position === 'fixed') {\r\n    return [el];\r\n  }\r\n\r\n  var parent = el;\r\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\r\n    var style = undefined;\r\n    try {\r\n      style = getComputedStyle(parent);\r\n    } catch (err) {}\r\n\r\n    if (typeof style === 'undefined' || style === null) {\r\n      parents.push(parent);\r\n      return parents;\r\n    }\r\n\r\n    var _style = style;\r\n    var overflow = _style.overflow;\r\n    var overflowX = _style.overflowX;\r\n    var overflowY = _style.overflowY;\r\n\r\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\r\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\r\n        parents.push(parent);\r\n      }\r\n    }\r\n  }\r\n\r\n  parents.push(el.ownerDocument.body);\r\n\r\n  // If the node is within a frame, account for the parent window scroll\r\n  if (el.ownerDocument !== document) {\r\n    parents.push(el.ownerDocument.defaultView);\r\n  }\r\n\r\n  return parents;\r\n}\r\n\r\nvar uniqueId = (function () {\r\n  var id = 0;\r\n  return function () {\r\n    return ++id;\r\n  };\r\n})();\r\n\r\nvar zeroPosCache = {};\r\nvar getOrigin = function getOrigin() {\r\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\r\n  // jitter as the user scrolls that messes with our ability to detect if two positions\r\n  // are equivilant or not.  We place an element at the top left of the page that will\r\n  // get the same jitter, so we can cancel the two out.\r\n  var node = zeroElement;\r\n  if (!node || !document.body.contains(node)) {\r\n    node = document.createElement('div');\r\n    node.setAttribute('data-tether-id', uniqueId());\r\n    extend(node.style, {\r\n      top: 0,\r\n      left: 0,\r\n      position: 'absolute'\r\n    });\r\n\r\n    document.body.appendChild(node);\r\n\r\n    zeroElement = node;\r\n  }\r\n\r\n  var id = node.getAttribute('data-tether-id');\r\n  if (typeof zeroPosCache[id] === 'undefined') {\r\n    zeroPosCache[id] = getActualBoundingClientRect(node);\r\n\r\n    // Clear the cache when this position call is done\r\n    defer(function () {\r\n      delete zeroPosCache[id];\r\n    });\r\n  }\r\n\r\n  return zeroPosCache[id];\r\n};\r\n\r\nfunction removeUtilElements() {\r\n  if (zeroElement) {\r\n    document.body.removeChild(zeroElement);\r\n  }\r\n  zeroElement = null;\r\n};\r\n\r\nfunction getBounds(el) {\r\n  var doc = undefined;\r\n  if (el === document) {\r\n    doc = document;\r\n    el = document.documentElement;\r\n  } else {\r\n    doc = el.ownerDocument;\r\n  }\r\n\r\n  var docEl = doc.documentElement;\r\n\r\n  var box = getActualBoundingClientRect(el);\r\n\r\n  var origin = getOrigin();\r\n\r\n  box.top -= origin.top;\r\n  box.left -= origin.left;\r\n\r\n  if (typeof box.width === 'undefined') {\r\n    box.width = document.body.scrollWidth - box.left - box.right;\r\n  }\r\n  if (typeof box.height === 'undefined') {\r\n    box.height = document.body.scrollHeight - box.top - box.bottom;\r\n  }\r\n\r\n  box.top = box.top - docEl.clientTop;\r\n  box.left = box.left - docEl.clientLeft;\r\n  box.right = doc.body.clientWidth - box.width - box.left;\r\n  box.bottom = doc.body.clientHeight - box.height - box.top;\r\n\r\n  return box;\r\n}\r\n\r\nfunction getOffsetParent(el) {\r\n  return el.offsetParent || document.documentElement;\r\n}\r\n\r\nvar _scrollBarSize = null;\r\nfunction getScrollBarSize() {\r\n  if (_scrollBarSize) {\r\n    return _scrollBarSize;\r\n  }\r\n  var inner = document.createElement('div');\r\n  inner.style.width = '100%';\r\n  inner.style.height = '200px';\r\n\r\n  var outer = document.createElement('div');\r\n  extend(outer.style, {\r\n    position: 'absolute',\r\n    top: 0,\r\n    left: 0,\r\n    pointerEvents: 'none',\r\n    visibility: 'hidden',\r\n    width: '200px',\r\n    height: '150px',\r\n    overflow: 'hidden'\r\n  });\r\n\r\n  outer.appendChild(inner);\r\n\r\n  document.body.appendChild(outer);\r\n\r\n  var widthContained = inner.offsetWidth;\r\n  outer.style.overflow = 'scroll';\r\n  var widthScroll = inner.offsetWidth;\r\n\r\n  if (widthContained === widthScroll) {\r\n    widthScroll = outer.clientWidth;\r\n  }\r\n\r\n  document.body.removeChild(outer);\r\n\r\n  var width = widthContained - widthScroll;\r\n\r\n  _scrollBarSize = { width: width, height: width };\r\n  return _scrollBarSize;\r\n}\r\n\r\nfunction extend() {\r\n  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\r\n\r\n  var args = [];\r\n\r\n  Array.prototype.push.apply(args, arguments);\r\n\r\n  args.slice(1).forEach(function (obj) {\r\n    if (obj) {\r\n      for (var key in obj) {\r\n        if (({}).hasOwnProperty.call(obj, key)) {\r\n          out[key] = obj[key];\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nfunction removeClass(el, name) {\r\n  if (typeof el.classList !== 'undefined') {\r\n    name.split(' ').forEach(function (cls) {\r\n      if (cls.trim()) {\r\n        el.classList.remove(cls);\r\n      }\r\n    });\r\n  } else {\r\n    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');\r\n    var className = getClassName(el).replace(regex, ' ');\r\n    setClassName(el, className);\r\n  }\r\n}\r\n\r\nfunction addClass(el, name) {\r\n  if (typeof el.classList !== 'undefined') {\r\n    name.split(' ').forEach(function (cls) {\r\n      if (cls.trim()) {\r\n        el.classList.add(cls);\r\n      }\r\n    });\r\n  } else {\r\n    removeClass(el, name);\r\n    var cls = getClassName(el) + (' ' + name);\r\n    setClassName(el, cls);\r\n  }\r\n}\r\n\r\nfunction hasClass(el, name) {\r\n  if (typeof el.classList !== 'undefined') {\r\n    return el.classList.contains(name);\r\n  }\r\n  var className = getClassName(el);\r\n  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);\r\n}\r\n\r\nfunction getClassName(el) {\r\n  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\r\n  // completely separately SVGAnimatedString base classes\r\n  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\r\n    return el.className.baseVal;\r\n  }\r\n  return el.className;\r\n}\r\n\r\nfunction setClassName(el, className) {\r\n  el.setAttribute('class', className);\r\n}\r\n\r\nfunction updateClasses(el, add, all) {\r\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\r\n  // 'add' classes to be set.\r\n  all.forEach(function (cls) {\r\n    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\r\n      removeClass(el, cls);\r\n    }\r\n  });\r\n\r\n  add.forEach(function (cls) {\r\n    if (!hasClass(el, cls)) {\r\n      addClass(el, cls);\r\n    }\r\n  });\r\n}\r\n\r\nvar deferred = [];\r\n\r\nvar defer = function defer(fn) {\r\n  deferred.push(fn);\r\n};\r\n\r\nvar flush = function flush() {\r\n  var fn = undefined;\r\n  while (fn = deferred.pop()) {\r\n    fn();\r\n  }\r\n};\r\n\r\nvar Evented = (function () {\r\n  function Evented() {\r\n    _classCallCheck(this, Evented);\r\n  }\r\n\r\n  _createClass(Evented, [{\r\n    key: 'on',\r\n    value: function on(event, handler, ctx) {\r\n      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\r\n\r\n      if (typeof this.bindings === 'undefined') {\r\n        this.bindings = {};\r\n      }\r\n      if (typeof this.bindings[event] === 'undefined') {\r\n        this.bindings[event] = [];\r\n      }\r\n      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });\r\n    }\r\n  }, {\r\n    key: 'once',\r\n    value: function once(event, handler, ctx) {\r\n      this.on(event, handler, ctx, true);\r\n    }\r\n  }, {\r\n    key: 'off',\r\n    value: function off(event, handler) {\r\n      if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      if (typeof handler === 'undefined') {\r\n        delete this.bindings[event];\r\n      } else {\r\n        var i = 0;\r\n        while (i < this.bindings[event].length) {\r\n          if (this.bindings[event][i].handler === handler) {\r\n            this.bindings[event].splice(i, 1);\r\n          } else {\r\n            ++i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: 'trigger',\r\n    value: function trigger(event) {\r\n      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\r\n        var i = 0;\r\n\r\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n          args[_key - 1] = arguments[_key];\r\n        }\r\n\r\n        while (i < this.bindings[event].length) {\r\n          var _bindings$event$i = this.bindings[event][i];\r\n          var handler = _bindings$event$i.handler;\r\n          var ctx = _bindings$event$i.ctx;\r\n          var once = _bindings$event$i.once;\r\n\r\n          var context = ctx;\r\n          if (typeof context === 'undefined') {\r\n            context = this;\r\n          }\r\n\r\n          handler.apply(context, args);\r\n\r\n          if (once) {\r\n            this.bindings[event].splice(i, 1);\r\n          } else {\r\n            ++i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return Evented;\r\n})();\r\n\r\nTetherBase.Utils = {\r\n  getActualBoundingClientRect: getActualBoundingClientRect,\r\n  getScrollParents: getScrollParents,\r\n  getBounds: getBounds,\r\n  getOffsetParent: getOffsetParent,\r\n  extend: extend,\r\n  addClass: addClass,\r\n  removeClass: removeClass,\r\n  hasClass: hasClass,\r\n  updateClasses: updateClasses,\r\n  defer: defer,\r\n  flush: flush,\r\n  uniqueId: uniqueId,\r\n  Evented: Evented,\r\n  getScrollBarSize: getScrollBarSize,\r\n  removeUtilElements: removeUtilElements\r\n};\r\n/* globals TetherBase, performance */\r\n\r\n'use strict';\r\n\r\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\r\n\r\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\r\n\r\nvar _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\r\nif (typeof TetherBase === 'undefined') {\r\n  throw new Error('You must include the utils.js file before tether.js');\r\n}\r\n\r\nvar _TetherBase$Utils = TetherBase.Utils;\r\nvar getScrollParents = _TetherBase$Utils.getScrollParents;\r\nvar getBounds = _TetherBase$Utils.getBounds;\r\nvar getOffsetParent = _TetherBase$Utils.getOffsetParent;\r\nvar extend = _TetherBase$Utils.extend;\r\nvar addClass = _TetherBase$Utils.addClass;\r\nvar removeClass = _TetherBase$Utils.removeClass;\r\nvar updateClasses = _TetherBase$Utils.updateClasses;\r\nvar defer = _TetherBase$Utils.defer;\r\nvar flush = _TetherBase$Utils.flush;\r\nvar getScrollBarSize = _TetherBase$Utils.getScrollBarSize;\r\nvar removeUtilElements = _TetherBase$Utils.removeUtilElements;\r\n\r\nfunction within(a, b) {\r\n  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\r\n\r\n  return a + diff >= b && b >= a - diff;\r\n}\r\n\r\nvar transformKey = (function () {\r\n  if (typeof document === 'undefined') {\r\n    return '';\r\n  }\r\n  var el = document.createElement('div');\r\n\r\n  var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\r\n  for (var i = 0; i < transforms.length; ++i) {\r\n    var key = transforms[i];\r\n    if (el.style[key] !== undefined) {\r\n      return key;\r\n    }\r\n  }\r\n})();\r\n\r\nvar tethers = [];\r\n\r\nvar position = function position() {\r\n  tethers.forEach(function (tether) {\r\n    tether.position(false);\r\n  });\r\n  flush();\r\n};\r\n\r\nfunction now() {\r\n  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {\r\n    return performance.now();\r\n  }\r\n  return +new Date();\r\n}\r\n\r\n(function () {\r\n  var lastCall = null;\r\n  var lastDuration = null;\r\n  var pendingTimeout = null;\r\n\r\n  var tick = function tick() {\r\n    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\r\n      // We voluntarily throttle ourselves if we can't manage 60fps\r\n      lastDuration = Math.min(lastDuration - 16, 250);\r\n\r\n      // Just in case this is the last event, remember to position just once more\r\n      pendingTimeout = setTimeout(tick, 250);\r\n      return;\r\n    }\r\n\r\n    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {\r\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\r\n      return;\r\n    }\r\n\r\n    if (pendingTimeout != null) {\r\n      clearTimeout(pendingTimeout);\r\n      pendingTimeout = null;\r\n    }\r\n\r\n    lastCall = now();\r\n    position();\r\n    lastDuration = now() - lastCall;\r\n  };\r\n\r\n  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\r\n    ['resize', 'scroll', 'touchmove'].forEach(function (event) {\r\n      window.addEventListener(event, tick);\r\n    });\r\n  }\r\n})();\r\n\r\nvar MIRROR_LR = {\r\n  center: 'center',\r\n  left: 'right',\r\n  right: 'left'\r\n};\r\n\r\nvar MIRROR_TB = {\r\n  middle: 'middle',\r\n  top: 'bottom',\r\n  bottom: 'top'\r\n};\r\n\r\nvar OFFSET_MAP = {\r\n  top: 0,\r\n  left: 0,\r\n  middle: '50%',\r\n  center: '50%',\r\n  bottom: '100%',\r\n  right: '100%'\r\n};\r\n\r\nvar autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {\r\n  var left = attachment.left;\r\n  var top = attachment.top;\r\n\r\n  if (left === 'auto') {\r\n    left = MIRROR_LR[relativeToAttachment.left];\r\n  }\r\n\r\n  if (top === 'auto') {\r\n    top = MIRROR_TB[relativeToAttachment.top];\r\n  }\r\n\r\n  return { left: left, top: top };\r\n};\r\n\r\nvar attachmentToOffset = function attachmentToOffset(attachment) {\r\n  var left = attachment.left;\r\n  var top = attachment.top;\r\n\r\n  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\r\n    left = OFFSET_MAP[attachment.left];\r\n  }\r\n\r\n  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\r\n    top = OFFSET_MAP[attachment.top];\r\n  }\r\n\r\n  return { left: left, top: top };\r\n};\r\n\r\nfunction addOffset() {\r\n  var out = { top: 0, left: 0 };\r\n\r\n  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {\r\n    offsets[_key] = arguments[_key];\r\n  }\r\n\r\n  offsets.forEach(function (_ref) {\r\n    var top = _ref.top;\r\n    var left = _ref.left;\r\n\r\n    if (typeof top === 'string') {\r\n      top = parseFloat(top, 10);\r\n    }\r\n    if (typeof left === 'string') {\r\n      left = parseFloat(left, 10);\r\n    }\r\n\r\n    out.top += top;\r\n    out.left += left;\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nfunction offsetToPx(offset, size) {\r\n  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\r\n    offset.left = parseFloat(offset.left, 10) / 100 * size.width;\r\n  }\r\n  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\r\n    offset.top = parseFloat(offset.top, 10) / 100 * size.height;\r\n  }\r\n\r\n  return offset;\r\n}\r\n\r\nvar parseOffset = function parseOffset(value) {\r\n  var _value$split = value.split(' ');\r\n\r\n  var _value$split2 = _slicedToArray(_value$split, 2);\r\n\r\n  var top = _value$split2[0];\r\n  var left = _value$split2[1];\r\n\r\n  return { top: top, left: left };\r\n};\r\nvar parseAttachment = parseOffset;\r\n\r\nvar TetherClass = (function (_Evented) {\r\n  _inherits(TetherClass, _Evented);\r\n\r\n  function TetherClass(options) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, TetherClass);\r\n\r\n    _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);\r\n    this.position = this.position.bind(this);\r\n\r\n    tethers.push(this);\r\n\r\n    this.history = [];\r\n\r\n    this.setOptions(options, false);\r\n\r\n    TetherBase.modules.forEach(function (module) {\r\n      if (typeof module.initialize !== 'undefined') {\r\n        module.initialize.call(_this);\r\n      }\r\n    });\r\n\r\n    this.position();\r\n  }\r\n\r\n  _createClass(TetherClass, [{\r\n    key: 'getClass',\r\n    value: function getClass() {\r\n      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\r\n      var classes = this.options.classes;\r\n\r\n      if (typeof classes !== 'undefined' && classes[key]) {\r\n        return this.options.classes[key];\r\n      } else if (this.options.classPrefix) {\r\n        return this.options.classPrefix + '-' + key;\r\n      } else {\r\n        return key;\r\n      }\r\n    }\r\n  }, {\r\n    key: 'setOptions',\r\n    value: function setOptions(options) {\r\n      var _this2 = this;\r\n\r\n      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\r\n\r\n      var defaults = {\r\n        offset: '0 0',\r\n        targetOffset: '0 0',\r\n        targetAttachment: 'auto auto',\r\n        classPrefix: 'tether'\r\n      };\r\n\r\n      this.options = extend(defaults, options);\r\n\r\n      var _options = this.options;\r\n      var element = _options.element;\r\n      var target = _options.target;\r\n      var targetModifier = _options.targetModifier;\r\n\r\n      this.element = element;\r\n      this.target = target;\r\n      this.targetModifier = targetModifier;\r\n\r\n      if (this.target === 'viewport') {\r\n        this.target = document.body;\r\n        this.targetModifier = 'visible';\r\n      } else if (this.target === 'scroll-handle') {\r\n        this.target = document.body;\r\n        this.targetModifier = 'scroll-handle';\r\n      }\r\n\r\n      ['element', 'target'].forEach(function (key) {\r\n        if (typeof _this2[key] === 'undefined') {\r\n          throw new Error('Tether Error: Both element and target must be defined');\r\n        }\r\n\r\n        if (typeof _this2[key].jquery !== 'undefined') {\r\n          _this2[key] = _this2[key][0];\r\n        } else if (typeof _this2[key] === 'string') {\r\n          _this2[key] = document.querySelector(_this2[key]);\r\n        }\r\n      });\r\n\r\n      addClass(this.element, this.getClass('element'));\r\n      if (!(this.options.addTargetClasses === false)) {\r\n        addClass(this.target, this.getClass('target'));\r\n      }\r\n\r\n      if (!this.options.attachment) {\r\n        throw new Error('Tether Error: You must provide an attachment');\r\n      }\r\n\r\n      this.targetAttachment = parseAttachment(this.options.targetAttachment);\r\n      this.attachment = parseAttachment(this.options.attachment);\r\n      this.offset = parseOffset(this.options.offset);\r\n      this.targetOffset = parseOffset(this.options.targetOffset);\r\n\r\n      if (typeof this.scrollParents !== 'undefined') {\r\n        this.disable();\r\n      }\r\n\r\n      if (this.targetModifier === 'scroll-handle') {\r\n        this.scrollParents = [this.target];\r\n      } else {\r\n        this.scrollParents = getScrollParents(this.target);\r\n      }\r\n\r\n      if (!(this.options.enabled === false)) {\r\n        this.enable(pos);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'getTargetBounds',\r\n    value: function getTargetBounds() {\r\n      if (typeof this.targetModifier !== 'undefined') {\r\n        if (this.targetModifier === 'visible') {\r\n          if (this.target === document.body) {\r\n            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\r\n          } else {\r\n            var bounds = getBounds(this.target);\r\n\r\n            var out = {\r\n              height: bounds.height,\r\n              width: bounds.width,\r\n              top: bounds.top,\r\n              left: bounds.left\r\n            };\r\n\r\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\r\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\r\n            out.height = Math.min(innerHeight, out.height);\r\n            out.height -= 2;\r\n\r\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\r\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\r\n            out.width = Math.min(innerWidth, out.width);\r\n            out.width -= 2;\r\n\r\n            if (out.top < pageYOffset) {\r\n              out.top = pageYOffset;\r\n            }\r\n            if (out.left < pageXOffset) {\r\n              out.left = pageXOffset;\r\n            }\r\n\r\n            return out;\r\n          }\r\n        } else if (this.targetModifier === 'scroll-handle') {\r\n          var bounds = undefined;\r\n          var target = this.target;\r\n          if (target === document.body) {\r\n            target = document.documentElement;\r\n\r\n            bounds = {\r\n              left: pageXOffset,\r\n              top: pageYOffset,\r\n              height: innerHeight,\r\n              width: innerWidth\r\n            };\r\n          } else {\r\n            bounds = getBounds(target);\r\n          }\r\n\r\n          var style = getComputedStyle(target);\r\n\r\n          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;\r\n\r\n          var scrollBottom = 0;\r\n          if (hasBottomScroll) {\r\n            scrollBottom = 15;\r\n          }\r\n\r\n          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\r\n\r\n          var out = {\r\n            width: 15,\r\n            height: height * 0.975 * (height / target.scrollHeight),\r\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\r\n          };\r\n\r\n          var fitAdj = 0;\r\n          if (height < 408 && this.target === document.body) {\r\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\r\n          }\r\n\r\n          if (this.target !== document.body) {\r\n            out.height = Math.max(out.height, 24);\r\n          }\r\n\r\n          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\r\n          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\r\n\r\n          if (this.target === document.body) {\r\n            out.height = Math.max(out.height, 24);\r\n          }\r\n\r\n          return out;\r\n        }\r\n      } else {\r\n        return getBounds(this.target);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'clearCache',\r\n    value: function clearCache() {\r\n      this._cache = {};\r\n    }\r\n  }, {\r\n    key: 'cache',\r\n    value: function cache(k, getter) {\r\n      // More than one module will often need the same DOM info, so\r\n      // we keep a cache which is cleared on each position call\r\n      if (typeof this._cache === 'undefined') {\r\n        this._cache = {};\r\n      }\r\n\r\n      if (typeof this._cache[k] === 'undefined') {\r\n        this._cache[k] = getter.call(this);\r\n      }\r\n\r\n      return this._cache[k];\r\n    }\r\n  }, {\r\n    key: 'enable',\r\n    value: function enable() {\r\n      var _this3 = this;\r\n\r\n      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\r\n\r\n      if (!(this.options.addTargetClasses === false)) {\r\n        addClass(this.target, this.getClass('enabled'));\r\n      }\r\n      addClass(this.element, this.getClass('enabled'));\r\n      this.enabled = true;\r\n\r\n      this.scrollParents.forEach(function (parent) {\r\n        if (parent !== _this3.target.ownerDocument) {\r\n          parent.addEventListener('scroll', _this3.position);\r\n        }\r\n      });\r\n\r\n      if (pos) {\r\n        this.position();\r\n      }\r\n    }\r\n  }, {\r\n    key: 'disable',\r\n    value: function disable() {\r\n      var _this4 = this;\r\n\r\n      removeClass(this.target, this.getClass('enabled'));\r\n      removeClass(this.element, this.getClass('enabled'));\r\n      this.enabled = false;\r\n\r\n      if (typeof this.scrollParents !== 'undefined') {\r\n        this.scrollParents.forEach(function (parent) {\r\n          parent.removeEventListener('scroll', _this4.position);\r\n        });\r\n      }\r\n    }\r\n  }, {\r\n    key: 'destroy',\r\n    value: function destroy() {\r\n      var _this5 = this;\r\n\r\n      this.disable();\r\n\r\n      tethers.forEach(function (tether, i) {\r\n        if (tether === _this5) {\r\n          tethers.splice(i, 1);\r\n        }\r\n      });\r\n\r\n      // Remove any elements we were using for convenience from the DOM\r\n      if (tethers.length === 0) {\r\n        removeUtilElements();\r\n      }\r\n    }\r\n  }, {\r\n    key: 'updateAttachClasses',\r\n    value: function updateAttachClasses(elementAttach, targetAttach) {\r\n      var _this6 = this;\r\n\r\n      elementAttach = elementAttach || this.attachment;\r\n      targetAttach = targetAttach || this.targetAttachment;\r\n      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\r\n\r\n      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\r\n        // updateAttachClasses can be called more than once in a position call, so\r\n        // we need to clean up after ourselves such that when the last defer gets\r\n        // ran it doesn't add any extra classes from previous calls.\r\n        this._addAttachClasses.splice(0, this._addAttachClasses.length);\r\n      }\r\n\r\n      if (typeof this._addAttachClasses === 'undefined') {\r\n        this._addAttachClasses = [];\r\n      }\r\n      var add = this._addAttachClasses;\r\n\r\n      if (elementAttach.top) {\r\n        add.push(this.getClass('element-attached') + '-' + elementAttach.top);\r\n      }\r\n      if (elementAttach.left) {\r\n        add.push(this.getClass('element-attached') + '-' + elementAttach.left);\r\n      }\r\n      if (targetAttach.top) {\r\n        add.push(this.getClass('target-attached') + '-' + targetAttach.top);\r\n      }\r\n      if (targetAttach.left) {\r\n        add.push(this.getClass('target-attached') + '-' + targetAttach.left);\r\n      }\r\n\r\n      var all = [];\r\n      sides.forEach(function (side) {\r\n        all.push(_this6.getClass('element-attached') + '-' + side);\r\n        all.push(_this6.getClass('target-attached') + '-' + side);\r\n      });\r\n\r\n      defer(function () {\r\n        if (!(typeof _this6._addAttachClasses !== 'undefined')) {\r\n          return;\r\n        }\r\n\r\n        updateClasses(_this6.element, _this6._addAttachClasses, all);\r\n        if (!(_this6.options.addTargetClasses === false)) {\r\n          updateClasses(_this6.target, _this6._addAttachClasses, all);\r\n        }\r\n\r\n        delete _this6._addAttachClasses;\r\n      });\r\n    }\r\n  }, {\r\n    key: 'position',\r\n    value: function position() {\r\n      var _this7 = this;\r\n\r\n      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\r\n\r\n      // flushChanges commits the changes immediately, leave true unless you are positioning multiple\r\n      // tethers (in which case call Tether.Utils.flush yourself when you're done)\r\n\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n\r\n      this.clearCache();\r\n\r\n      // Turn 'auto' attachments into the appropriate corner or edge\r\n      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\r\n\r\n      this.updateAttachClasses(this.attachment, targetAttachment);\r\n\r\n      var elementPos = this.cache('element-bounds', function () {\r\n        return getBounds(_this7.element);\r\n      });\r\n\r\n      var width = elementPos.width;\r\n      var height = elementPos.height;\r\n\r\n      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\r\n        var _lastSize = this.lastSize;\r\n\r\n        // We cache the height and width to make it possible to position elements that are\r\n        // getting hidden.\r\n        width = _lastSize.width;\r\n        height = _lastSize.height;\r\n      } else {\r\n        this.lastSize = { width: width, height: height };\r\n      }\r\n\r\n      var targetPos = this.cache('target-bounds', function () {\r\n        return _this7.getTargetBounds();\r\n      });\r\n      var targetSize = targetPos;\r\n\r\n      // Get an actual px offset from the attachment\r\n      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });\r\n      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\r\n\r\n      var manualOffset = offsetToPx(this.offset, { width: width, height: height });\r\n      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\r\n\r\n      // Add the manually provided offset\r\n      offset = addOffset(offset, manualOffset);\r\n      targetOffset = addOffset(targetOffset, manualTargetOffset);\r\n\r\n      // It's now our goal to make (element position + offset) == (target position + target offset)\r\n      var left = targetPos.left + targetOffset.left - offset.left;\r\n      var top = targetPos.top + targetOffset.top - offset.top;\r\n\r\n      for (var i = 0; i < TetherBase.modules.length; ++i) {\r\n        var _module2 = TetherBase.modules[i];\r\n        var ret = _module2.position.call(this, {\r\n          left: left,\r\n          top: top,\r\n          targetAttachment: targetAttachment,\r\n          targetPos: targetPos,\r\n          elementPos: elementPos,\r\n          offset: offset,\r\n          targetOffset: targetOffset,\r\n          manualOffset: manualOffset,\r\n          manualTargetOffset: manualTargetOffset,\r\n          scrollbarSize: scrollbarSize,\r\n          attachment: this.attachment\r\n        });\r\n\r\n        if (ret === false) {\r\n          return false;\r\n        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {\r\n          continue;\r\n        } else {\r\n          top = ret.top;\r\n          left = ret.left;\r\n        }\r\n      }\r\n\r\n      // We describe the position three different ways to give the optimizer\r\n      // a chance to decide the best possible way to position the element\r\n      // with the fewest repaints.\r\n      var next = {\r\n        // It's position relative to the page (absolute positioning when\r\n        // the element is a child of the body)\r\n        page: {\r\n          top: top,\r\n          left: left\r\n        },\r\n\r\n        // It's position relative to the viewport (fixed positioning)\r\n        viewport: {\r\n          top: top - pageYOffset,\r\n          bottom: pageYOffset - top - height + innerHeight,\r\n          left: left - pageXOffset,\r\n          right: pageXOffset - left - width + innerWidth\r\n        }\r\n      };\r\n\r\n      var doc = this.target.ownerDocument;\r\n      var win = doc.defaultView;\r\n\r\n      var scrollbarSize = undefined;\r\n      if (win.innerHeight > doc.documentElement.clientHeight) {\r\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\r\n        next.viewport.bottom -= scrollbarSize.height;\r\n      }\r\n\r\n      if (win.innerWidth > doc.documentElement.clientWidth) {\r\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\r\n        next.viewport.right -= scrollbarSize.width;\r\n      }\r\n\r\n      if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\r\n        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\r\n        next.page.bottom = doc.body.scrollHeight - top - height;\r\n        next.page.right = doc.body.scrollWidth - left - width;\r\n      }\r\n\r\n      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {\r\n        (function () {\r\n          var offsetParent = _this7.cache('target-offsetparent', function () {\r\n            return getOffsetParent(_this7.target);\r\n          });\r\n          var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {\r\n            return getBounds(offsetParent);\r\n          });\r\n          var offsetParentStyle = getComputedStyle(offsetParent);\r\n          var offsetParentSize = offsetPosition;\r\n\r\n          var offsetBorder = {};\r\n          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {\r\n            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);\r\n          });\r\n\r\n          offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\r\n          offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\r\n\r\n          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\r\n            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\r\n              // We're within the visible part of the target's scroll parent\r\n              var scrollTop = offsetParent.scrollTop;\r\n              var scrollLeft = offsetParent.scrollLeft;\r\n\r\n              // It's position relative to the target's offset parent (absolute positioning when\r\n              // the element is moved to be a child of the target's offset parent).\r\n              next.offset = {\r\n                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\r\n                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\r\n              };\r\n            }\r\n          }\r\n        })();\r\n      }\r\n\r\n      // We could also travel up the DOM and try each containing context, rather than only\r\n      // looking at the body, but we're gonna get diminishing returns.\r\n\r\n      this.move(next);\r\n\r\n      this.history.unshift(next);\r\n\r\n      if (this.history.length > 3) {\r\n        this.history.pop();\r\n      }\r\n\r\n      if (flushChanges) {\r\n        flush();\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    // THE ISSUE\r\n  }, {\r\n    key: 'move',\r\n    value: function move(pos) {\r\n      var _this8 = this;\r\n\r\n      if (!(typeof this.element.parentNode !== 'undefined')) {\r\n        return;\r\n      }\r\n\r\n      var same = {};\r\n\r\n      for (var type in pos) {\r\n        same[type] = {};\r\n\r\n        for (var key in pos[type]) {\r\n          var found = false;\r\n\r\n          for (var i = 0; i < this.history.length; ++i) {\r\n            var point = this.history[i];\r\n            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (!found) {\r\n            same[type][key] = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      var css = { top: '', left: '', right: '', bottom: '' };\r\n\r\n      var transcribe = function transcribe(_same, _pos) {\r\n        var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';\r\n        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;\r\n        if (gpu !== false) {\r\n          var yPos = undefined,\r\n              xPos = undefined;\r\n          if (_same.top) {\r\n            css.top = 0;\r\n            yPos = _pos.top;\r\n          } else {\r\n            css.bottom = 0;\r\n            yPos = -_pos.bottom;\r\n          }\r\n\r\n          if (_same.left) {\r\n            css.left = 0;\r\n            xPos = _pos.left;\r\n          } else {\r\n            css.right = 0;\r\n            xPos = -_pos.right;\r\n          }\r\n\r\n          if (window.matchMedia) {\r\n            // HubSpot/tether#207\r\n            var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;\r\n            if (!retina) {\r\n              xPos = Math.round(xPos);\r\n              yPos = Math.round(yPos);\r\n            }\r\n          }\r\n\r\n          css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';\r\n\r\n          if (transformKey !== 'msTransform') {\r\n            // The Z transform will keep this in the GPU (faster, and prevents artifacts),\r\n            // but IE9 doesn't support 3d transforms and will choke.\r\n            css[transformKey] += \" translateZ(0)\";\r\n          }\r\n        } else {\r\n          if (_same.top) {\r\n            css.top = _pos.top + 'px';\r\n          } else {\r\n            css.bottom = _pos.bottom + 'px';\r\n          }\r\n\r\n          if (_same.left) {\r\n            css.left = _pos.left + 'px';\r\n          } else {\r\n            css.right = _pos.right + 'px';\r\n          }\r\n        }\r\n      };\r\n\r\n      var moved = false;\r\n      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\r\n        css.position = 'absolute';\r\n        transcribe(same.page, pos.page);\r\n      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\r\n        css.position = 'fixed';\r\n        transcribe(same.viewport, pos.viewport);\r\n      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\r\n        (function () {\r\n          css.position = 'absolute';\r\n          var offsetParent = _this8.cache('target-offsetparent', function () {\r\n            return getOffsetParent(_this8.target);\r\n          });\r\n\r\n          if (getOffsetParent(_this8.element) !== offsetParent) {\r\n            defer(function () {\r\n              _this8.element.parentNode.removeChild(_this8.element);\r\n              offsetParent.appendChild(_this8.element);\r\n            });\r\n          }\r\n\r\n          transcribe(same.offset, pos.offset);\r\n          moved = true;\r\n        })();\r\n      } else {\r\n        css.position = 'absolute';\r\n        transcribe({ top: true, left: true }, pos.page);\r\n      }\r\n\r\n      if (!moved) {\r\n        if (this.options.bodyElement) {\r\n          this.options.bodyElement.appendChild(this.element);\r\n        } else {\r\n          var offsetParentIsBody = true;\r\n          var currentNode = this.element.parentNode;\r\n          while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {\r\n            if (getComputedStyle(currentNode).position !== 'static') {\r\n              offsetParentIsBody = false;\r\n              break;\r\n            }\r\n\r\n            currentNode = currentNode.parentNode;\r\n          }\r\n\r\n          if (!offsetParentIsBody) {\r\n            this.element.parentNode.removeChild(this.element);\r\n            this.element.ownerDocument.body.appendChild(this.element);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Any css change will trigger a repaint, so let's avoid one if nothing changed\r\n      var writeCSS = {};\r\n      var write = false;\r\n      for (var key in css) {\r\n        var val = css[key];\r\n        var elVal = this.element.style[key];\r\n\r\n        if (elVal !== val) {\r\n          write = true;\r\n          writeCSS[key] = val;\r\n        }\r\n      }\r\n\r\n      if (write) {\r\n        defer(function () {\r\n          extend(_this8.element.style, writeCSS);\r\n          _this8.trigger('repositioned');\r\n        });\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return TetherClass;\r\n})(Evented);\r\n\r\nTetherClass.modules = [];\r\n\r\nTetherBase.position = position;\r\n\r\nvar Tether = extend(TetherClass, TetherBase);\r\n/* globals TetherBase */\r\n\r\n'use strict';\r\n\r\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\r\n\r\nvar _TetherBase$Utils = TetherBase.Utils;\r\nvar getBounds = _TetherBase$Utils.getBounds;\r\nvar extend = _TetherBase$Utils.extend;\r\nvar updateClasses = _TetherBase$Utils.updateClasses;\r\nvar defer = _TetherBase$Utils.defer;\r\n\r\nvar BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\r\n\r\nfunction getBoundingRect(tether, to) {\r\n  if (to === 'scrollParent') {\r\n    to = tether.scrollParents[0];\r\n  } else if (to === 'window') {\r\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\r\n  }\r\n\r\n  if (to === document) {\r\n    to = to.documentElement;\r\n  }\r\n\r\n  if (typeof to.nodeType !== 'undefined') {\r\n    (function () {\r\n      var node = to;\r\n      var size = getBounds(to);\r\n      var pos = size;\r\n      var style = getComputedStyle(to);\r\n\r\n      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\r\n\r\n      // Account any parent Frames scroll offset\r\n      if (node.ownerDocument !== document) {\r\n        var win = node.ownerDocument.defaultView;\r\n        to[0] += win.pageXOffset;\r\n        to[1] += win.pageYOffset;\r\n        to[2] += win.pageXOffset;\r\n        to[3] += win.pageYOffset;\r\n      }\r\n\r\n      BOUNDS_FORMAT.forEach(function (side, i) {\r\n        side = side[0].toUpperCase() + side.substr(1);\r\n        if (side === 'Top' || side === 'Left') {\r\n          to[i] += parseFloat(style['border' + side + 'Width']);\r\n        } else {\r\n          to[i] -= parseFloat(style['border' + side + 'Width']);\r\n        }\r\n      });\r\n    })();\r\n  }\r\n\r\n  return to;\r\n}\r\n\r\nTetherBase.modules.push({\r\n  position: function position(_ref) {\r\n    var _this = this;\r\n\r\n    var top = _ref.top;\r\n    var left = _ref.left;\r\n    var targetAttachment = _ref.targetAttachment;\r\n\r\n    if (!this.options.constraints) {\r\n      return true;\r\n    }\r\n\r\n    var _cache = this.cache('element-bounds', function () {\r\n      return getBounds(_this.element);\r\n    });\r\n\r\n    var height = _cache.height;\r\n    var width = _cache.width;\r\n\r\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\r\n      var _lastSize = this.lastSize;\r\n\r\n      // Handle the item getting hidden as a result of our positioning without glitching\r\n      // the classes in and out\r\n      width = _lastSize.width;\r\n      height = _lastSize.height;\r\n    }\r\n\r\n    var targetSize = this.cache('target-bounds', function () {\r\n      return _this.getTargetBounds();\r\n    });\r\n\r\n    var targetHeight = targetSize.height;\r\n    var targetWidth = targetSize.width;\r\n\r\n    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\r\n\r\n    this.options.constraints.forEach(function (constraint) {\r\n      var outOfBoundsClass = constraint.outOfBoundsClass;\r\n      var pinnedClass = constraint.pinnedClass;\r\n\r\n      if (outOfBoundsClass) {\r\n        allClasses.push(outOfBoundsClass);\r\n      }\r\n      if (pinnedClass) {\r\n        allClasses.push(pinnedClass);\r\n      }\r\n    });\r\n\r\n    allClasses.forEach(function (cls) {\r\n      ['left', 'top', 'right', 'bottom'].forEach(function (side) {\r\n        allClasses.push(cls + '-' + side);\r\n      });\r\n    });\r\n\r\n    var addClasses = [];\r\n\r\n    var tAttachment = extend({}, targetAttachment);\r\n    var eAttachment = extend({}, this.attachment);\r\n\r\n    this.options.constraints.forEach(function (constraint) {\r\n      var to = constraint.to;\r\n      var attachment = constraint.attachment;\r\n      var pin = constraint.pin;\r\n\r\n      if (typeof attachment === 'undefined') {\r\n        attachment = '';\r\n      }\r\n\r\n      var changeAttachX = undefined,\r\n          changeAttachY = undefined;\r\n      if (attachment.indexOf(' ') >= 0) {\r\n        var _attachment$split = attachment.split(' ');\r\n\r\n        var _attachment$split2 = _slicedToArray(_attachment$split, 2);\r\n\r\n        changeAttachY = _attachment$split2[0];\r\n        changeAttachX = _attachment$split2[1];\r\n      } else {\r\n        changeAttachX = changeAttachY = attachment;\r\n      }\r\n\r\n      var bounds = getBoundingRect(_this, to);\r\n\r\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\r\n        if (top < bounds[1] && tAttachment.top === 'top') {\r\n          top += targetHeight;\r\n          tAttachment.top = 'bottom';\r\n        }\r\n\r\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\r\n          top -= targetHeight;\r\n          tAttachment.top = 'top';\r\n        }\r\n      }\r\n\r\n      if (changeAttachY === 'together') {\r\n        if (tAttachment.top === 'top') {\r\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\r\n            top += targetHeight;\r\n            tAttachment.top = 'bottom';\r\n\r\n            top += height;\r\n            eAttachment.top = 'top';\r\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\r\n            top -= height - targetHeight;\r\n            tAttachment.top = 'bottom';\r\n\r\n            eAttachment.top = 'bottom';\r\n          }\r\n        }\r\n\r\n        if (tAttachment.top === 'bottom') {\r\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\r\n            top -= targetHeight;\r\n            tAttachment.top = 'top';\r\n\r\n            top -= height;\r\n            eAttachment.top = 'bottom';\r\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\r\n            top += height - targetHeight;\r\n            tAttachment.top = 'top';\r\n\r\n            eAttachment.top = 'top';\r\n          }\r\n        }\r\n\r\n        if (tAttachment.top === 'middle') {\r\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\r\n            top -= height;\r\n            eAttachment.top = 'bottom';\r\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\r\n            top += height;\r\n            eAttachment.top = 'top';\r\n          }\r\n        }\r\n      }\r\n\r\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\r\n        if (left < bounds[0] && tAttachment.left === 'left') {\r\n          left += targetWidth;\r\n          tAttachment.left = 'right';\r\n        }\r\n\r\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\r\n          left -= targetWidth;\r\n          tAttachment.left = 'left';\r\n        }\r\n      }\r\n\r\n      if (changeAttachX === 'together') {\r\n        if (left < bounds[0] && tAttachment.left === 'left') {\r\n          if (eAttachment.left === 'right') {\r\n            left += targetWidth;\r\n            tAttachment.left = 'right';\r\n\r\n            left += width;\r\n            eAttachment.left = 'left';\r\n          } else if (eAttachment.left === 'left') {\r\n            left += targetWidth;\r\n            tAttachment.left = 'right';\r\n\r\n            left -= width;\r\n            eAttachment.left = 'right';\r\n          }\r\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\r\n          if (eAttachment.left === 'left') {\r\n            left -= targetWidth;\r\n            tAttachment.left = 'left';\r\n\r\n            left -= width;\r\n            eAttachment.left = 'right';\r\n          } else if (eAttachment.left === 'right') {\r\n            left -= targetWidth;\r\n            tAttachment.left = 'left';\r\n\r\n            left += width;\r\n            eAttachment.left = 'left';\r\n          }\r\n        } else if (tAttachment.left === 'center') {\r\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\r\n            left -= width;\r\n            eAttachment.left = 'right';\r\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\r\n            left += width;\r\n            eAttachment.left = 'left';\r\n          }\r\n        }\r\n      }\r\n\r\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\r\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\r\n          top += height;\r\n          eAttachment.top = 'top';\r\n        }\r\n\r\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\r\n          top -= height;\r\n          eAttachment.top = 'bottom';\r\n        }\r\n      }\r\n\r\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\r\n        if (left < bounds[0]) {\r\n          if (eAttachment.left === 'right') {\r\n            left += width;\r\n            eAttachment.left = 'left';\r\n          } else if (eAttachment.left === 'center') {\r\n            left += width / 2;\r\n            eAttachment.left = 'left';\r\n          }\r\n        }\r\n\r\n        if (left + width > bounds[2]) {\r\n          if (eAttachment.left === 'left') {\r\n            left -= width;\r\n            eAttachment.left = 'right';\r\n          } else if (eAttachment.left === 'center') {\r\n            left -= width / 2;\r\n            eAttachment.left = 'right';\r\n          }\r\n        }\r\n      }\r\n\r\n      if (typeof pin === 'string') {\r\n        pin = pin.split(',').map(function (p) {\r\n          return p.trim();\r\n        });\r\n      } else if (pin === true) {\r\n        pin = ['top', 'left', 'right', 'bottom'];\r\n      }\r\n\r\n      pin = pin || [];\r\n\r\n      var pinned = [];\r\n      var oob = [];\r\n\r\n      if (top < bounds[1]) {\r\n        if (pin.indexOf('top') >= 0) {\r\n          top = bounds[1];\r\n          pinned.push('top');\r\n        } else {\r\n          oob.push('top');\r\n        }\r\n      }\r\n\r\n      if (top + height > bounds[3]) {\r\n        if (pin.indexOf('bottom') >= 0) {\r\n          top = bounds[3] - height;\r\n          pinned.push('bottom');\r\n        } else {\r\n          oob.push('bottom');\r\n        }\r\n      }\r\n\r\n      if (left < bounds[0]) {\r\n        if (pin.indexOf('left') >= 0) {\r\n          left = bounds[0];\r\n          pinned.push('left');\r\n        } else {\r\n          oob.push('left');\r\n        }\r\n      }\r\n\r\n      if (left + width > bounds[2]) {\r\n        if (pin.indexOf('right') >= 0) {\r\n          left = bounds[2] - width;\r\n          pinned.push('right');\r\n        } else {\r\n          oob.push('right');\r\n        }\r\n      }\r\n\r\n      if (pinned.length) {\r\n        (function () {\r\n          var pinnedClass = undefined;\r\n          if (typeof _this.options.pinnedClass !== 'undefined') {\r\n            pinnedClass = _this.options.pinnedClass;\r\n          } else {\r\n            pinnedClass = _this.getClass('pinned');\r\n          }\r\n\r\n          addClasses.push(pinnedClass);\r\n          pinned.forEach(function (side) {\r\n            addClasses.push(pinnedClass + '-' + side);\r\n          });\r\n        })();\r\n      }\r\n\r\n      if (oob.length) {\r\n        (function () {\r\n          var oobClass = undefined;\r\n          if (typeof _this.options.outOfBoundsClass !== 'undefined') {\r\n            oobClass = _this.options.outOfBoundsClass;\r\n          } else {\r\n            oobClass = _this.getClass('out-of-bounds');\r\n          }\r\n\r\n          addClasses.push(oobClass);\r\n          oob.forEach(function (side) {\r\n            addClasses.push(oobClass + '-' + side);\r\n          });\r\n        })();\r\n      }\r\n\r\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\r\n        eAttachment.left = tAttachment.left = false;\r\n      }\r\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\r\n        eAttachment.top = tAttachment.top = false;\r\n      }\r\n\r\n      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {\r\n        _this.updateAttachClasses(eAttachment, tAttachment);\r\n        _this.trigger('update', {\r\n          attachment: eAttachment,\r\n          targetAttachment: tAttachment\r\n        });\r\n      }\r\n    });\r\n\r\n    defer(function () {\r\n      if (!(_this.options.addTargetClasses === false)) {\r\n        updateClasses(_this.target, addClasses, allClasses);\r\n      }\r\n      updateClasses(_this.element, addClasses, allClasses);\r\n    });\r\n\r\n    return { top: top, left: left };\r\n  }\r\n});\r\n/* globals TetherBase */\r\n\r\n'use strict';\r\n\r\nvar _TetherBase$Utils = TetherBase.Utils;\r\nvar getBounds = _TetherBase$Utils.getBounds;\r\nvar updateClasses = _TetherBase$Utils.updateClasses;\r\nvar defer = _TetherBase$Utils.defer;\r\n\r\nTetherBase.modules.push({\r\n  position: function position(_ref) {\r\n    var _this = this;\r\n\r\n    var top = _ref.top;\r\n    var left = _ref.left;\r\n\r\n    var _cache = this.cache('element-bounds', function () {\r\n      return getBounds(_this.element);\r\n    });\r\n\r\n    var height = _cache.height;\r\n    var width = _cache.width;\r\n\r\n    var targetPos = this.getTargetBounds();\r\n\r\n    var bottom = top + height;\r\n    var right = left + width;\r\n\r\n    var abutted = [];\r\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\r\n      ['left', 'right'].forEach(function (side) {\r\n        var targetPosSide = targetPos[side];\r\n        if (targetPosSide === left || targetPosSide === right) {\r\n          abutted.push(side);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (left <= targetPos.right && right >= targetPos.left) {\r\n      ['top', 'bottom'].forEach(function (side) {\r\n        var targetPosSide = targetPos[side];\r\n        if (targetPosSide === top || targetPosSide === bottom) {\r\n          abutted.push(side);\r\n        }\r\n      });\r\n    }\r\n\r\n    var allClasses = [];\r\n    var addClasses = [];\r\n\r\n    var sides = ['left', 'top', 'right', 'bottom'];\r\n    allClasses.push(this.getClass('abutted'));\r\n    sides.forEach(function (side) {\r\n      allClasses.push(_this.getClass('abutted') + '-' + side);\r\n    });\r\n\r\n    if (abutted.length) {\r\n      addClasses.push(this.getClass('abutted'));\r\n    }\r\n\r\n    abutted.forEach(function (side) {\r\n      addClasses.push(_this.getClass('abutted') + '-' + side);\r\n    });\r\n\r\n    defer(function () {\r\n      if (!(_this.options.addTargetClasses === false)) {\r\n        updateClasses(_this.target, addClasses, allClasses);\r\n      }\r\n      updateClasses(_this.element, addClasses, allClasses);\r\n    });\r\n\r\n    return true;\r\n  }\r\n});\r\n/* globals TetherBase */\r\n\r\n'use strict';\r\n\r\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\r\n\r\nTetherBase.modules.push({\r\n  position: function position(_ref) {\r\n    var top = _ref.top;\r\n    var left = _ref.left;\r\n\r\n    if (!this.options.shift) {\r\n      return;\r\n    }\r\n\r\n    var shift = this.options.shift;\r\n    if (typeof this.options.shift === 'function') {\r\n      shift = this.options.shift.call(this, { top: top, left: left });\r\n    }\r\n\r\n    var shiftTop = undefined,\r\n        shiftLeft = undefined;\r\n    if (typeof shift === 'string') {\r\n      shift = shift.split(' ');\r\n      shift[1] = shift[1] || shift[0];\r\n\r\n      var _shift = shift;\r\n\r\n      var _shift2 = _slicedToArray(_shift, 2);\r\n\r\n      shiftTop = _shift2[0];\r\n      shiftLeft = _shift2[1];\r\n\r\n      shiftTop = parseFloat(shiftTop, 10);\r\n      shiftLeft = parseFloat(shiftLeft, 10);\r\n    } else {\r\n      shiftTop = shift.top;\r\n      shiftLeft = shift.left;\r\n    }\r\n\r\n    top += shiftTop;\r\n    left += shiftLeft;\r\n\r\n    return { top: top, left: left };\r\n  }\r\n});\r\nreturn Tether;\r\n\r\n}));\r\n"

/***/ }),

/***/ 303:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(100);
__webpack_require__(103);
__webpack_require__(98);
__webpack_require__(101);
__webpack_require__(102);
__webpack_require__(97);
module.exports = __webpack_require__(99);


/***/ }),

/***/ 97:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(252))

/***/ }),

/***/ 98:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(253))

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18)(__webpack_require__(254))

/***/ })

},[303]);
//# sourceMappingURL=scripts.bundle.js.map